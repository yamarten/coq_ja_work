<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.3.2_0_6a661c5e0" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>*Qualified identifiers* (:token:`qualid`) denote *global constants* (definitions, lemmas, theorems, remarks or facts), *global variables* (parameters or axioms), *inductive types* or *constructors of inductive types*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T103445Z" creationid="yamarten" creationdate="20200509T103403Z">
        <seg>*修飾付き識別子* (:token:`qualid`) は *グローバル定数* (定義、補題、定理、注意、事実) や *グローバル変数* (パラメータや公理) 、 *帰納型* 、*帰納型のコンストラクタ* を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*Simple identifiers* (or shortly :token:`ident`) are a syntactic subset of qualified identifiers.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T103558Z" creationid="yamarten" creationdate="20200509T103558Z">
        <seg>*単純識別子* (もしくは単に :token:`ident`) は修飾付き識別子の構文上のサブセットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:g:`Prop` is the universe of *logical propositions*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T112121Z" creationid="yamarten" creationdate="20200509T112121Z">
        <seg>:g:`Prop` は *論理命題* のユニバースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:g:`Set` is is the universe of *program types* or *specifications*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T153521Z" creationid="yamarten" creationdate="20200509T153521Z">
        <seg>:g:`Set` は *プログラム型* または *仕様* のユニバースです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:g:`Type` is the type of :g:`Prop` and :g:`Set`</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T153645Z" creationid="yamarten" creationdate="20200509T153645Z">
        <seg>:g:`Type` は :g:`Prop` と :g:`Set` の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:n:`@term &lt;: @type` locally sets up the virtual machine for checking that :token:`term` has type :token:`type`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T034035Z" creationid="yamarten" creationdate="20200614T034035Z">
        <seg>:n:`@term &lt;: @type` は :token:`term` が 型 :token:`type` を持つことを検査するための仮想マシンを局所的に用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:n:`@term &lt;&lt;: @type` uses native compilation for checking that :token:`term` has type :token:`type`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T034638Z" creationid="yamarten" creationdate="20200614T034638Z">
        <seg>:n:`@term &lt;&lt;: @type` はネイティブコンパイルによって :token:`term` が 型 :token:`type` を持つことを検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:n:`let @ident := @term in @term’` denotes the local binding of :token:`term` to the variable :token:`ident` in :token:`term`’.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T043002Z" creationid="yamarten" creationdate="20200614T043002Z">
        <seg>:n:`let @ident := @term in @term’` は :token:`term'` 内の変数 :token:`ident` への :token:`term` の束縛を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>:ref:`thecoqcommands`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145020Z" creationid="yamarten" creationdate="20181104T145020Z">
        <seg>:ref:`thecoqcommands`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A binder can also be any pattern prefixed by a quote, e.g. :g:`'(x,y)`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T071250Z" creationid="yamarten" creationdate="20200510T071224Z">
        <seg>束縛子には引用符を前置した任意のパターンが使えます。 例: :g:`'(x,y)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A binding is represented by an identifier.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T043044Z" creationid="yamarten" creationdate="20200510T043044Z">
        <seg>束縛は識別子を使って表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A commented version of sources of the |Coq| standard library (including only the specifications, the proofs are removed) is available at https://coq.inria.fr/stdlib/.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150204Z" creationid="yamarten" creationdate="20181104T150204Z">
        <seg>|Coq| 標準ライブラリのコメント付きソースコード (仕様のみで、証明を省いたもの)は https://coq.inria.fr/stdlib/ で閲覧できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A companion volume to this reference manual, the |Coq| Tutorial, is aimed at gently introducing new users to developing proofs in |Coq| without assuming prior knowledge of type theory.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145957Z" creationid="yamarten" creationdate="20181104T145957Z">
        <seg>このマニュアルと対を成す |Coq| チュートリアルは、新規ユーザが型理論の知識なしに |Coq| で証明を構築できるようになるまで、優しく導入することを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pattern matching expression is used to analyze the structure of an inductive object and to apply specific treatments accordingly.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T052542Z" creationid="yamarten" creationdate="20200614T052454Z">
        <seg>パターンマッチ式は、帰納的オブジェクトの構造を分析し、その結果に応じて特定の処理をするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A text file `INSTALL` that comes with the sources explains how to install |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150123Z" creationid="yamarten" creationdate="20181104T150123Z">
        <seg>ソースに付属するテキストファイル `INSTALL` では、 |Coq| をインストールする方法について説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>About the grammars in the manual</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T103318Z" creationid="yamarten" creationdate="20181111T103318Z">
        <seg>このマニュアルにおける文法について</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstractions</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T102546Z" creationid="yamarten" creationdate="20200510T102546Z">
        <seg>関数抽象</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access identifiers, written :token:`access_ident`, are identifiers prefixed by `.` (dot) without blank.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T145950Z" creationid="yamarten" creationdate="20181111T145950Z">
        <seg>アクセス識別子 :token:`access_ident` は、識別子の前に間を空けずにドット `.` をつけたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Addendum</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150239Z" creationid="yamarten" creationdate="20181104T150239Z">
        <seg>付録</seg>
      </tuv>
    </tu>
    <tu>
      <note>おそらく識別に用いられるの意。</note>
      <tuv lang="EN-US">
        <seg>All characters are meaningful.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T114109Z" creationid="yamarten" creationdate="20181111T113921Z">
        <seg>あらゆる文字が意味を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All logical judgments in |Coq| are typing judgments.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T101610Z" creationid="yamarten" creationdate="20181007T100201Z">
        <seg>|Coq| における論理的判断は全て型付け判断です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All services of the |Coq| proof assistant are accessible by interpretation of a command language called *the vernacular*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144825Z" creationid="yamarten" creationdate="20181007T112922Z">
        <seg>|Coq| が提供する全てのサービスは、 *Vernacular* と呼ばれるコマンド言語を読み込ませることで利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An expression enclosed in square brackets ``[…]`` means at most one occurrence of this expression (this corresponds to an optional component).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T133100Z" creationid="yamarten" creationdate="20181111T104237Z">
        <seg>角括弧で囲まれた式``[…]``は、その式が最大1回出現する(省略可能な要素である)ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>プロダクトの話を見るにT-&gt;Propを関数と呼びたくなさそうなので訳として微妙</note>
      <tuv lang="EN-US">
        <seg>Applications</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T092610Z" creationid="yamarten" creationdate="20200613T092610Z">
        <seg>関数適用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As for abstractions, :g:`forall` is followed by a binder list, and products over several variables are equivalent to an iteration of one-variable products.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T084138Z" creationid="yamarten" creationdate="20200613T084138Z">
        <seg>関数抽象と同様に、 :g:`forall` には束縛子リストが続き、複数変数のプロダクトは1変数プロダクトの繰り返しになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the end, the notation “``[entry sep … sep entry]``” stands for a possibly empty sequence of expressions parsed by the “``entry``” entry, separated by the literal “``sep``”.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T105225Z" creationid="yamarten" creationdate="20181111T105040Z">
        <seg>最後に、 “``[entry sep … sep entry]``” は、 “``sep``” で区切られた “``entry``” の空であることを許す列を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binders</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T154901Z" creationid="yamarten" creationdate="20200509T154901Z">
        <seg>束縛子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blanks</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T105803Z" creationid="yamarten" creationdate="20181111T105730Z">
        <seg>空白記号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blanks are ignored but they separate tokens.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T110030Z" creationid="yamarten" creationdate="20181111T110030Z">
        <seg>空白記号はトークンの区切りとしてのみ用いられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calculus of Inductive Constructions</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181110T055945Z" creationid="yamarten" creationdate="20181110T055945Z">
        <seg>Calculus of Inductive Constructions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapters :ref:`gallinaspecificationlanguage` and :ref:`extensionsofgallina` describe the concrete syntax as well as the meaning of programs, theorems and proofs in the Calculus of Inductive Constructions.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145106Z" creationid="yamarten" creationdate="20181104T145106Z">
        <seg>:ref:`gallinaspecificationlanguage` および :ref:`extensionsofgallina` の章では、構文および Calculus of Inductive Constructions におけるプログラムや証明・定理の意味について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`calculusofinductiveconstructions` is a mathematical description of the formalism.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145128Z" creationid="yamarten" creationdate="20181104T145128Z">
        <seg>:ref:`calculusofinductiveconstructions` の章は数学の形式的な説明です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`thecoqlibrary` describes the standard library of |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145114Z" creationid="yamarten" creationdate="20181104T145114Z">
        <seg>:ref:`thecoqlibrary` の章では |Coq| の標準ライブラリについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`themodulesystem` describes the module system.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145130Z" creationid="yamarten" creationdate="20181104T145130Z">
        <seg>:ref:`themodulesystem` の章ではモジュールシステムについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>"requests to the environment"が指すものがわかっていない。環境ってどの辺りなんだろう。宣言とかの話なのか、Setみたいなより広い話を含んでいるのか。</note>
      <tuv lang="EN-US">
        <seg>Chapter :ref:`vernacularcommands` presents all commands (we call them *vernacular commands*) that are not directly related to interactive proving: requests to the environment, complete or partial evaluation, loading and compiling files.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145429Z" creationid="yamarten" creationdate="20181104T145429Z">
        <seg>:ref:`vernacularcommands` の章では、対話的証明と直接的には関係のないコマンド (*Vernacular コマンド*) を全て挙げます。コマンドは、環境への要求、完全/部分的な評価、ファイルの読み込みやコンパイルなどを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T110032Z" creationid="yamarten" creationdate="20181111T110032Z">
        <seg>コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments are treated as blanks.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T110455Z" creationid="yamarten" creationdate="20181111T110455Z">
        <seg>コメントは空白記号として扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments in Coq are enclosed between ``(*`` and ``*)``, and can be nested.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T110139Z" creationid="yamarten" creationdate="20181111T110119Z">
        <seg>Coqのコメントは ``(*`` と ``*)`` で囲まれた部分で、入れ子にすることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>唐突に「Coq」から外れる縦棒。どうも付けるとsmallcapクラスが付くっぽいのだけど、スモールキャピタルにはなっているわけでもなく、特に意味は無さそう。
</note>
      <tuv lang="EN-US">
        <seg>Coq has an interactive mode in which commands are interpreted as the user types them in from the keyboard and a compiled mode where commands are processed from a file.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T114048Z" creationid="yamarten" creationdate="20181007T113510Z">
        <seg>Coq には、ユーザが入力した端からコマンドを実行していく対話モードと、ファイルに書かれたコマンドを順に実行していくコンパイルモードがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coq terms are typed.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T100627Z" creationid="yamarten" creationdate="20200509T100617Z">
        <seg>Coq の項には型が付きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Coq types are recognized by the same syntactic class as :token:`term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T101548Z" creationid="yamarten" creationdate="20200509T101429Z">
        <seg>Coqの型は項と同様に :token:`term` 構文クラスとして認識されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Definition by case analysis</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T051243Z" creationid="yamarten" creationdate="20200614T051243Z">
        <seg>場合分けによる定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of tactics are described in Chapter :ref:`detailedexamplesoftactics`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145621Z" creationid="yamarten" creationdate="20181104T145621Z">
        <seg>タクティックの具体例は :ref:`detailedexamplesoftactics` の章で説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions often contain redundant pieces of information.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T041136Z" creationid="yamarten" creationdate="20200614T035110Z">
        <seg>式には冗長な情報片が含まれることがよくあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions of this syntax are given in Chapter :ref:`extensionsofgallina`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T100442Z" creationid="yamarten" creationdate="20200509T100328Z">
        <seg>この構文の拡張は :ref:`extensionsofgallina` の章にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, Chapter :ref:`coqintegrateddevelopmentenvironment` describes CoqIDE.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145816Z" creationid="yamarten" creationdate="20181104T145816Z">
        <seg>最後に、 :ref:`coqintegrateddevelopmentenvironment` の章で、 CoqIDE について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the |SSR| proof language is presented in Chapter :ref:`thessreflectprooflanguage`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145630Z" creationid="yamarten" creationdate="20181104T145630Z">
        <seg>最後に、証明言語 |SSR| について :ref:`thessreflectprooflanguage` の章で説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>compile mode じゃなかったのかよ。</note>
      <tuv lang="EN-US">
        <seg>First in Chapter :ref:`thecoqcommands`, the usage of `coqc` (batch mode) and `coqtop` (interactive mode) with their options is described.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145714Z" creationid="yamarten" creationdate="20181104T145714Z">
        <seg>まず、 :ref:`thecoqcommands` の章で、`coqc` (コンパイルモード) と `coqtop` (対話モード) の使い方およびオプションについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance the expression “fun :token:`ident`\ :math:`_{1}` … :token:`ident`\ :math:`_{n}` : :token:`type` =&gt; :token:`term`” denotes the same function as “ fun :token:`ident`\ :math:`_{1}` : :token:`type` =&gt; … fun :token:`ident`\ :math:`_{n}` : :token:`type` =&gt; :token:`term`”.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T074426Z" creationid="yamarten" creationdate="20200613T074426Z">
        <seg>例えば “fun :token:`ident`\ :math:`_{1}` … :token:`ident`\ :math:`_{n}` : :token:`type` =&gt; :token:`term`” は “ fun :token:`ident`\ :math:`_{1}` : :token:`type` =&gt; … fun :token:`ident`\ :math:`_{n}` : :token:`type` =&gt; :token:`term`”と同じ関数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions over several variables are equivalent to an iteration of one-variable functions.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T074236Z" creationid="yamarten" creationdate="20200613T074236Z">
        <seg>複数変数の関数は1変数関数の繰り返しと同義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammars are presented in Backus-Naur form (BNF).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T103807Z" creationid="yamarten" creationdate="20181111T103520Z">
        <seg>文法は Backus-Naur 形式 (BNF) で表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to customize the syntax is described in Chapter :ref:`syntaxextensionsandinterpretationscopes`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T100533Z" creationid="yamarten" creationdate="20200509T100527Z">
        <seg>構文のカスタマイズ方法については :ref:`syntaxextensionsandinterpretationscopes` の章で説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to read this book</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144922Z" creationid="yamarten" creationdate="20181104T144922Z">
        <seg>この文書の読み方</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to start and stop proofs, do multiple proofs in parallel is explained in Chapter :ref:`proofhandling`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145435Z" creationid="yamarten" creationdate="20181104T145435Z">
        <seg>どのように証明を始め、終わればいいのか、どうすれば証明を並行して進めることができるかは、 :ref:`proofhandling` の章で説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, :token:`string` literals must be correctly closed.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T110410Z" creationid="yamarten" creationdate="20181111T110410Z">
        <seg>ただし、 :token:`string` リテラルは正しく閉じられねばなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <note>access identifier は「(モジュール等の)内部にアクセスするための識別子」くらいの意味なんだろうけど、世の中的にはaccess modifier(publicとか)の意味でたまに使われることがあるらしく、微妙にややこしい。ここでしか出てこないからいいけど。</note>
      <tuv lang="EN-US">
        <seg>Identifiers and access identifiers</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T112746Z" creationid="yamarten" creationdate="20181111T110531Z">
        <seg>識別子とアクセス識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifiers may also denote *local variables*, while qualified identifiers do not.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T103750Z" creationid="yamarten" creationdate="20200509T103750Z">
        <seg>識別子は *ローカル変数* を表すこともありますが、修飾付き識別子がローカル変数を表すことはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifiers, written :token:`ident`, are sequences of letters, digits, ``_`` and ``'``, that do not start with a digit or ``'``.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T112938Z" creationid="yamarten" creationdate="20181111T112755Z">
        <seg>識別子 :token:`ident` は、文字・数字・ ``_`` ・ ``'`` の列で、数字および ``'`` で始まらないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a let-binder occurs in the list of binders, it is expanded to a let-in definition (see Section :ref:`let-in`).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T075250Z" creationid="yamarten" creationdate="20200613T075250Z">
        <seg>束縛子リストの中にlet束縛子があった場合、それはlet-in定義に展開されます。(:ref:`let-in` を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the binding variable is not used in the expression, the identifier can be replaced by the symbol :g:`_`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T043210Z" creationid="yamarten" creationdate="20200510T043210Z">
        <seg>もし束縛変数をその式で使わないなら、識別子の代わりに :g:`_` を使うこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the variable :token:`ident` occurs in :token:`term`, the product is called *dependent product*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T085214Z" creationid="yamarten" creationdate="20200613T085214Z">
        <seg>:token:`ident` が :token:`term` 中に現れる場合、そのプロダクトを *依存積* と呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Chapter :ref:`tactics`, all commands that realize one or more steps of the proof are presented: we call them *tactics*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145557Z" creationid="yamarten" creationdate="20181104T145557Z">
        <seg>:ref:`tactics` の章では、証明の1つまたは複数のステップを成すコマンド (*タクティック*) を全て挙げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Coq, logical objects are typed to ensure their logical correctness.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T102932Z" creationid="yamarten" creationdate="20181111T102932Z">
        <seg>Coqにおいて、論理的対象は型付けされることで、その正しさが保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a let-binder, only one variable can be introduced at the same time.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T074909Z" creationid="yamarten" creationdate="20200510T074909Z">
        <seg>let束縛子では、一度に一つの変数のみ導入できます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>とっくの昔に消えているような気がする。</note>
      <tuv lang="EN-US">
        <seg>In a second step, the user can read also the tutorial on recursive types (document `RecTutorial.ps`).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150007Z" creationid="yamarten" creationdate="20181104T150007Z">
        <seg>その後は、再帰型についてのチュートリアル (`RecTutorial.ps`) を読むのもいいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, there are special notations for regular expressions.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T103827Z" creationid="yamarten" creationdate="20181111T103758Z">
        <seg>さらに、正規表現のための特殊な記法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In grammars, the entry for quoted strings is :production:`string`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190213T142616Z" creationid="yamarten" creationdate="20190213T142616Z">
        <seg>文法においては、文字列は :production:`string`  というエントリで表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In interactive mode, users can develop their theories and proofs step by step, and query the system for available theorems and definitions.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T122200Z" creationid="yamarten" creationdate="20181007T122200Z">
        <seg>対話モードでは、ユーザは順を追って証明を構築したり、利用できる定理や定義をシステムに問い合わせたりできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, identifiers are case-sensitive.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T114152Z" creationid="yamarten" creationdate="20181111T114152Z">
        <seg>特に、識別子の大文字・小文字は区別されます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>funやforallでlet束縛するとletに変換されるため、おそらくそのこと</note>
      <tuv lang="EN-US">
        <seg>In the case of :g:`fun` and :g:`forall`, it is intended that at least one binder of the list is an assumption otherwise fun and forall gets identical.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T094157Z" creationid="yamarten" creationdate="20200510T092626Z">
        <seg>:g:`fun` や :g:`forall` の場合、リストの中で少なくとも1つの束縛子が仮定であることを意図しています。そうでない場合、 fun と forall は同じ意味になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the fourth part more practical tools are documented.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145717Z" creationid="yamarten" creationdate="20181104T145650Z">
        <seg>第4部はより実用的なツールについて文書化しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indexes</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150216Z" creationid="yamarten" creationdate="20181104T150216Z">
        <seg>索引</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inferable subterms</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T034943Z" creationid="yamarten" creationdate="20200614T034943Z">
        <seg>推論可能な部分項</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initially, numerals are bound to Peano’s representation of natural numbers (see :ref:`datatypes`).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T104435Z" creationid="yamarten" creationdate="20200509T104435Z">
        <seg>初期状態では、数字列は自然数のペアノ表現に紐づけられています。 (:ref:`datatypes` を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Installation</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150013Z" creationid="yamarten" creationdate="20181104T150013Z">
        <seg>インストール方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers are numerals optionally preceded by a minus sign.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190213T141914Z" creationid="yamarten" creationdate="20190213T140737Z">
        <seg>整数は、数字列もしくは数字列の先頭にマイナス記号が付いたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T034937Z" creationid="yamarten" creationdate="20181007T033312Z">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It allows developing mathematical theories and to prove specifications of programs.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T101002Z" creationid="yamarten" creationdate="20181111T100823Z">
        <seg>Gallinaは、数学的な理論の構築やプログラムの仕様の証明を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It denotes a function of the variable :token:`ident` that evaluates to the expression :token:`term` (e.g. :g:`fun x : A =&gt; x` denotes the identity function on type :g:`A`).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T115701Z" creationid="yamarten" creationdate="20200510T115701Z">
        <seg>これは、変数 :token:`ident`の関数を表し、:token:`term` に評価されます。 (例: :g:`fun x : A =&gt; x` は型 :g:`A` 上の恒等関数を表します)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It denotes either the universal quantification of the variable :g:`x` of type :g:`A` in the proposition :g:`B` or the functional dependent product from :g:`A` to :g:`B` (a construction usually written :math:`\Pi_{x:A}.B` in set theory).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T091443Z" creationid="yamarten" creationdate="20200613T090848Z">
        <seg>命題 :g:`B` 内の :g:`A` 型の変数 :g:`x` の全称量化と、:g:`A` から :g:`B` への依存関数型(型理論では一般に :math:`\Pi_{x:A}.B` と表記される構造)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It enforces the type of :token:`term` to be :token:`type`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T023636Z" creationid="yamarten" creationdate="20200614T023636Z">
        <seg>:token:`term` の型を :token:`type` に強制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to give the type of the variable as follows: :n:`(@ident : @type := @term)`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T075641Z" creationid="yamarten" creationdate="20200510T075520Z">
        <seg>変数の型を与えることもできます: :n:`(@ident : @type := @term)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is divided in six chapters.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145403Z" creationid="yamarten" creationdate="20181104T145403Z">
        <seg>ここは6つの章に分かれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is equivalent to ( … ( :token:`term`\ :math:`_0` :token:`term`\ :math:`_1` ) … ) :token:`term`\ :math:`_n` : associativity is to the left.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T022601Z" creationid="yamarten" creationdate="20200614T022311Z">
        <seg>これは ( … ( :token:`term`\ :math:`_0` :token:`term`\ :math:`_1` ) … ) :token:`term`\ :math:`_n` と同義で、左結合になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a specification language named |Gallina|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T080633Z" creationid="yamarten" creationdate="20181007T080342Z">
        <seg>Coqは、 |Gallina| と呼ばれる仕様記述言語を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190213T142620Z" creationid="yamarten" creationdate="20190213T142620Z">
        <seg>キーワード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let-in definitions</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T041815Z" creationid="yamarten" creationdate="20200614T041807Z">
        <seg>let-in定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexical ambiguities are resolved according to the “longest match” rule: when a sequence of non alphanumerical characters can be decomposed into several different ways, then the first token is the longest possible one (among all tokens defined at this moment), and so on.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T095500Z" creationid="yamarten" creationdate="20190217T070020Z">
        <seg>字句解析時の曖昧性は、「最長一致」の原則に従って解消されます。つまり、英数字以外の文字の並びに複数の解釈がある場合、最初のトークンが(その時に定義されているトークンの中で)可能な限り最長なものになり、以降も同様に選ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexical conventions</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T105629Z" creationid="yamarten" creationdate="20181111T105629Z">
        <seg>字句規則</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>License</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150242Z" creationid="yamarten" creationdate="20181104T150242Z">
        <seg>ライセンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Links to several tutorials can be found at https://coq.inria.fr/documentation and https://github.com/coq/coq/wiki#coq-tutorials</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T035722Z" creationid="yamarten" creationdate="20181007T035722Z">
        <seg>https://coq.inria.fr/documentation や https://github.com/coq/coq/wiki#coq-tutorials には、幾つかのチュートリアルへのリンクがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>List of additional documentation</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145841Z" creationid="yamarten" creationdate="20181104T145841Z">
        <seg>その他の文書一覧</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lists of :token:`binder` are allowed.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T075739Z" creationid="yamarten" creationdate="20200510T075739Z">
        <seg>:token:`binder` のリストも使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More on sorts can be found in Section :ref:`sorts`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T153728Z" creationid="yamarten" creationdate="20200509T153728Z">
        <seg>ソートの詳細については :ref:`sorts` を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, parentheses can be omitted in the case of a single sequence of bindings sharing the same type (e.g.: :g:`fun (x y z : A) =&gt; t` can be shortened in :g:`fun x y z : A =&gt; t`).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T115707Z" creationid="yamarten" creationdate="20200510T100143Z">
        <seg>さらに、同じ型を持つ束縛の列一つの場合は括弧を省くことができます。 (例: :g:`fun (x y z : A) =&gt; t` は :g:`fun x y z : A =&gt; t` と略記できます) </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, |Coq|’s compiler provides an output file containing a compact representation of its input.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144902Z" creationid="yamarten" creationdate="20181104T144902Z">
        <seg>さらに、 |Coq| コンパイラは、入力のコンパクトな表現を持つ出力ファイルを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Natural numbers and integers</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190213T134928Z" creationid="yamarten" creationdate="20190213T134928Z">
        <seg>自然数と整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative integers are not at the same level as :token:`num`, for this would make precedence unnatural.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T105424Z" creationid="yamarten" creationdate="20200509T105424Z">
        <seg>負の整数は :token:`num` と同じレベルにはありません。これは、優先順位が不自然になってしまうためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non dependent product types have a special notation: :g:`A -&gt; B` stands for :g:`forall _ : A, B`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T091958Z" creationid="yamarten" creationdate="20200613T091719Z">
        <seg>依存積でないプロダクトは特別な記法 :g:`A -&gt; B` を持ち、 :g:`forall _ : A, B` を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, the manual has some structure that is explained below.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145002Z" creationid="yamarten" creationdate="20181104T145002Z">
        <seg>とはいえ、このマニュアルも以下のような構造を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that :token:`term` is intended to be a type.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T084227Z" creationid="yamarten" creationdate="20200613T084227Z">
        <seg>:token:`term` は型を意図していることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numerals</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T103808Z" creationid="yamarten" creationdate="20200509T103808Z">
        <seg>数字列</seg>
      </tuv>
    </tu>
    <tu>
      <note>digitとnumeralの訳し分けが厳しかったので情報を足した
おそらく今後はnumeralも「数字」と訳すことがある</note>
      <tuv lang="EN-US">
        <seg>Numerals are sequences of digits.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190217T071125Z" creationid="yamarten" creationdate="20190213T140719Z">
        <seg>数字列はアラビア数字の並びによって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numerals have no definite semantics in the calculus.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T103953Z" creationid="yamarten" creationdate="20200509T103953Z">
        <seg>数字列は、この計算体系で明確な意味を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects of inductive types can be destructurated by a case-analysis construction called *pattern matching* expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T052100Z" creationid="yamarten" creationdate="20200614T051650Z">
        <seg>帰納型のオブジェクトは *パターンマッチ* 式という場合分け用の構造によって分解できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionally, you can enhance it with the minor mode Company-Coq :cite:`Pit16` (see https://github.com/cpitclaudel/company-coq).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150319Z" creationid="yamarten" creationdate="20181104T150319Z">
        <seg>また、マイナーモード Company-Coq :cite:`Pit16` (https://github.com/cpitclaudel/company-coq) で拡張することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Options A and B are not elected.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150310Z" creationid="yamarten" creationdate="20181104T150310Z">
        <seg>オプションAおよびBは選択しない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Practical tools</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150232Z" creationid="yamarten" creationdate="20181104T150232Z">
        <seg>実用ツール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preamble</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150219Z" creationid="yamarten" creationdate="20181104T150219Z">
        <seg>はじめに</seg>
      </tuv>
    </tu>
    <tu>
      <note>世に言うproduct type(直積型)ではないことに注意
</note>
      <tuv lang="EN-US">
        <seg>Products</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T083658Z">
        <seg>プロダクト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To:
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T035013Z" creationid="yamarten" creationdate="20181007T035013Z">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To:
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To: 
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T035446Z" creationid="yamarten" creationdate="20181007T035446Z">
        <seg>Project-Id-Version: Coq 8.8.2
Report-Msgid-Bugs-To: 
POT-Creation-Date: 2018-10-07 10:53+0900
PO-Revision-Date: 2018-10-07 10:53+0900
Last-Translator: Automatically generated
Language-Team: none
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Language: ja
Plural-Forms: nplurals=1; plural=0;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proof-General is available at https://proofgeneral.github.io/.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150315Z" creationid="yamarten" creationdate="20181104T150315Z">
        <seg>Proof-General は https://proofgeneral.github.io/から入手可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Qualified identifiers and simple identifiers</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T102126Z" creationid="yamarten" creationdate="20200509T102126Z">
        <seg>修飾付き識別子と単純識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Section :ref:`Mult-match` and Chapter :ref:`extendedpatternmatching` for the description of the general form.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T052828Z" creationid="yamarten" creationdate="20200614T052828Z">
        <seg>形式全般についての説明は :ref:`Mult-match や ref:`extendedpatternmatching` の章を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See the table of contents for a complete list.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145836Z" creationid="yamarten" creationdate="20181104T145836Z">
        <seg>全ての項目を知りたい場合は、目次を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the notation “``entry … entry``” stands for a non empty sequence of expressions parsed by the “``entry``” entry, without any separator between.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T105029Z" creationid="yamarten" creationdate="20181111T104853Z">
        <seg>同様に、 “``entry … entry``” は区切り文字を含まない “``entry``” の空でない列を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some constructions allow the binding of a variable to value.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T072521Z" creationid="yamarten" creationdate="20200510T072521Z">
        <seg>一部の構造では変数を値に束縛できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Space, newline and horizontal tabulation are considered as blanks.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T105924Z" creationid="yamarten" creationdate="20181111T105759Z">
        <seg>スペース・改行・水平タブは空白記号として見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special tokens</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190213T142954Z" creationid="yamarten" creationdate="20190213T142954Z">
        <seg>特殊トークン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190213T141921Z" creationid="yamarten" creationdate="20190213T141921Z">
        <seg>文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings are delimited by ``"`` (double quote), and enclose a sequence of any characters different from ``"`` or the sequence ``""`` to denote the double quote character.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190217T070104Z" creationid="yamarten" creationdate="20190213T142519Z">
        <seg>文字列は、 ``"`` (二重引用符)で囲まれた任意の(``"`` 以外の)任意の文字の並びと、二重引用符の文字を表す ``""`` を指します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subterms that can be automatically inferred by Coq can be replaced by the symbol ``_`` and Coq will guess the missing piece of information.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T041715Z" creationid="yamarten" creationdate="20200614T041715Z">
        <seg>Coqが自動推論できる部分項はシンボル ``_`` によって置換することで、Coqが欠けた情報を推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax of terms</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T095609Z" creationid="yamarten" creationdate="20200509T095609Z">
        <seg>項の構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table of contents</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150213Z" creationid="yamarten" creationdate="20181104T150213Z">
        <seg>目次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Terminal symbols are set in black ``typewriter font``.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T103714Z" creationid="yamarten" creationdate="20181111T103645Z">
        <seg>終端記号には黒い``タイプライタ体``を用います。</seg>
      </tuv>
    </tu>
    <tu>
      <note>as well asのニュアンスを落としてるので、「仕様記述言語のはずでは？」となりそうな気もする</note>
      <tuv lang="EN-US">
        <seg>Terms of |Gallina| can represent programs as well as properties of these programs and proofs of these properties.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T081041Z" creationid="yamarten" creationdate="20181007T081041Z">
        <seg>|Gallina| の項はプログラム・プログラムの性質・性質の証明を表現できます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>字句クラスというのはつまり「ident」とかのこと。http://ocaml.jp/?Genlex でもそう訳されていたし、他に出てこないのでとりあえずいいことにする。</note>
      <tuv lang="EN-US">
        <seg>That is, they are recognized by the following lexical class:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T113842Z" creationid="yamarten" creationdate="20181111T113842Z">
        <seg>つまり、次の字句クラスによって認識されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The *non dependent product* is used both to denote the propositional implication and function types.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T091953Z" creationid="yamarten" creationdate="20200613T091953Z">
        <seg>*非依存積* は命題の論理包含と関数型を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Gallina specification language</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181110T115315Z" creationid="yamarten" creationdate="20181110T115315Z">
        <seg>仕様記述言語 Gallina</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The `coqtop` read-eval-print-loop can also be used directly, for debugging purposes.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144829Z" creationid="yamarten" creationdate="20181104T111736Z">
        <seg>デバッグのために、 read-eval-print-loop である `coqtop` を直接用いることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic form of pattern matching is characterized by a single :token:`match_item` expression, a :token:`mult_pattern` restricted to a single :token:`pattern` and :token:`pattern` restricted to the form :n:`@qualid {* @ident}`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T053659Z" creationid="yamarten" creationdate="20200614T053659Z">
        <seg>パターンマッチの基本的な形式は、1つの :token:`match_item` 式、1つの:token:`pattern` 式のみの :token:`match_item` 、そして :n:`@qualid {* @ident}` 形式の :token:`pattern` によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiled mode acts as a proof checker taking a file containing a whole development in order to ensure its correctness.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144849Z" creationid="yamarten" creationdate="20181104T144849Z">
        <seg>コンパイルモードは、開発したもの全てを受け取り、その正当性を保証する証明チェッカとして機能します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiled mode is run with the `coqc` command.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144910Z" creationid="yamarten" creationdate="20181104T144910Z">
        <seg>コンパイルモードは `coqc` コマンドで実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entry :token:`binder` of the grammar accepts either an assumption binder as defined above or a let-binder.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T074044Z" creationid="yamarten" creationdate="20200510T073948Z">
        <seg>:token:`binder` エントリは、上で定義した仮定束縛子またはlet束縛子のいずれかになります。</seg>
      </tuv>
    </tu>
    <tu>
      <note>non-exhaustivelyがよくわかっていない。最初は「Unicodeならなんでもというわけではない」(「あ」は有るが「。」は無いとか)くらいの意味かと思ったけど、それだと後ろの方の意味が取れない。例に挙げたもので全てではない、みたいな意味？</note>
      <tuv lang="EN-US">
        <seg>The entry ``unicode-letter`` non-exhaustively includes Latin, Greek, Gothic, Cyrillic, Arabic, Hebrew, Georgian, Hangul, Hiragana and Katakana characters, CJK ideographs, mathematical letter-like symbols, hyphens, non-breaking space, … The entry ``unicode-id-part`` non-exhaustively includes symbols for prime letters and subscripts.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T145759Z" creationid="yamarten" creationdate="20181111T142500Z">
        <seg>``unicode-letter`` エントリには、ラテン文字・ギリシャ文字・ゴート文字・キリル文字・アラビア文字・ヘブライ文字・グルジア文字・ハングル・ひらがな・カタカナ・CJK漢字・数学記号・ハイフン・改行禁止スペースといった文字が非網羅的に含まれます。 ``unicode-id-part`` エントリには、プライム記号や下付き文字などが含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression :n:`@term : @type` is a type cast expression.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T023549Z" creationid="yamarten" creationdate="20200614T023549Z">
        <seg>式 :n:`@term : @type` は型キャスト式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression :n:`forall @ident : @type, @term` denotes the *product* of the variable :token:`ident` of type :token:`type`, over the term :token:`term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T083945Z" creationid="yamarten" creationdate="20200613T083945Z">
        <seg>式 :n:`forall @ident : @type, @term` は、 :token:`type`型の変数 :token:`ident` の :token:`term` に関する *プロダクト* を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression :n:`fun @ident : @type =&gt; @term` defines the *abstraction* of the variable :token:`ident`, of type :token:`type`, over the term :token:`term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T114433Z" creationid="yamarten" creationdate="20200510T114433Z">
        <seg>式 :n:`fun @ident : @type =&gt; @term` は、:token:`type` 型の変数 :token:`ident` を持つ *関数抽象* を項 :token:`term` に対して定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression :token:`term`\ :math:`_0` :token:`term`\ :math:`_1` ... :token:`term`\ :math:`_n` denotes the application of the term :token:`term`\ :math:`_0` to the arguments :token:`term`\ :math:`_1` ... then :token:`term`\ :math:`_n`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T022253Z" creationid="yamarten" creationdate="20200614T022123Z">
        <seg>式 :token:`term`\ :math:`_0` :token:`term`\ :math:`_1` ... :token:`term`\ :math:`_n` は項 :token:`term`\ :math:`_0` の引数 :token:`term`\ :math:`_1` ... then :token:`term`\ :math:`_n` への関数適用を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression :token:`term`\ :math:`_0` :token:`term`\ :math:`_1` denotes the application of :token:`term`\ :math:`_0` to :token:`term`\ :math:`_1`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T021828Z" creationid="yamarten" creationdate="20200614T020151Z">
        <seg>式 :token:`term`\ :math:`_0` :token:`term`\ :math:`_1` は :token:`term`\ :math:`_0` の :token:`term`\ :math:`_1` への関数適用を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <note>原文の引用符の範囲に誤りあり</note>
      <tuv lang="EN-US">
        <seg>The expression match ":token:`term`:math:`_0` :token:`return_type` with :token:`pattern`:math:`_1` =&gt; :token:`term`:math:`_1` :math:`|` … :math:`|` :token:`pattern`:math:`_n` =&gt; :token:`term`:math:`_n` end" denotes a *pattern matching* over the term :token:`term`:math:`_0` (expected to be of an inductive type :math:`I`).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T055707Z" creationid="yamarten" creationdate="20200614T053714Z">
        <seg>式 "match :token:`term`:math:`_0` :token:`return_type` with :token:`pattern`:math:`_1` =&gt; :token:`term`:math:`_1` :math:`|` … :math:`|` :token:`pattern`:math:`_n` =&gt; :token:`term`:math:`_n` end" は、(帰納型 :math:`I` を持つ) :token:`term`:math:`_0` に対する *パターンマッチ* を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fifth part documents a number of advanced features, including coercions, canonical structures, typeclasses, program extraction, and specialized solvers and tactics.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145822Z" creationid="yamarten" creationdate="20181104T145822Z">
        <seg>第5部では、型強制・正準構造・型クラス・プログラム抽出・特殊なソルバとタクティックといった、いくつかの高度な機能について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first part describes the specification language, |Gallina|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145011Z" creationid="yamarten" creationdate="20181104T145011Z">
        <seg>第1部では、仕様記述言語 |Gallina| について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following grammars describe the basic syntax of the terms of the *Calculus of Inductive Constructions* (also called Cic).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T095827Z" creationid="yamarten" creationdate="20200509T095807Z">
        <seg>次の文法は *Calculus of Inductibe Constructions* (Cic とも呼ばれます)の項の基本的な構文を示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following identifiers are reserved keywords, and cannot be employed otherwise::</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190213T142907Z" creationid="yamarten" creationdate="20190213T142907Z">
        <seg>以下の識別子は予約語であり、定められた用途以外に使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following sequences of characters are special tokens::</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190213T143735Z" creationid="yamarten" creationdate="20190213T143735Z">
        <seg>以下の文字列は特殊なトークンとして扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The formal presentation of Cic is given in Chapter :ref:`calculusofinductiveconstructions`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T100448Z" creationid="yamarten" creationdate="20200509T100259Z">
        <seg>Cic の形式的な表記は、 :ref:`calculusofinductiveconstructions` の章にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <note>クレジットへのリンクは張らないのか？</note>
      <tuv lang="EN-US">
        <seg>The history of this formalism as well as pointers to related work are provided in a separate chapter; see *Credits*.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The intention behind a dependent product :g:`forall x : A, B` is twofold.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T090552Z" creationid="yamarten" creationdate="20200613T090542Z">
        <seg>依存積 :g:`forall x : A, B` には2つの意図があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interactive mode is generally run with the help of an IDE, such as CoqIDE, documented in :ref:`coqintegrateddevelopmentenvironment`, Emacs with Proof-General :cite:`Asp00` [#PG]_, or jsCoq to run Coq in your browser (see https://github.com/ejgallego/jscoq).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T161431Z" creationid="yamarten" creationdate="20181104T111701Z">
        <seg>対話モードは一般的に, CoqIDE (:ref:`coqintegrateddevelopmentenvironment` にて記載)やProof-General :cite:`Asp00` [#PG]_ を入れた Emacs 、またはブラウザ上で動作する jsCoq (https://github.com/ejgallego/jscoq) のようなIDEの助けを借りて実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The keyword :g:`fun` can be followed by several binders as given in Section :ref:`binders`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200613T062039Z" creationid="yamarten" creationdate="20200613T062039Z">
        <seg>キーワード :g:`fun` には :ref:`binders` の節で定めた束縛子を複数続けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150221Z" creationid="yamarten" creationdate="20181104T150221Z">
        <seg>言語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language of commands, called *The Vernacular* is described in Section :ref:`vernacular`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T102721Z" creationid="yamarten" creationdate="20181111T102721Z">
        <seg>*Vernacular* と呼ばれるコマンド言語については、 :ref:`vernacular` の節で説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language to combine these tactics into complex proof strategies is given in Chapter :ref:`ltac`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145611Z" creationid="yamarten" creationdate="20181104T145611Z">
        <seg>これらのタクティックを組み合わせて複雑な証明戦略を作るための言語については :ref:`ltac` の章で述べています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The logical propositions themselves are typing the proofs.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T144420Z" creationid="yamarten" creationdate="20200509T144420Z">
        <seg>論理命題自体は証明の型になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The notation :n:`(@ident := @term)` for arguments is used for making explicit the value of implicit arguments (see Section :ref:`explicit-applications`).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T023159Z" creationid="yamarten" creationdate="20200614T023159Z">
        <seg>記法 :n:`(@ident := @term)` は暗黙の引数の値を明示するために使います。 (:ref:`explicit-application` を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The notation in the latter case is :n:`(@ident := @term)`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T074754Z" creationid="yamarten" creationdate="20200510T074754Z">
        <seg>後者の記法として :n:`(@ident := @term)`があります。</seg>
      </tuv>
    </tu>
    <tu>
      <note>entryはタイプライタ体にしなくていいのだろうか。</note>
      <tuv lang="EN-US">
        <seg>The notation “``entry sep … sep entry``” stands for a non empty sequence of expressions parsed by entry and separated by the literal “``sep``” [1]_.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T104632Z" creationid="yamarten" creationdate="20181111T104317Z">
        <seg>“``entry sep … sep entry``”という記法は、 “``sep``” [1]_ で区切られた、 entry としてパースされる式の、空でない列を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The proof engine</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150224Z" creationid="yamarten" creationdate="20181104T150224Z">
        <seg>証明エンジン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules implemented by the typing algorithm are described in Chapter :ref:`calculusofinductiveconstructions`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T100402Z" creationid="yamarten" creationdate="20181111T103139Z">
        <seg>型付けアルゴリズムで実装されている規則は、 :ref:`calculusofinductiveconstructions` の章で説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second part describes the proof engine.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145355Z" creationid="yamarten" creationdate="20181104T145355Z">
        <seg>第2部では、証明エンジンについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specifications themselves are typing the programs.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T153542Z" creationid="yamarten" creationdate="20200509T153542Z">
        <seg>仕様はプログラムの型になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax of logical objects involved in theories is described in Section :ref:`term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T102613Z" creationid="yamarten" creationdate="20181111T102417Z">
        <seg>理論に関わる論理的な対象についての構文は、 :ref:`term` の節で説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The theories are built from axioms, hypotheses, parameters, lemmas, theorems and definitions of constants, functions, predicates and sets.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T102231Z" creationid="yamarten" creationdate="20181111T100837Z">
        <seg>理論は、公理・仮説・パラメータ・補題・定理と、定数・関数・述語・集合の定義から構築されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third part describes how to extend the syntax of |Coq| in Chapter :ref:`syntaxextensionsandinterpretationscopes` and how to define new induction principles in Chapter :ref:`proofschemes`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145639Z" creationid="yamarten" creationdate="20181104T145639Z">
        <seg>第3部は、 :ref:`syntaxextensionsandinterpretationscopes` の章で|Coq| の構文の拡張方法を、 :ref:`proofschemes` の章で帰納法の原理を新たに定義する方法を説明しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The underlying formal language of |Coq| is a *Calculus of Inductive Constructions* (|Cic|) whose inference rules are presented in this chapter.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181110T110830Z" creationid="yamarten" creationdate="20181110T110830Z">
        <seg>|Coq| の基礎となる形式言語は *Calculus of Inductive Constructions* (|Cic|) と呼ばれる。この章では、 |Cic| の推論規則について説明する。</seg>
      </tuv>
    </tu>
    <tu>
      <note>「compiles to its specification」ってなんだ。</note>
      <tuv lang="EN-US">
        <seg>The very heart of the |Coq| system is the type checking algorithm that checks the correctness of proofs, in other words that checks that a program complies to its specification.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T102409Z" creationid="yamarten" creationdate="20181007T101423Z">
        <seg>|Coq| システムの心臓部は型検査アルゴリズムで、これは証明の正しさを検査します。言い換えれば、このアルゴリズムはプログラムがその仕様に準拠するか検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The |Coq| standard library</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150201Z" creationid="yamarten" creationdate="20181104T150201Z">
        <seg>|Coq| 標準ライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The |Coq| system is designed to develop mathematical proofs, and especially to write formal specifications, programs and to verify that programs are correct with respect to their specifications.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T040420Z" creationid="yamarten" creationdate="20181007T035904Z">
        <seg>|Coq| は、数学的な証明を構築するためにデザインされました。特に、形式仕様やプログラムを記述したり、プログラムが仕様に沿っていることを検証することを目的としています。</seg>
      </tuv>
    </tu>
    <tu>
      <note>distributionのいい感じの訳語が欲しい。</note>
      <tuv lang="EN-US">
        <seg>Then, in Chapter :ref:`utilities`, various utilities that come with the |Coq| distribution are presented.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145806Z" creationid="yamarten" creationdate="20181104T145806Z">
        <seg>次に、 :ref:`utilities` の章で、 |Coq| ディストリビューションに付属する様々なユーティリティについて説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three sorts :g:`Set`, :g:`Prop` and :g:`Type`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T110840Z" creationid="yamarten" creationdate="20200509T110833Z">
        <seg>型には :g:`Set`、:g:`Prop`、:g:`Type` という3つのソートがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <note>オプション(Setするやつ)についての索引は無視？</note>
      <tuv lang="EN-US">
        <seg>There is a global index, and a number of specific indexes for tactics, vernacular commands, and error messages and warnings.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144950Z" creationid="yamarten" creationdate="20181104T144950Z">
        <seg>総合索引に加え、タクティックやコマンド、エラーメッセージ・警告に特化した索引があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a syntactic sugar for let-in definition of functions: :n:`let @ident {+ @binder} := @term in @term’` stands for :n:`let @ident := fun {+ @binder} =&gt; @term in @term’`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T043910Z" creationid="yamarten" creationdate="20200614T043042Z">
        <seg>let-in定義には構文糖衣があります。 :n:`let @ident {+ @binder} := @term in @term’` は :n:`let @ident := fun {+ @binder} =&gt; @term in @term’` の省略形です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a notation for a sequence of binding variables sharing the same type: :n:`({+ @ident} : @type)`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T070558Z" creationid="yamarten" creationdate="20200510T065311Z">
        <seg>複数の束縛変数に同じ型を持たせるための記法もあります: :n:`({+ @ident} : @type)`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are mere notations that can be bound to objects through the notation mechanism (see Chapter :ref:`syntaxextensionsandinterpretationscopes` for details).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T104321Z" creationid="yamarten" creationdate="20200509T104321Z">
        <seg>単に記法メカニズムによってオブジェクトに紐づけられる表記法です。 (詳細は :ref:`syntaxextensionsandinterpretationscopes` の章を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are used in the syntax of qualified identifiers.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20190213T134918Z" creationid="yamarten" creationdate="20190213T134918Z">
        <seg>これは修飾付き識別子に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can contain any character.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T110153Z" creationid="yamarten" creationdate="20181111T110153Z">
        <seg>コメントには任意の文字を含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter describes Gallina, the specification language of Coq.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181111T100518Z" creationid="yamarten" creationdate="20181111T100420Z">
        <seg>この章では、Coqの仕様記述言語であるGallinaについて述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constitutes a semantic subclass of the syntactic class :token:`term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T153405Z" creationid="yamarten" creationdate="20200509T153405Z">
        <seg>これは、構文クラス :token:`term` のサブクラスを構成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is the Reference Manual of the |Coq| proof assistant.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T034931Z" creationid="yamarten" creationdate="20181007T033738Z">
        <seg>この文書は証明アシスタント |Coq| のリファレンスマニュアルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a Reference Manual, so it is not intended for continuous reading.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144930Z" creationid="yamarten" creationdate="20181104T144930Z">
        <seg>この文書はリファレンスマニュアルであり、通読するものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is called a “let-binder”.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T073136Z" creationid="yamarten" creationdate="20200510T073101Z">
        <seg>これを "let束縛子" と呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>documentとdocumentationが区別できてないせいでちょっとよろしくない感じになっている。</note>
      <tuv lang="EN-US">
        <seg>This manual does not contain all the documentation the user may need about |Coq|.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145934Z" creationid="yamarten" creationdate="20181104T145918Z">
        <seg>このマニュアルは |Coq| についてユーザが求める文書が全て含まれているわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <note>http://www.opensource.jp/openpub/ に準拠している。敬体に直した方が自然かもしれない。</note>
      <tuv lang="EN-US">
        <seg>This material (the Coq Reference Manual) may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at http://www.opencontent.org/openpub).</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150301Z" creationid="yamarten" creationdate="20181104T150301Z">
        <seg>この作品 (Coq リファレンスマニュアル) はオープン・パブリケーション利用許諾契約書 (v1.0 かそれ以降) で指定された条件と制約に従う限り配布することができる(契約書の最新の版は現在のところ http://www.opencontent.org/openpub/で入手可能である)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This paragraph describes the basic form of pattern matching.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T052625Z" creationid="yamarten" creationdate="20200614T052625Z">
        <seg>この段落では、パターンマッチの基本的な形式について説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To start using Coq, it is advised to first read a tutorial.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T034900Z" creationid="yamarten" creationdate="20181007T034900Z">
        <seg>Coqを初めて使う方は、まずチュートリアルを読むことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tutorial</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145951Z" creationid="yamarten" creationdate="20181104T145951Z">
        <seg>チュートリアル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type cast</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200614T023502Z" creationid="yamarten" creationdate="20200614T023502Z">
        <seg>型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T100539Z" creationid="yamarten" creationdate="20200509T100539Z">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User extensions</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T150228Z" creationid="yamarten" creationdate="20181104T150228Z">
        <seg>ユーザ拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the so-called *Curry-Howard isomorphism*, programs, properties and proofs are formalized in the same language called *Calculus of Inductive Constructions*, that is a :math:`\lambda`-calculus with a rich type system.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T094032Z" creationid="yamarten" creationdate="20181007T082717Z">
        <seg>*カリー・ハワード同型対応* を使えば、プログラム・性質・証明は全て *Calculus of Inductive Constructions* という一つの言語で表現できます。これは :math:`\lambda` 計算にリッチな型システムが付いたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various constructions such as :g:`fun`, :g:`forall`, :g:`fix` and :g:`cofix` *bind* variables.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T042113Z" creationid="yamarten" creationdate="20200509T155450Z">
        <seg>:g:`fun`、:g:`forall`、:g:`fix`、:g:`cofix` といった様々な構造で変数を *束縛* します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Various informations can be found in the following documents:</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T145944Z" creationid="yamarten" creationdate="20181104T145944Z">
        <seg>以下の文書からも様々な情報を得ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We denote by :production:`type` the semantic subclass of types inside the syntactic class :token:`term`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T101839Z" creationid="yamarten" creationdate="20200509T101839Z">
        <seg>以降、構文クラス :token:`term` に含まれる、型を表すサブクラスを :production:`type` と表記します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We denote propositions by :production:`form`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T153151Z" creationid="yamarten" creationdate="20200509T153151Z">
        <seg>命題は :production:`form` と表記します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We denote specifications by :production:`specif`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200509T153603Z" creationid="yamarten" creationdate="20200509T153603Z">
        <seg>仕様は :production:`specif` と表記します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We recommend using the various indexes to quickly locate the documentation you are looking for.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181104T144937Z" creationid="yamarten" creationdate="20181104T144937Z">
        <seg>目的の文書を素早く見つけるために、色々な索引を使うことをお勧めします。</seg>
      </tuv>
    </tu>
    <tu>
      <note>このsynthesizeの意味が正しく取れない(推論とは違う？)のでとりあえず直訳
binding variableとbound variableは同じ意味で使われてそう</note>
      <tuv lang="EN-US">
        <seg>When the type of a bound variable cannot be synthesized by the system, it can be specified with the notation :n:`(@ident : @type)`.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20200510T065141Z" creationid="yamarten" creationdate="20200510T060035Z">
        <seg>束縛変数の型がシステムで合成できない場合、 :n:`(@ident : @type)` という記法で指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <note>意図がちゃんとわかってない。「型検査器であり、証明アシスタントでもある」「証明アシスタントではタクティックというものを使う」の2点か？そもそもタクティックを言語と呼ぶのに違和感があるので、先を見てから戻ってきたい。</note>
      <tuv lang="EN-US">
        <seg>|Coq| also provides an interactive proof assistant to build proofs using specific programs called *tactics*.</seg>
      </tuv>
      <tuv lang="JA" changeid="yamarten" changedate="20181007T112633Z" creationid="yamarten" creationdate="20181007T101451Z">
        <seg>また、|Coq| は、 *タクティック* と呼ばれるプログラムを用いて証明を構築する、対話的証明アシスタントも提供します。</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
