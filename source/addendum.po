# Japanese translations for Coq package
# Coq パッケージに対する英訳.
# Copyright (C) 1999-2018, Inria
# This file is distributed under the same license as the Coq package.
# Automatically generated, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Coq 8.8.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-29 17:08+0900\n"
"PO-Revision-Date: 2019-12-29 17:08+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../addendum/canonical-structures.rst:4
msgid "Canonical Structures"
msgstr ""

#: ../../addendum/canonical-structures.rst:0
#: ../../addendum/extended-pattern-matching.rst:0
#: ../../addendum/extraction.rst:0 ../../addendum/micromega.rst:0
msgid "Authors"
msgstr ""

#: ../../addendum/canonical-structures.rst:6
msgid "Assia Mahboubi and Enrico Tassi"
msgstr ""

#: ../../addendum/canonical-structures.rst:8
msgid ""
"This chapter explains the basics of canonical structures and how they can be "
"used to overload notations and build a hierarchy of algebraic structures. "
"The examples are taken from :cite:`CSwcu`. We invite the interested reader "
"to refer to this paper for all the details that are omitted here for "
"brevity. The interested reader shall also find in :cite:`CSlessadhoc` a "
"detailed description of another, complementary, use of canonical structures: "
"advanced proof search. This latter papers also presents many techniques one "
"can employ to tune the inference of canonical structures."
msgstr ""

#: ../../addendum/canonical-structures.rst:19
msgid "Notation overloading"
msgstr ""

#: ../../addendum/canonical-structures.rst:21
msgid ""
"We build an infix notation == for a comparison predicate. Such notation will "
"be overloaded, and its meaning will depend on the types of the terms that "
"are compared."
msgstr ""

#: ../../addendum/canonical-structures.rst:40
msgid ""
"We use Coq modules as namespaces. This allows us to follow the same pattern "
"and naming convention for the rest of the chapter. The base namespace "
"contains the definitions of the algebraic structure. To keep the example "
"small, the algebraic structure ``EQ.type`` we are defining is very "
"simplistic, and characterizes terms on which a binary relation is defined, "
"without requiring such relation to validate any property. The inner theory "
"module contains the overloaded notation ``==`` and will eventually contain "
"lemmas holding all the instances of the algebraic structure (in this case "
"there are no lemmas)."
msgstr ""

#: ../../addendum/canonical-structures.rst:50
msgid ""
"Note that in practice the user may want to declare ``EQ.obj`` as a coercion, "
"but we will not do that here."
msgstr ""

#: ../../addendum/canonical-structures.rst:53
msgid ""
"The following line tests that, when we assume a type ``e`` that is in theEQ "
"class, we can relate two of its objects with ``==``."
msgstr ""

#: ../../addendum/canonical-structures.rst:61
msgid "Still, no concrete type is in the ``EQ`` class."
msgstr ""

#: ../../addendum/canonical-structures.rst:67
msgid "We amend that by equipping ``nat`` with a comparison relation."
msgstr ""

#: ../../addendum/canonical-structures.rst:77
msgid ""
"This last test shows that |Coq| is now not only able to type check ``3 == "
"3``, but also that the infix relation was bound to the ``nat_eq`` relation. "
"This relation is selected whenever ``==`` is used on terms of type nat. This "
"can be read in the line declaring the canonical structure ``nat_EQty``, "
"where the first argument to ``Pack`` is the key and its second argument a "
"group of canonical values associated to the key. In this case we associate "
"to nat only one canonical value (since its class, ``nat_EQcl`` has just one "
"member). The use of the projection ``op`` requires its argument to be in the "
"class ``EQ``, and uses such a member (function) to actually compare its "
"arguments."
msgstr ""

#: ../../addendum/canonical-structures.rst:88
msgid ""
"Similarly, we could equip any other type with a comparison relation, and use "
"the ``==`` notation on terms of this type."
msgstr ""

#: ../../addendum/canonical-structures.rst:93
msgid "Derived Canonical Structures"
msgstr ""

#: ../../addendum/canonical-structures.rst:95
msgid ""
"We know how to use ``== `` on base types, like ``nat``, ``bool``, ``Z``. "
"Here we show how to deal with type constructors, i.e. how to make the "
"following example work:"
msgstr ""

#: ../../addendum/canonical-structures.rst:104
msgid ""
"The error message is telling that |Coq| has no idea on how to compare pairs "
"of objects. The following construction is telling Coq exactly how to do that."
msgstr ""

#: ../../addendum/canonical-structures.rst:122
msgid ""
"Thanks to the ``pair_EQty`` declaration, |Coq| is able to build a comparison "
"relation for pairs whenever it is able to build a comparison relation for "
"each component of the pair. The declaration associates to the key ``*`` (the "
"type constructor of pairs) the canonical comparison relation ``pair_eq`` "
"whenever the type constructor ``*`` is applied to two types being themselves "
"in the ``EQ`` class."
msgstr ""

#: ../../addendum/canonical-structures.rst:130
msgid "Hierarchy of structures"
msgstr ""

#: ../../addendum/canonical-structures.rst:132
msgid ""
"To get to an interesting example we need another base class to be available. "
"We choose the class of types that are equipped with an order relation, to "
"which we associate the infix ``<=`` notation."
msgstr ""

#: ../../addendum/canonical-structures.rst:159
msgid "As before we register a canonical ``LE`` class for ``nat``."
msgstr ""

#: ../../addendum/canonical-structures.rst:171
msgid "And we enable |Coq| to relate pair of terms with ``<=``."
msgstr ""

#: ../../addendum/canonical-structures.rst:185
msgid ""
"At the current stage we can use ``==`` and ``<=`` on concrete types, like "
"tuples of natural numbers, but we can’t develop an algebraic theory over the "
"types that are equipped with both relations."
msgstr ""

#: ../../addendum/canonical-structures.rst:197
msgid ""
"We need to define a new class that inherits from both ``EQ`` and ``LE``."
msgstr ""

#: ../../addendum/canonical-structures.rst:218
msgid ""
"The mixin component of the ``LEQ`` class contains all the extra content we "
"are adding to ``EQ`` and ``LE``. In particular it contains the requirement "
"that the two relations we are combining are compatible."
msgstr ""

#: ../../addendum/canonical-structures.rst:222
msgid ""
"Unfortunately there is still an obstacle to developing the algebraic theory "
"of this new class."
msgstr ""

#: ../../addendum/canonical-structures.rst:232
msgid ""
"The problem is that the two classes ``LE`` and ``LEQ`` are not yet related "
"by a subclass relation. In other words |Coq| does not see that an object of "
"the ``LEQ`` class is also an object of the ``LE`` class."
msgstr ""

#: ../../addendum/canonical-structures.rst:236
msgid ""
"The following two constructions tell |Coq| how to canonically build the ``LE."
"type`` and ``EQ.type`` structure given an ``LEQ.type`` structure on the same "
"type."
msgstr ""

#: ../../addendum/canonical-structures.rst:252
msgid ""
"We can now formulate out first theorem on the objects of the ``LEQ`` "
"structure."
msgstr ""

#: ../../addendum/canonical-structures.rst:273
msgid ""
"Of course one would like to apply results proved in the algebraic setting to "
"any concrete instate of the algebraic structure."
msgstr ""

#: ../../addendum/canonical-structures.rst:291
msgid ""
"Again one has to tell |Coq| that the type ``nat`` is in the ``LEQ`` class, "
"and how the type constructor ``*`` interacts with the ``LEQ`` class. In the "
"following proofs are omitted for brevity."
msgstr ""

#: ../../addendum/canonical-structures.rst:310
msgid ""
"The following script registers an ``LEQ`` class for ``nat`` and for the type "
"constructor ``*``. It also tests that they work as expected."
msgstr ""

#: ../../addendum/canonical-structures.rst:313
msgid ""
"Unfortunately, these declarations are very verbose. In the following "
"subsection we show how to make them more compact."
msgstr ""

#: ../../addendum/canonical-structures.rst:342
msgid ""
"Note that no direct proof of ``n <= m -> m <= n -> n == m`` is provided by "
"the user for ``n`` and m of type ``nat * nat``. What the user provides is a "
"proof of this statement for ``n`` and ``m`` of type ``nat`` and a proof that "
"the pair constructor preserves this property. The combination of these two "
"facts is a simple form of proof search that |Coq| performs automatically "
"while inferring canonical structures."
msgstr ""

#: ../../addendum/canonical-structures.rst:350
msgid "Compact declaration of Canonical Structures"
msgstr ""

#: ../../addendum/canonical-structures.rst:352
msgid "We need some infrastructure for that."
msgstr ""

#: ../../addendum/canonical-structures.rst:380
msgid ""
"To explain the notation ``[find v | t1 ~ t2]`` let us pick one of its "
"instances: ``[find e | EQ.obj e ~ T | \"is not an EQ.type\" ]``. It should "
"be read as: “find a class e such that its objects have type T or fail with "
"message \"T is not an EQ.type\"”."
msgstr ""

#: ../../addendum/canonical-structures.rst:385
msgid ""
"The other utilities are used to ask |Coq| to solve a specific unification "
"problem, that will in turn require the inference of some canonical "
"structures. They are explained in more details in :cite:`CSwcu`."
msgstr ""

#: ../../addendum/canonical-structures.rst:389
msgid ""
"We now have all we need to create a compact “packager” to declare instances "
"of the ``LEQ`` class."
msgstr ""

#: ../../addendum/canonical-structures.rst:406
msgid ""
"The object ``Pack`` takes a type ``T`` (the key) and a mixin ``m``. It "
"infers all the other pieces of the class ``LEQ`` and declares them as "
"canonical values associated to the ``T`` key. All in all, the only new piece "
"of information we add in the ``LEQ`` class is the mixin, all the rest is "
"already canonical for ``T`` and hence can be inferred by |Coq|."
msgstr ""

#: ../../addendum/canonical-structures.rst:412
msgid ""
"``Pack`` is a notation, hence it is not type checked at the time of its "
"declaration. It will be type checked when it is used, an in that case ``T`` "
"is going to be a concrete type. The odd arguments ``_`` and ``id`` we pass "
"to the packager represent respectively the classes to be inferred (like "
"``e``, ``o``, etc) and a token (``id``) to force their inference. Again, for "
"all the details the reader can refer to :cite:`CSwcu`."
msgstr ""

#: ../../addendum/canonical-structures.rst:419
msgid "The declaration of canonical instances can now be way more compact:"
msgstr ""

#: ../../addendum/canonical-structures.rst:428
msgid ""
"Error messages are also quite intelligible (if one skips to the end of the "
"message)."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:4
msgid "Extended pattern matching"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:6
msgid "Cristina Cornes and Hugo Herbelin"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:10
msgid ""
"This section describes the full form of pattern matching in |Coq| terms."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:15
msgid "Patterns"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:17
msgid ""
"The full syntax of match is presented in Figures 1.1 and 1.2. Identifiers in "
"patterns are either constructor names or variables. Any identifier that is "
"not the constructor of an inductive or co-inductive type is considered to be "
"a variable. A variable name cannot occur more than once in a given pattern. "
"It is recommended to start variable names by a lowercase letter."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:24
msgid ""
"If a pattern has the form ``(c x)`` where ``c`` is a constructor symbol and "
"x is a linear vector of (distinct) variables, it is called *simple*: it is "
"the kind of pattern recognized by the basic version of match. On the "
"opposite, if it is a variable ``x`` or has the form ``(c p)`` with ``p`` not "
"only made of variables, the pattern is called *nested*."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:30
msgid ""
"A variable pattern matches any value, and the identifier is bound to that "
"value. The pattern “``_``” (called “don't care” or “wildcard” symbol) also "
"matches any value, but does not bind anything. It may occur an arbitrary "
"number of times in a pattern. Alias patterns written :n:`(@pattern as "
"@identifier)` are also accepted. This pattern matches the same values as "
"``pattern`` does and ``identifier`` is bound to the matched value. A pattern "
"of the form :n:`pattern | pattern` is called disjunctive. A list of patterns "
"separated with commas is also considered as a pattern and is called "
"*multiple pattern*. However multiple patterns can only occur at the root of "
"pattern matching equations. Disjunctions of *multiple patterns* are allowed "
"though."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:42
msgid ""
"Since extended ``match`` expressions are compiled into the primitive ones, "
"the expressiveness of the theory remains the same. Once parsing has finished "
"only simple patterns remain. The original nesting of the ``match`` "
"expressions is recovered at printing time. An easy way to see the result of "
"the expansion is to toggle off the nesting performed at printing (use here :"
"flag:`Printing Matching`), then by printing the term with :cmd:`Print` if "
"the term is a constant, or using the command :cmd:`Check`."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:50
msgid ""
"The extended ``match`` still accepts an optional *elimination predicate* "
"given after the keyword ``return``. Given a pattern matching expression, if "
"all the right-hand-sides of ``=>`` have the same type, then this type can be "
"sometimes synthesized, and so we can omit the return part. Otherwise the "
"predicate after return has to be provided, like for the basicmatch."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:57
msgid ""
"Let us illustrate through examples the different aspects of extended pattern "
"matching. Consider for example the function that computes the maximum of two "
"natural numbers. We can write it in primitive syntax by:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:74
msgid "Multiple patterns"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:76
msgid "Using multiple patterns in the definition of ``max`` lets us write:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:87
msgid "which will be compiled into the previous form."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:89
msgid ""
"The pattern matching compilation strategy examines patterns from left to "
"right. A match expression is generated **only** when there is at least one "
"constructor in the column of patterns. E.g. the following example does not "
"build a match expression."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:102
msgid "Aliasing subpatterns"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:104
msgid "We can also use :n:`as @ident` to associate a name to a sub-pattern:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:116
msgid "Nested patterns"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:118
msgid "Here is now an example of nested patterns:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:129
msgid "This is compiled into:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:136
msgid ""
"In the previous examples patterns do not conflict with, but sometimes it is "
"comfortable to write patterns that admit a non trivial superposition. "
"Consider the boolean function :g:`lef` that given two natural numbers "
"yields :g:`true` if the first one is less or equal than the second one and :"
"g:`false` otherwise. We can write it as follows:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:151
msgid ""
"Note that the first and the second multiple pattern overlap because the "
"couple of values ``O O`` matches both. Thus, what is the result of the "
"function on those values? To eliminate ambiguity we use the *textual "
"priority rule:* we consider patterns to be ordered from top to bottom. A "
"value is matched by the pattern at the ith row if and only if it is not "
"matched by some pattern from a previous row. Thus in the example, ``O O`` is "
"matched by the first pattern, and so :g:`(lef O O)` yields true."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:159
msgid "Another way to write this function is:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:170
msgid ""
"Here the last pattern superposes with the first two. Because of the priority "
"rule, the last pattern will be used only for values that do not match "
"neither the first nor the second one."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:174
msgid ""
"Terms with useless patterns are not accepted by the system. Here is an "
"example:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:188
msgid "Disjunctive patterns"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:190
msgid ""
"Multiple patterns that share the same right-hand-side can be factorized "
"using the notation :n:`{+| @mult_pattern}`. For instance, :g:`max` can be "
"rewritten as follows:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:202
msgid ""
"Similarly, factorization of (not necessarily multiple) patterns that share "
"the same variables is possible by using the notation :n:`{+| @pattern}`. "
"Here is an example:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:215
msgid "Here is another example using disjunctive subpatterns."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:226
msgid "About patterns of parametric types"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:229
msgid "Parameters in patterns"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:231
msgid ""
"When matching objects of a parametric type, parameters do not bind in "
"patterns. They must be substituted by “``_``”. Consider for example the type "
"of polymorphic lists:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:241
msgid "We can check the function *tail*:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:252
msgid "When we use parameters in patterns there is an error message:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:265
msgid ""
"This flag (off by default) removes parameters from constructors in patterns:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:278
msgid "Implicit arguments in patterns"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:280
msgid "By default, implicit arguments are omitted in patterns. So we write:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:293
msgid ""
"But the possibility to use all the arguments is given by “``@``” implicit "
"explicitations (as for terms 2.7.11)."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:309
msgid "Matching objects of dependent types"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:311
msgid ""
"The previous examples illustrate pattern matching on objects of non- "
"dependent types, but we can also use the expansion strategy to destructure "
"objects of dependent types. Consider the type :g:`listn` of lists of a "
"certain length:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:324
msgid "Understanding dependencies in patterns"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:326
msgid "We can define the function length over :g:`listn` by:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:332
msgid ""
"Just for illustrating pattern matching, we can define it by case analysis:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:343
msgid ""
"We can understand the meaning of this definition using the same notions of "
"usual pattern matching."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:348
msgid "When the elimination predicate must be provided"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:351
msgid "Dependent pattern matching"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:353
msgid ""
"The examples given so far do not need an explicit elimination predicate "
"because all the |rhs| have the same type and Coq succeeds to synthesize it. "
"Unfortunately when dealing with dependent patterns it often happens that we "
"need to write cases where the types of the |rhs| are different instances of "
"the elimination predicate. The function :g:`concat` for :g:`listn` is an "
"example where the branches have different types and we need to provide the "
"elimination predicate:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:370
msgid ""
"The elimination predicate is :g:`fun (n:nat) (l:listn n) => listn (n+m)`. In "
"general if :g:`m` has type :g:`(I q1 … qr t1 … ts)` where :g:`q1, …, qr` are "
"parameters, the elimination predicate should be of the form :g:`fun y1 … ys "
"x : (I q1 … qr y1 … ys ) => Q`."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:374
msgid ""
"In the concrete syntax, it should be written : ``match m as x in (I _ … _ y1 "
"… ys) return Q with … end``. The variables which appear in the ``in`` and "
"``as`` clause are new and bounded in the property :g:`Q` in the return "
"clause. The parameters of the inductive definitions should not be mentioned "
"and are replaced by ``_``."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:381
msgid "Multiple dependent pattern matching"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:383
msgid ""
"Recall that a list of patterns is also a pattern. So, when we destructure "
"several terms at the same time and the branches have different types we need "
"to provide the elimination predicate for this multiple pattern. It is done "
"using the same scheme: each term may be associated to an ``as`` clause and "
"an ``in`` clause in order to introduce a dependent product."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:390
msgid ""
"For example, an equivalent definition for :g:`concat` (even though the "
"matching on the second term is trivial) would have been:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:402
msgid ""
"Even without real matching over the second term, this construction can be "
"used to keep types linked. If :g:`a` and :g:`b` are two :g:`listn` of the "
"same length, by writing"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:414
msgid "we have a copy of :g:`b` in type :g:`listn 0` resp. :g:`listn (S n')`."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:419
msgid "Patterns in ``in``"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:421
msgid ""
"If the type of the matched term is more precise than an inductive applied to "
"variables, arguments of the inductive in the ``in`` branch can be more "
"complicated patterns than a variable."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:425
msgid ""
"Moreover, constructors whose types do not follow the same pattern will "
"become impossible branches. In an impossible branch, you can answer anything "
"but False_rect unit has the advantage to be subterm of anything."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:430
msgid "To be concrete: the ``tail`` function can be written:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:440
msgid "and :g:`tail n v` will be subterm of :g:`v`."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:443
msgid "Using pattern matching to write proofs"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:445
msgid ""
"In all the previous examples the elimination predicate does not depend on "
"the object(s) matched. But it may depend and the typical case is when we "
"write a proof by induction or a function that yields an object of a "
"dependent type. An example of a proof written using ``match`` is given in "
"the description of the tactic :tacn:`refine`."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:451
msgid ""
"For example, we can write the function :g:`buildlist` that given a natural "
"number :g:`n` builds a list of length :g:`n` containing zeros as follows:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:462
msgid ""
"We can also use multiple patterns. Consider the following definition of the "
"predicate less-equal :g:`Le`:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:471
msgid ""
"We can use multiple patterns to write the proof of the lemma :g:`forall (n m:"
"nat), (LE n m) \\/ (LE m n)`:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:487
msgid ""
"In the example of :g:`dec`, the first match is dependent while the second is "
"not."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:490
msgid ""
"The user can also use match in combination with the tactic :tacn:`refine` "
"(see Section 8.2.3) to build incomplete proofs beginning with a match "
"construction."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:496
msgid "Pattern-matching on inductive objects involving local definitions"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:498
msgid ""
"If local definitions occur in the type of a constructor, then there are two "
"ways to match on this constructor. Either the local definitions are skipped "
"and matching is done only on the true arguments of the constructors, or the "
"bindings for local definitions can also be caught in the matching."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:504
#: ../../addendum/extended-pattern-matching.rst:550
#: ../../addendum/generalized-rewriting.rst:232
#: ../../addendum/generalized-rewriting.rst:329
#: ../../addendum/generalized-rewriting.rst:347
#: ../../addendum/generalized-rewriting.rst:394
#: ../../addendum/generalized-rewriting.rst:414
#: ../../addendum/miscellaneous-extensions.rst:32 ../../addendum/omega.rst:97
#: ../../addendum/ring.rst:43 ../../addendum/ring.rst:125
#: ../../addendum/ring.rst:526
msgid "Example"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:512
msgid "In the next example, the local definition is not caught."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:522
msgid "But in this example, it is."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:532
msgid ""
"For a given matching clause, either none of the local definitions or all of "
"them can be caught."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:535
msgid ""
"You can only catch let bindings in mode where you bind all variables and so "
"you have to use ``@`` syntax."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:538
msgid ""
"this feature is incoherent with the fact that parameters cannot be caught "
"and consequently is somehow hidden. For example, there is no mention of it "
"in error messages."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:543
msgid "Pattern-matching and coercions"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:545
msgid ""
"If a mismatch occurs between the expected type of a pattern and its actual "
"type, a coercion made from constructors is sought. If such a coercion can be "
"found, it is automatically inserted around the pattern."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:569
msgid "When does the expansion strategy fail?"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:571
msgid ""
"The strategy works very like in ML languages when treating patterns of non-"
"dependent types. But there are new cases of failure that are due to the "
"presence of dependencies."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:575
msgid ""
"The error messages of the current implementation may be sometimes confusing. "
"When the tactic fails because patterns are somehow incorrect then error "
"messages refer to the initial expression. But the strategy may succeed to "
"build an expression whose sub-expressions are well typed when the whole "
"expression is not. In this situation the message makes reference to the "
"expanded expression. We encourage users, when they have patterns with the "
"same outer constructor in different equations, to name the variable patterns "
"in the same positions with the same name. E.g. to write ``(cons n O x) => "
"e1`` and ``(cons n _ x) => e2`` instead of ``(cons n O x) => e1`` and "
"``(cons n' _ x') => e2``. This helps to maintain certain name correspondence "
"between the generated expression and the original."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:588
msgid ""
"Here is a summary of the error messages corresponding to each situation:"
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:593
msgid ""
"The variable ident is bound several times in pattern termFound a constructor "
"of inductive type term while a constructor of term is expectedPatterns are "
"incorrect (because constructors are not applied to the correct number of the "
"arguments, because they are not linear or they are wrongly typed)."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:600
msgid "The pattern matching is not exhaustive."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:605
msgid "The elimination predicate provided to match has not the expected arity."
msgstr ""

#: ../../addendum/extended-pattern-matching.rst:610
msgid ""
"There is a type mismatch between the different branches. The user should "
"provide an elimination predicate."
msgstr ""

#: ../../addendum/extraction.rst:4
msgid "Extraction of programs in |OCaml| and Haskell"
msgstr ""

#: ../../addendum/extraction.rst:6
msgid "Jean-Christophe Filliâtre and Pierre Letouzey"
msgstr ""

#: ../../addendum/extraction.rst:8
msgid ""
"We present here the |Coq| extraction commands, used to build certified and "
"relatively efficient functional programs, extracting them from either |Coq| "
"functions or |Coq| proofs of specifications. The functional languages "
"available as output are currently |OCaml|, Haskell and Scheme. In the "
"following, \"ML\" will be used (abusively) to refer to any of the three."
msgstr ""

#: ../../addendum/extraction.rst:15
msgid ""
"Before using any of the commands or options described in this chapter, the "
"extraction framework should first be loaded explicitly via ``Require "
"Extraction``, or via the more robust ``From Coq Require Extraction``. Note "
"that in earlier versions of Coq, these commands and options were directly "
"available without any preliminary ``Require``."
msgstr ""

#: ../../addendum/extraction.rst:27
msgid "Generating ML Code"
msgstr ""

#: ../../addendum/extraction.rst:31
msgid ""
"In the following, a qualified identifier `qualid` can be used to refer to "
"any kind of |Coq| global \"object\" : constant, inductive type, inductive "
"constructor or module name."
msgstr ""

#: ../../addendum/extraction.rst:35
msgid ""
"The next two commands are meant to be used for rapid preview of extraction. "
"They both display extracted term(s) inside |Coq|."
msgstr ""

#: ../../addendum/extraction.rst:40
msgid "Extraction of the mentioned object in the |Coq| toplevel."
msgstr ""

#: ../../addendum/extraction.rst:44
msgid ""
"Recursive extraction of all the mentioned objects and all their dependencies "
"in the |Coq| toplevel."
msgstr ""

#: ../../addendum/extraction.rst:47
msgid ""
"All the following commands produce real ML files. User can choose to produce "
"one monolithic file or one file per |Coq| library."
msgstr ""

#: ../../addendum/extraction.rst:52
msgid ""
"Recursive extraction of all the mentioned objects and all their dependencies "
"in one monolithic `file`. Global and local identifiers are renamed according "
"to the chosen ML language to fulfill its syntactic conventions, keeping "
"original names as much as possible."
msgstr ""

#: ../../addendum/extraction.rst:60
msgid ""
"Extraction of the whole |Coq| library ``ident.v`` to an ML module ``ident."
"ml``. In case of name clash, identifiers are here renamed using prefixes "
"``coq_``  or ``Coq_`` to ensure a session-independent renaming."
msgstr ""

#: ../../addendum/extraction.rst:67
msgid ""
"Extraction of the |Coq| library ``ident.v`` and all other modules ``ident."
"v`` depends on."
msgstr ""

#: ../../addendum/extraction.rst:72
msgid ""
"Recursive extraction of all the mentioned objects and all their "
"dependencies, just as ``Extraction \"file\"``, but instead of producing one "
"monolithic file, this command splits the produced code in separate ML files, "
"one per corresponding Coq ``.v`` file. This command is hence quite similar "
"to :cmd:`Recursive Extraction Library`, except that only the needed parts of "
"Coq libraries are extracted instead of the whole. The naming convention in "
"case of name clash is the same one as :cmd:`Extraction Library`: identifiers "
"are here renamed using prefixes ``coq_``  or ``Coq_``."
msgstr ""

#: ../../addendum/extraction.rst:83
msgid ""
"The following command is meant to help automatic testing of the extraction, "
"see for instance the ``test-suite`` directory in the |Coq| sources."
msgstr ""

#: ../../addendum/extraction.rst:89
msgid ""
"All the mentioned objects and all their dependencies are extracted to a "
"temporary |OCaml| file, just as in ``Extraction \"file\"``. Then this "
"temporary file and its signature are compiled with the same |OCaml| compiler "
"used to built |Coq|. This command succeeds only if the extraction and the |"
"OCaml| compilation succeed. It fails if the current target language of the "
"extraction is not |OCaml|."
msgstr ""

#: ../../addendum/extraction.rst:97
msgid "Extraction Options"
msgstr ""

#: ../../addendum/extraction.rst:100
msgid "Setting the target language"
msgstr ""

#: ../../addendum/extraction.rst:102
msgid ""
"The ability to fix target language is the first and more important of the "
"extraction options. Default is ``OCaml``."
msgstr ""

#: ../../addendum/extraction.rst:110
msgid "Inlining and optimizations"
msgstr ""

#: ../../addendum/extraction.rst:112
msgid ""
"Since |OCaml| is a strict language, the extracted code has to be optimized "
"in order to be efficient (for instance, when using induction principles we "
"do not want to compute all the recursive calls but only the needed ones). So "
"the extraction mechanism provides an automatic optimization routine that "
"will be called each time the user wants to generate an |OCaml| program. The "
"optimizations can be split in two groups: the type-preserving ones "
"(essentially constant inlining and reductions) and the non type-preserving "
"ones (some function abstractions of dummy types are removed when it is "
"deemed safe in order to have more elegant types). Therefore some constants "
"may not appear in the resulting monolithic |OCaml| program. In the case of "
"modular extraction, even if some inlining is done, the inlined constants are "
"nevertheless printed, to ensure session-independent programs."
msgstr ""

#: ../../addendum/extraction.rst:126
msgid ""
"Concerning Haskell, type-preserving optimizations are less useful because of "
"laziness. We still make some optimizations, for example in order to produce "
"more readable code."
msgstr ""

#: ../../addendum/extraction.rst:130
msgid ""
"The type-preserving optimizations are controlled by the following |Coq| "
"options:"
msgstr ""

#: ../../addendum/extraction.rst:134
msgid ""
"Default is on. This controls all type-preserving optimizations made on the "
"ML terms (mostly reduction of dummy beta/iota redexes, but also "
"simplifications on Cases, etc). Turn this option off if you want a ML term "
"as close as possible to the Coq term."
msgstr ""

#: ../../addendum/extraction.rst:141
msgid ""
"Default is off. This controls the non type-preserving optimizations made on "
"ML terms (which try to avoid function abstraction of dummy types). Turn this "
"option on to make sure that ``e:t`` implies that ``e':t'`` where ``e'`` and "
"``t'`` are the extracted code of ``e`` and ``t`` respectively."
msgstr ""

#: ../../addendum/extraction.rst:149
msgid ""
"Default is off. Normally, when the extraction of an inductive type produces "
"a singleton type (i.e. a type with only one constructor, and only one "
"argument to this constructor), the inductive structure is removed and this "
"type is seen as an alias to the inner type. The typical example is ``sig``. "
"This option allows disabling this optimization when one wishes to preserve "
"the inductive structure of types."
msgstr ""

#: ../../addendum/extraction.rst:158
msgid ""
"Default is on. The extraction mechanism inlines the bodies of some defined "
"constants, according to some heuristics like size of bodies, uselessness of "
"some arguments, etc. Those heuristics are not always perfect; if you want to "
"disable this feature, turn this option off."
msgstr ""

#: ../../addendum/extraction.rst:166
msgid ""
"In addition to the automatic inline feature, the constants mentionned by "
"this command will always be inlined during extraction."
msgstr ""

#: ../../addendum/extraction.rst:171
msgid ""
"Conversely, the constants mentionned by this command will never be inlined "
"during extraction."
msgstr ""

#: ../../addendum/extraction.rst:176
msgid ""
"Prints the current state of the table recording the custom inlinings "
"declared by the two previous commands."
msgstr ""

#: ../../addendum/extraction.rst:181
msgid ""
"Empties the table recording the custom inlinings (see the previous commands)."
msgstr ""

#: ../../addendum/extraction.rst:184
msgid "**Inlining and printing of a constant declaration:**"
msgstr ""

#: ../../addendum/extraction.rst:186
msgid ""
"The user can explicitly ask for a constant to be extracted by two means:"
msgstr ""

#: ../../addendum/extraction.rst:188
msgid "by mentioning it on the extraction command line"
msgstr ""

#: ../../addendum/extraction.rst:190
msgid "by extracting the whole |Coq| module of this constant."
msgstr ""

#: ../../addendum/extraction.rst:192
msgid ""
"In both cases, the declaration of this constant will be present in the "
"produced file. But this same constant may or may not be inlined in the "
"following terms, depending on the automatic/custom inlining mechanism."
msgstr ""

#: ../../addendum/extraction.rst:196
msgid ""
"For the constants non-explicitly required but needed for dependency reasons, "
"there are two cases:"
msgstr ""

#: ../../addendum/extraction.rst:199
msgid ""
"If an inlining decision is taken, whether automatically or not, all "
"occurrences of this constant are replaced by its extracted body, and this "
"constant is not declared in the generated file."
msgstr ""

#: ../../addendum/extraction.rst:203
msgid ""
"If no inlining decision is taken, the constant is normally declared in the "
"produced file."
msgstr ""

#: ../../addendum/extraction.rst:207
msgid "Extra elimination of useless arguments"
msgstr ""

#: ../../addendum/extraction.rst:209
msgid ""
"The following command provides some extra manual control on the code "
"elimination performed during extraction, in a way which is independent but "
"complementary to the main elimination principles of extraction (logical "
"parts and types)."
msgstr ""

#: ../../addendum/extraction.rst:216
msgid ""
"This experimental command allows declaring some arguments of `qualid` as "
"implicit, i.e. useless in extracted code and hence to be removed by "
"extraction. Here `qualid` can be any function or inductive constructor, and "
"the given `ident` are the names of the concerned arguments. In fact, an "
"argument can also be referred by a number indicating its position, starting "
"from 1."
msgstr ""

#: ../../addendum/extraction.rst:223
msgid ""
"When an actual extraction takes place, an error is normally raised if the :"
"cmd:`Extraction Implicit` declarations cannot be honored, that is if any of "
"the implicit arguments still occurs in the final code. This behavior can be "
"relaxed via the following option:"
msgstr ""

#: ../../addendum/extraction.rst:230
msgid ""
"Default is on. When this option is off, a warning is emitted instead of an "
"error if some implicit arguments still occur in the final code of an "
"extraction. This way, the extracted code may be obtained nonetheless and "
"reviewed manually to locate the source of the issue (in the code, some "
"comments mark the location of these remaining implicit arguments). Note that "
"this extracted code might not compile or run properly, depending of the use "
"of these remaining implicit arguments."
msgstr ""

#: ../../addendum/extraction.rst:239
msgid "Realizing axioms"
msgstr ""

#: ../../addendum/extraction.rst:241
msgid ""
"Extraction will fail if it encounters an informative axiom not realized. A "
"warning will be issued if it encounters a logical axiom, to remind the user "
"that inconsistent logical axioms may lead to incorrect or non-terminating "
"extracted terms."
msgstr ""

#: ../../addendum/extraction.rst:246
msgid ""
"It is possible to assume some axioms while developing a proof. Since these "
"axioms can be any kind of proposition or object or type, they may perfectly "
"well have some computational content. But a program must be a closed term, "
"and of course the system cannot guess the program which realizes an axiom.  "
"Therefore, it is possible to tell the system what ML term corresponds to a "
"given axiom."
msgstr ""

#: ../../addendum/extraction.rst:255
msgid ""
"Give an ML extraction for the given constant. The `string` may be an "
"identifier or a quoted string."
msgstr ""

#: ../../addendum/extraction.rst:260
msgid ""
"Same as the previous one, except that the given ML terms will be inlined "
"everywhere instead of being declared via a ``let``."
msgstr ""

#: ../../addendum/extraction.rst:264
msgid ""
"This command is sugar for an :cmd:`Extract Constant` followed by a :cmd:"
"`Extraction Inline`. Hence a :cmd:`Reset Extraction Inline` will have an "
"effect on the realized and inlined axiom."
msgstr ""

#: ../../addendum/extraction.rst:268
msgid ""
"It is the responsibility of the user to ensure that the ML terms given to "
"realize the axioms do have the expected types. In fact, the strings "
"containing realizing code are just copied to the extracted files. The "
"extraction recognizes whether the realized axiom should become a ML type "
"constant or a ML object declaration. For example:"
msgstr ""

#: ../../addendum/extraction.rst:281
msgid ""
"Notice that in the case of type scheme axiom (i.e. whose type is an arity, "
"that is a sequence of product finished by a sort), then some type variables "
"have to be given (as quoted strings). The syntax is then:"
msgstr ""

#: ../../addendum/extraction.rst:287
msgid "The number of type variables is checked by the system. For example:"
msgstr ""

#: ../../addendum/extraction.rst:294
msgid ""
"Realizing an axiom via :cmd:`Extract Constant` is only useful in the case of "
"an informative axiom (of sort ``Type`` or ``Set``). A logical axiom has no "
"computational content and hence will not appear in extracted terms. But a "
"warning is nonetheless issued if extraction encounters a logical axiom. This "
"warning reminds user that inconsistent logical axioms may lead to incorrect "
"or non-terminating extracted terms."
msgstr ""

#: ../../addendum/extraction.rst:301
msgid ""
"If an informative axiom has not been realized before an extraction, a "
"warning is also issued and the definition of the axiom is filled with an "
"exception labeled ``AXIOM TO BE REALIZED``. The user must then search these "
"exceptions inside the extracted file and replace them by real code."
msgstr ""

#: ../../addendum/extraction.rst:308
msgid "Realizing inductive types"
msgstr ""

#: ../../addendum/extraction.rst:310
msgid ""
"The system also provides a mechanism to specify ML terms for inductive types "
"and constructors. For instance, the user may want to use the ML native "
"boolean type instead of the |Coq| one. The syntax is the following:"
msgstr ""

#: ../../addendum/extraction.rst:316
msgid ""
"Give an ML extraction for the given inductive type. You must specify "
"extractions for the type itself (first `string`) and all its constructors "
"(all the `string` between square brackets). In this form, the ML extraction "
"must be an ML inductive datatype, and the native pattern matching of the "
"language will be used."
msgstr ""

#: ../../addendum/extraction.rst:324
msgid ""
"Same as before, with a final extra `string` that indicates how to perform "
"pattern matching over this inductive type. In this form, the ML extraction "
"could be an arbitrary type. For an inductive type with `k` constructors, the "
"function used to emulate the pattern matching should expect `(k+1)` "
"arguments, first the `k` branches in functional form, and then the inductive "
"element to destruct. For instance, the match branch ``| S n => foo`` gives "
"the functional form ``(fun n -> foo)``. Note that a constructor with no "
"arguments is considered to have one unit argument, in order to block early "
"evaluation of the branch: ``| O => bar`` leads to the functional form ``(fun "
"() -> bar)``. For instance, when extracting ``nat`` into |OCaml| ``int``, "
"the code to be provided has type: ``(unit->'a)->(int->'a)->int->'a``."
msgstr ""

#: ../../addendum/extraction.rst:338
msgid "As for :cmd:`Extract Constant`, this command should be used with care:"
msgstr ""

#: ../../addendum/extraction.rst:340
msgid ""
"The ML code provided by the user is currently **not** checked at all by "
"extraction, even for syntax errors."
msgstr ""

#: ../../addendum/extraction.rst:343
msgid ""
"Extracting an inductive type to a pre-existing ML inductive type is quite "
"sound. But extracting to a general type (by providing an ad-hoc pattern "
"matching) will often **not** be fully rigorously correct. For instance, when "
"extracting ``nat`` to |OCaml| ``int``, it is theoretically possible to build "
"``nat`` values that are larger than |OCaml| ``max_int``. It is the user's "
"responsibility to be sure that no overflow or other bad events occur in "
"practice."
msgstr ""

#: ../../addendum/extraction.rst:351
msgid ""
"Translating an inductive type to an arbitrary ML type does **not** magically "
"improve the asymptotic complexity of functions, even if the ML type is an "
"efficient representation. For instance, when extracting ``nat`` to |OCaml| "
"``int``, the function ``Nat.mul`` stays quadratic. It might be interesting "
"to associate this translation with some specific :cmd:`Extract Constant` "
"when primitive counterparts exist."
msgstr ""

#: ../../addendum/extraction.rst:358
msgid "Typical examples are the following:"
msgstr ""

#: ../../addendum/extraction.rst:368
msgid ""
"When extracting to |OCaml|, if an inductive constructor or type has arity 2 "
"and the corresponding string is enclosed by parentheses, and the string "
"meets |OCaml|'s lexical criteria for an infix symbol, then the rest of the "
"string is used as an infix constructor or type."
msgstr ""

#: ../../addendum/extraction.rst:378
msgid ""
"As an example of translation to a non-inductive datatype, let's turn ``nat`` "
"into |OCaml| ``int`` (see caveat above):"
msgstr ""

#: ../../addendum/extraction.rst:386
msgid "Avoiding conflicts with existing filenames"
msgstr ""

#: ../../addendum/extraction.rst:388
msgid ""
"When using :cmd:`Extraction Library`, the names of the extracted files "
"directly depend on the names of the |Coq| files. It may happen that these "
"filenames are in conflict with already existing files, either in the "
"standard library of the target language or in other code that is meant to be "
"linked with the extracted code. For instance the module ``List`` exists both "
"in |Coq| and in |OCaml|. It is possible to instruct the extraction not to "
"use particular filenames."
msgstr ""

#: ../../addendum/extraction.rst:398
msgid ""
"Instruct the extraction to avoid using these names as filenames for "
"extracted code."
msgstr ""

#: ../../addendum/extraction.rst:403
msgid "Show the current list of filenames the extraction should avoid."
msgstr ""

#: ../../addendum/extraction.rst:407
msgid "Allow the extraction to use any filename."
msgstr ""

#: ../../addendum/extraction.rst:409
msgid ""
"For |OCaml|, a typical use of these commands is ``Extraction Blacklist "
"String List``."
msgstr ""

#: ../../addendum/extraction.rst:413
msgid "Differences between |Coq| and ML type systems"
msgstr ""

#: ../../addendum/extraction.rst:415
msgid ""
"Due to differences between |Coq| and ML type systems, some extracted "
"programs are not directly typable in ML. We now solve this problem (at least "
"in |OCaml|) by adding when needed some unsafe casting ``Obj.magic``, which "
"give a generic type ``'a`` to any term."
msgstr ""

#: ../../addendum/extraction.rst:421
msgid ""
"First, if some part of the program is *very* polymorphic, there may be no ML "
"type for it. In that case the extraction to ML works alright but the "
"generated code may be refused by the ML type checker. A very well known "
"example is the ``distr-pair`` function:"
msgstr ""

#: ../../addendum/extraction.rst:431
msgid "In |OCaml|, for instance, the direct extracted term would be::"
msgstr ""

#: ../../addendum/extraction.rst:435
msgid "and would have type::"
msgstr ""

#: ../../addendum/extraction.rst:439
msgid "which is not its original type, but a restriction."
msgstr ""

#: ../../addendum/extraction.rst:441
msgid "We now produce the following correct version::"
msgstr ""

#: ../../addendum/extraction.rst:445
msgid ""
"Secondly, some |Coq| definitions may have no counterpart in ML. This happens "
"when there is a quantification over types inside the type of a constructor; "
"for example:"
msgstr ""

#: ../../addendum/extraction.rst:453
msgid ""
"which corresponds to the definition of an ML dynamic type. In |OCaml|, we "
"must cast any argument of the constructor dummy (no GADT are produced yet by "
"the extraction)."
msgstr ""

#: ../../addendum/extraction.rst:457
msgid ""
"Even with those unsafe castings, you should never get error like "
"``segmentation fault``. In fact even if your program may seem ill-typed to "
"the |OCaml| type checker, it can't go wrong : it comes from a Coq well-typed "
"terms, so for example inductive types will always have the correct number of "
"arguments, etc. Of course, when launching manually some extracted function, "
"you should apply it to arguments of the right shape (from the |Coq| point-of-"
"view)."
msgstr ""

#: ../../addendum/extraction.rst:465
msgid ""
"More details about the correctness of the extracted programs can be found "
"in :cite:`Let02`."
msgstr ""

#: ../../addendum/extraction.rst:468
msgid ""
"We have to say, though, that in most \"realistic\" programs, these problems "
"do not occur. For example all the programs of Coq library are accepted by "
"the |OCaml| type checker without any ``Obj.magic`` (see examples below)."
msgstr ""

#: ../../addendum/extraction.rst:473
msgid "Some examples"
msgstr ""

#: ../../addendum/extraction.rst:475
msgid ""
"We present here two examples of extraction, taken from the |Coq| Standard "
"Library. We choose |OCaml| as the target language, but everything, with "
"slight modifications, can also be done in the other languages supported by "
"extraction. We then indicate where to find other examples and tests of "
"extraction."
msgstr ""

#: ../../addendum/extraction.rst:482
msgid "A detailed example: Euclidean division"
msgstr ""

#: ../../addendum/extraction.rst:484
msgid ""
"The file ``Euclid`` contains the proof of Euclidean division. The natural "
"numbers used here are unary, represented by the type``nat``, which is "
"defined by two constructors ``O`` and ``S``. This module contains a theorem "
"``eucl_dev``, whose type is::"
msgstr ""

#: ../../addendum/extraction.rst:491
msgid ""
"where ``diveucl`` is a type for the pair of the quotient and the modulo, "
"plus some logical assertions that disappear during extraction. We can now "
"extract this program to |OCaml|:"
msgstr ""

#: ../../addendum/extraction.rst:506
msgid ""
"The inlining of ``gt_wf_rec`` and others is not mandatory. It only enhances "
"readability of extracted code. You can then copy-paste the output to a file "
"``euclid.ml`` or let |Coq| do it for you with the following command::"
msgstr ""

#: ../../addendum/extraction.rst:513
msgid "Let us play the resulting program (in an |OCaml| toplevel)::"
msgstr ""

#: ../../addendum/extraction.rst:527
msgid "It is easier to test on |OCaml| integers::"
msgstr ""

#: ../../addendum/extraction.rst:543
msgid ""
"Note that these ``nat_of_int`` and ``int_of_nat`` are now available via a "
"mere ``Require Import ExtrOcamlIntConv`` and then adding these functions to "
"the list of functions to extract. This file ``ExtrOcamlIntConv.v`` and some "
"others in ``plugins/extraction/`` are meant to help building concrete "
"program via extraction."
msgstr ""

#: ../../addendum/extraction.rst:550
msgid "Extraction's horror museum"
msgstr ""

#: ../../addendum/extraction.rst:552
msgid ""
"Some pathological examples of extraction are grouped in the file ``test-"
"suite/success/extraction.v`` of the sources of |Coq|."
msgstr ""

#: ../../addendum/extraction.rst:556
msgid "Users' Contributions"
msgstr ""

#: ../../addendum/extraction.rst:558
msgid ""
"Several of the |Coq| Users' Contributions use extraction to produce "
"certified programs. In particular the following ones have an automatic "
"extraction test:"
msgstr ""

#: ../../addendum/extraction.rst:562
msgid "``additions`` : https://github.com/coq-contribs/additions"
msgstr ""

#: ../../addendum/extraction.rst:563
msgid "``bdds`` : https://github.com/coq-contribs/bdds"
msgstr ""

#: ../../addendum/extraction.rst:564
msgid "``canon-bdds`` : https://github.com/coq-contribs/canon-bdds"
msgstr ""

#: ../../addendum/extraction.rst:565
msgid "``chinese`` : https://github.com/coq-contribs/chinese"
msgstr ""

#: ../../addendum/extraction.rst:566
msgid "``continuations`` : https://github.com/coq-contribs/continuations"
msgstr ""

#: ../../addendum/extraction.rst:567
msgid "``coq-in-coq`` : https://github.com/coq-contribs/coq-in-coq"
msgstr ""

#: ../../addendum/extraction.rst:568
msgid "``exceptions`` : https://github.com/coq-contribs/exceptions"
msgstr ""

#: ../../addendum/extraction.rst:569
msgid "``firing-squad`` : https://github.com/coq-contribs/firing-squad"
msgstr ""

#: ../../addendum/extraction.rst:570
msgid "``founify`` : https://github.com/coq-contribs/founify"
msgstr ""

#: ../../addendum/extraction.rst:571
msgid "``graphs`` : https://github.com/coq-contribs/graphs"
msgstr ""

#: ../../addendum/extraction.rst:572
msgid "``higman-cf`` : https://github.com/coq-contribs/higman-cf"
msgstr ""

#: ../../addendum/extraction.rst:573
msgid "``higman-nw`` : https://github.com/coq-contribs/higman-nw"
msgstr ""

#: ../../addendum/extraction.rst:574
msgid "``hardware`` : https://github.com/coq-contribs/hardware"
msgstr ""

#: ../../addendum/extraction.rst:575
msgid "``multiplier`` : https://github.com/coq-contribs/multiplier"
msgstr ""

#: ../../addendum/extraction.rst:576
msgid "``search-trees`` : https://github.com/coq-contribs/search-trees"
msgstr ""

#: ../../addendum/extraction.rst:577
msgid "``stalmarck`` : https://github.com/coq-contribs/stalmarck"
msgstr ""

#: ../../addendum/extraction.rst:579
msgid ""
"Note that ``continuations`` and ``multiplier`` are a bit particular. They "
"are examples of developments where ``Obj.magic`` is needed. This is probably "
"due to a heavy use of impredicativity. After compilation, those two examples "
"run nonetheless, thanks to the correction of the extraction :cite:`Let02`."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:4
msgid "Generalized rewriting"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:0
#: ../../addendum/implicit-coercions.rst:0 ../../addendum/nsatz.rst:0
#: ../../addendum/omega.rst:0 ../../addendum/parallel-proof-processing.rst:0
#: ../../addendum/program.rst:0 ../../addendum/ring.rst:0
#: ../../addendum/universe-polymorphism.rst:0
msgid "Author"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:6 ../../addendum/program.rst:8
#: ../../addendum/universe-polymorphism.rst:6
msgid "Matthieu Sozeau"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:8
msgid ""
"This chapter presents the extension of several equality related tactics to "
"work over user-defined structures (called setoids) that are equipped with ad-"
"hoc equivalence relations meant to behave as equalities. Actually, the "
"tactics have also been generalized to relations weaker then equivalences (e."
"g. rewriting systems). The toolbox also extends the automatic rewriting "
"capabilities of the system, allowing the specification of custom strategies "
"for rewriting."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:16
msgid ""
"This documentation is adapted from the previous setoid documentation by "
"Claudio Sacerdoti Coen (based on previous work by Clément Renard). The new "
"implementation is a drop-in replacement for the old one [#tabareau]_, hence "
"most of the documentation still applies."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:21
msgid ""
"The work is a complete rewrite of the previous implementation, based on the "
"typeclass infrastructure. It also improves on and generalizes the previous "
"implementation in several ways:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:25
msgid ""
"User-extensible algorithm. The algorithm is separated into two parts: "
"generation of the rewriting constraints (written in ML) and solving these "
"constraints using typeclass resolution. As typeclass resolution is "
"extensible using tactics, this allows users to define general ways to solve "
"morphism constraints."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:30
msgid ""
"Subrelations. An example extension to the base algorithm is the ability to "
"define one relation as a subrelation of another so that morphism "
"declarations on one relation can be used automatically for the other. This "
"is done purely using tactics and typeclass search."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:34
msgid ""
"Rewriting under binders. It is possible to rewrite under binders in the new "
"implementation, if one provides the proper morphisms. Again, most of the "
"work is handled in the tactics."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:37
msgid ""
"First-class morphisms and signatures. Signatures and morphisms are ordinary "
"Coq terms, hence they can be manipulated inside Coq, put inside structures "
"and lemmas about them can be proved inside the system. Higher-order "
"morphisms are also allowed."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:41
msgid ""
"Performance. The implementation is based on a depth-first search for the "
"first solution to a set of constraints which can be as fast as linear in the "
"size of the term, and the size of the proof term is linear in the size of "
"the original term. Besides, the extensibility allows the user to customize "
"the proof search if necessary."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:47
msgid "Nicolas Tabareau helped with the gluing."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:50
msgid "Introduction to generalized rewriting"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:54
msgid "Relations and morphisms"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:56
msgid ""
"A parametric *relation* ``R`` is any term of type ``forall (x1 : T1) ... "
"(xn : Tn), relation A``. The expression ``A``, which depends on ``x1 ... "
"xn`` , is called the *carrier* of the relation and ``R`` is said to be a "
"relation over ``A``; the list ``x1,...,xn`` is the (possibly empty) list of "
"parameters of the relation."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:62
#: ../../addendum/generalized-rewriting.rst:204
msgid "Example: Parametric relation"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:64
msgid ""
"It is possible to implement finite sets of elements of type ``A`` as "
"unordered lists of elements of type ``A``. The function ``set_eq: forall "
"(A : Type), relation (list A)`` satisfied by two lists with the same "
"elements is a parametric relation over ``(list A)`` with one parameter "
"``A``. The type of ``set_eq`` is convertible with ``forall (A : Type), list "
"A -> list A -> Prop.``"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:71
msgid ""
"An *instance* of a parametric relation ``R`` with n parameters is any term "
"``(R t1 ... tn)``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:74
msgid ""
"Let ``R`` be a relation over ``A`` with ``n`` parameters. A term is a "
"parametric proof of reflexivity for ``R`` if it has type ``forall (x1 : "
"T1) ... (xn : Tn), reflexive (R x1 ... xn)``. Similar definitions are given "
"for parametric proofs of symmetry and transitivity."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:79
msgid "Example: Parametric relation (continued)"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:81
msgid ""
"The ``set_eq`` relation of the previous example can be proved to be "
"reflexive, symmetric and transitive. A parametric unary function ``f`` of "
"type ``forall (x1 : T1) ... (xn : Tn), A1 -> A2`` covariantly respects two "
"parametric relation instances ``R1`` and ``R2`` if, whenever ``x``, ``y`` "
"satisfy ``R1 x y``, their images (``f x``) and (``f y``) satisfy ``R2 (f x) "
"(f y)``. An ``f`` that respects its input and output relations will be "
"called a unary covariant *morphism*. We can also say that ``f`` is a "
"monotone function with respect to ``R1`` and ``R2`` . The sequence ``x1 ... "
"xn`` represents the parameters of the morphism."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:90
msgid ""
"Let ``R1`` and ``R2`` be two parametric relations. The *signature* of a "
"parametric morphism of type ``forall (x1 : T1) ... (xn : Tn), A1 -> A2`` "
"that covariantly respects two instances :math:`I_{R_1}` and :math:`I_{R_2}` "
"of ``R1`` and ``R2`` is written :math:`I_{R_1} ++> I_{R_2}`. Notice that the "
"special arrow ++>, which reminds the reader of covariance, is placed between "
"the two relation instances, not between the two carriers. The signature "
"relation instances and morphism will be typed in a context introducing "
"variables for the parameters."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:99
msgid ""
"The previous definitions are extended straightforwardly to n-ary morphisms, "
"that are required to be simultaneously monotone on every argument."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:103
msgid ""
"Morphisms can also be contravariant in one or more of their arguments. A "
"morphism is contravariant on an argument associated to the relation "
"instance :math:`R` if it is covariant on the same argument when the inverse "
"relation :math:`R^{−1}` (``inverse R`` in Coq) is considered. The special "
"arrow ``-->`` is used in signatures for contravariant morphisms."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:109
msgid ""
"Functions having arguments related by symmetric relations instances are both "
"covariant and contravariant in those arguments. The special arrow ``==>`` is "
"used in signatures for morphisms that are both covariant and contravariant."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:114
msgid ""
"An instance of a parametric morphism :math:`f` with :math:`n` parameters is "
"any term :math:`f \\, t_1 \\ldots t_n`."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:117
msgid "Example: Morphisms"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:119
msgid ""
"Continuing the previous example, let ``union: forall (A : Type), list A -> "
"list A -> list A`` perform the union of two sets by appending one list to "
"the other. ``union` is a binary morphism parametric over ``A`` that respects "
"the relation instance ``(set_eq A)``. The latter condition is proved by "
"showing:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:131
msgid ""
"The signature of the function ``union A`` is ``set_eq A ==> set_eq A ==> "
"set_eq A`` for all ``A``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:134
msgid "Example: Contravariant morphisms"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:136
msgid ""
"The division function ``Rdiv : R -> R -> R`` is a morphism of signature ``le "
"++> le --> le`` where ``le`` is the usual order relation over real numbers. "
"Notice that division is covariant in its first argument and contravariant in "
"its second argument."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:141
msgid ""
"Leibniz equality is a relation and every function is a morphism that "
"respects Leibniz equality. Unfortunately, Leibniz equality is not always the "
"intended equality for a given structure."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:145
msgid ""
"In the next section we will describe the commands to register terms as "
"parametric relations and morphisms. Several tactics that deal with equality "
"in Coq can also work with the registered relations. The exact list of "
"tactics will be given :ref:`in this section <tactics-enabled-on-user-"
"provided-relations>`. For instance, the tactic reflexivity can be used to "
"solve a goal ``R n n`` whenever ``R`` is an instance of a registered "
"reflexive relation. However, the tactics that replace in a context ``C[]`` "
"one term with another one related by ``R`` must verify that ``C[]`` is a "
"morphism that respects the intended relation. Currently the verification "
"consists of checking whether ``C[]`` is a syntactic composition of morphism "
"instances that respects some obvious compatibility constraints."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:157
msgid "Example: Rewriting"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:159
msgid ""
"Continuing the previous examples, suppose that the user must prove ``set_eq "
"int (union int (union int S1 S2) S2) (f S1 S2)`` under the hypothesis ``H : "
"set_eq int S2 (@nil int)``. It is possible to use the ``rewrite`` tactic to "
"replace the first two occurrences of ``S2`` with ``@nil int`` in the goal "
"since the context ``set_eq int (union int (union int S1 nil) nil) (f S1 "
"S2)``, being a composition of morphisms instances, is a morphism. However "
"the tactic will fail replacing the third occurrence of ``S2``  unless ``f`` "
"has also been declared as a morphism."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:171
msgid "Adding new relations and morphisms"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:175
msgid ""
"This command declares a parametric relation :g:`Aeq: forall (y1 : β1 ... "
"ym : βm)`, :g:`relation (A t1 ... tn)` over :g:`(A : αi -> ... αn -> Type)`."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:178
msgid ""
"The :token:`ident` gives a unique name to the morphism and it is used by the "
"command to generate fresh names for automatically provided lemmas used "
"internally."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:182
msgid ""
"Notice that the carrier and relation parameters may refer to the context of "
"variables introduced at the beginning of the declaration, but the instances "
"need not be made only of variables. Also notice that ``A`` is *not* required "
"to be a term having the same parameters as ``Aeq``, although that is often "
"the case in practice (this departs from the previous implementation)."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:189
msgid ""
"To use this command, you need to first import the module ``Setoid`` using "
"the command ``Require Import Setoid``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:194
msgid ""
"In case the carrier and relations are not parametric, one can use this "
"command instead, whose syntax is the same except there is no local context."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:197
msgid ""
"The proofs of reflexivity, symmetry and transitivity can be omitted if the "
"relation is not an equivalence relation. The proofs must be instances of the "
"corresponding relation definitions: e.g. the proof of reflexivity must have "
"a type convertible to :g:`reflexive (A t1 ... tn) (Aeq t′ 1 …t′ n)`. Each "
"proof may refer to the introduced variables as well."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:206
msgid "For Leibniz equality, we may declare:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:214
msgid ""
"Some tactics (:tacn:`reflexivity`, :tacn:`symmetry`, :tacn:`transitivity`) "
"work only on relations that respect the expected properties. The remaining "
"tactics (:tacn:`replace`, :tacn:`rewrite` and derived tactics such as :tacn:"
"`autorewrite`) do not require any properties over the relation. However, "
"they are able to replace terms with related ones only in contexts that are "
"syntactic compositions of parametric morphism instances declared with the "
"following command."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:224
msgid ""
"This command declares ``f`` as a parametric morphism of signature ``sig``. "
"The identifier :token:`ident` gives a unique name to the morphism and it is "
"used as the base name of the typeclass instance definition and as the name "
"of the lemma that proves the well-definedness of the morphism. The "
"parameters of the morphism as well as the signature may refer to the context "
"of variables. The command asks the user to prove interactively that ``f`` "
"respects the relations identified from the signature."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:234
msgid ""
"We start the example by assuming a small theory over homogeneous sets and we "
"declare set equality as a parametric equivalence relation and union of two "
"sets as a parametric morphism."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:273
msgid ""
"It is possible to reduce the burden of specifying parameters using "
"(maximally inserted) implicit arguments. If ``A`` is always set as maximally "
"implicit in the previous example, one can write:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:294
msgid ""
"We proceed now by proving a simple lemma performing a rewrite step and then "
"applying reflexivity, as we would do working with Leibniz equality. Both "
"tactic applications are accepted since the required properties over "
"``eq_set`` and ``union`` can be established from the two declarations above."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:309
msgid ""
"The tables of relations and morphisms are managed by the typeclass instance "
"mechanism. The behavior on section close is to generalize the instances by "
"the variables of the section (and possibly hypotheses used in the proofs of "
"instance declarations) but not to export them in the rest of the development "
"for proof search. One can use the cmd:`Existing Instance` command to do so "
"outside the section, using the name of the declared morphism suffixed by "
"``_Morphism``, or use the ``Global`` modifier for the corresponding class "
"instance declaration (see :ref:`First Class Setoids and Morphisms <first-"
"class-setoids-and-morphisms>`) at definition time. When loading a compiled "
"file or importing a module, all the declarations of this module will be "
"loaded."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:323
msgid "Rewriting and non reflexive relations"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:325
msgid ""
"To replace only one argument of an n-ary morphism it is necessary to prove "
"that all the other arguments are related to themselves by the respective "
"relation instances."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:331
msgid ""
"To replace ``(union S empty)`` with ``S`` in ``(union (union S empty) S) "
"(union S S)`` the rewrite tactic must exploit the monotony of ``union`` "
"(axiom ``union_compat`` in the previous example). Applying ``union_compat`` "
"by hand we are left with the goal ``eq_set (union S S) (union S S)``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:336
msgid ""
"When the relations associated to some arguments are not reflexive, the "
"tactic cannot automatically prove the reflexivity goals, that are left to "
"the user."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:340
msgid ""
"Setoids whose relations are partial equivalence relations (PER) are useful "
"for dealing with partial functions. Let ``R`` be a PER. We say that an "
"element ``x`` is defined if ``R x x``. A partial function whose domain "
"comprises all the defined elements is declared as a morphism that respects "
"``R``. Every time a rewriting step is performed the user must prove that the "
"argument of the morphism is defined."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:349
msgid ""
"Let ``eqO`` be ``fun x y => x = y /\\ x <> 0`` (the smallest PER over "
"nonzero elements). Division can be declared as a morphism of signature ``eq "
"==> eq0 ==> eq``. Replacing ``x`` with ``y`` in ``div x n = div y n`` opens "
"an additional goal ``eq0 n n`` which is equivalent to ``n = n /\\ n <> 0``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:357
msgid "Rewriting and non symmetric relations"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:359
msgid ""
"When the user works up to relations that are not symmetric, it is no longer "
"the case that any covariant morphism argument is also contravariant. As a "
"result it is no longer possible to replace a term with a related one in "
"every context, since the obtained goal implies the previous one if and only "
"if the replacement has been performed in a contravariant position. In a "
"similar way, replacement in an hypothesis can be performed only if the "
"replaced term occurs in a covariant position."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:368
msgid "Example: Covariance and contravariance"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:370
msgid ""
"Suppose that division over real numbers has been defined as a morphism of "
"signature ``Z.div : Z.lt ++> Z.lt --> Z.lt`` (i.e. ``Z.div`` is increasing "
"in its first argument, but decreasing on the second one). Let ``<`` denote "
"``Z.lt``. Under the hypothesis ``H : x < y`` we have ``k < x / y -> k < x / "
"x``, but not ``k < y / x -> k < x / x``. Dually, under the same hypothesis "
"``k < x / y -> k < y / y`` holds, but ``k < y / x -> k < y / y`` does not. "
"Thus, if the current goal is ``k < x / x``, it is possible to replace only "
"the second occurrence of ``x`` (in contravariant position) with ``y`` since "
"the obtained goal must imply the current one. On the contrary, if ``k < x / "
"x`` is an hypothesis, it is possible to replace only the first occurrence of "
"``x`` (in covariant position) with ``y`` since the current hypothesis must "
"imply the obtained one."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:384
msgid ""
"Contrary to the previous implementation, no specific error message will be "
"raised when trying to replace a term that occurs in the wrong position. It "
"will only fail because the rewriting constraints are not satisfiable. "
"However it is possible to use the at modifier to specify which occurrences "
"should be rewritten."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:390
msgid ""
"As expected, composing morphisms together propagates the variance "
"annotations by switching the variance every time a contravariant position is "
"traversed."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:396
msgid ""
"Let us continue the previous example and let us consider the goal ``x / (x / "
"x) < k``. The first and third occurrences of ``x`` are in a contravariant "
"position, while the second one is in covariant position. More in detail, the "
"second occurrence of ``x`` occurs covariantly in ``(x / x)`` (since division "
"is covariant in its first argument), and thus contravariantly in ``x / (x / "
"x)`` (since division is contravariant in its second argument), and finally "
"covariantly in ``x / (x / x) < k`` (since ``<``, as every transitive "
"relation, is contravariant in its first argument with respect to the "
"relation itself)."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:409
msgid "Rewriting in ambiguous setoid contexts"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:411
msgid ""
"One function can respect several different relations and thus it can be "
"declared as a morphism having multiple signatures."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:416
msgid ""
"Union over homogeneous lists can be given all the following signatures: ``eq "
"==> eq ==> eq`` (``eq`` being the equality over ordered lists) ``set_eq ==> "
"set_eq ==> set_eq`` (``set_eq`` being the equality over unordered lists up "
"to duplicates), ``multiset_eq ==> multiset_eq ==> multiset_eq`` "
"(``multiset_eq`` being the equality over unordered lists)."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:423
msgid ""
"To declare multiple signatures for a morphism, repeat the :cmd:`Add "
"Morphism` command."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:426
msgid ""
"When morphisms have multiple signatures it can be the case that a rewrite "
"request is ambiguous, since it is unclear what relations should be used to "
"perform the rewriting. Contrary to the previous implementation, the tactic "
"will always choose the first possible solution to the set of constraints "
"generated by a rewrite and will not try to find *all* the possible solutions "
"to warn the user about them."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:435
msgid "Commands and tactics"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:441
msgid "First class setoids and morphisms"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:445
msgid ""
"The implementation is based on a first-class representation of properties of "
"relations and morphisms as typeclasses. That is, the various combinations of "
"properties on relations and morphisms are represented as records and "
"instances of theses classes are put in a hint database. For example, the "
"declaration:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:460
msgid "is equivalent to an instance declaration:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:469
msgid ""
"The declaration itself amounts to the definition of an object of the record "
"type ``Coq.Classes.RelationClasses.Equivalence`` and a hint added to the "
"``typeclass_instances`` hint database. Morphism declarations are also "
"instances of a typeclass defined in ``Classes.Morphisms``. See the "
"documentation on :ref:`typeclasses` and the theories files in Classes for "
"further explanations."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:476
msgid ""
"One can inform the rewrite tactic about morphisms and relations just by "
"using the typeclass mechanism to declare them using Instance and Context "
"vernacular commands. Any object of type Proper (the type of morphism "
"declarations) in the local context will also be automatically used by the "
"rewriting tactic to solve constraints."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:482
msgid ""
"Other representations of first class setoids and morphisms can also be "
"handled by encoding them as records. In the following example, the "
"projections of the setoid relation and of the morphism function can be "
"registered as parametric relations and morphisms."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:487
msgid "Example: First class setoids"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:522
msgid "Tactics enabled on user provided relations"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:524
msgid ""
"The following tactics, all prefixed by ``setoid_``, deal with arbitrary "
"registered relations and morphisms. Moreover, all the corresponding "
"unprefixed tactics (i.e. :tacn:`reflexivity`, :tacn:`symmetry`, :tacn:"
"`transitivity`, :tacn:`replace`, :tacn:`rewrite`) have been extended to fall "
"back to their prefixed counterparts when the relation involved is not "
"Leibniz equality. Notice, however, that using the prefixed tactics it is "
"possible to pass additional arguments such as ``using relation``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:547
msgid ""
"The ``using relation`` arguments cannot be passed to the unprefixed form. "
"The latter argument tells the tactic what parametric relation should be used "
"to replace the first tactic argument with the second one. If omitted, it "
"defaults to the ``DefaultRelation`` instance on the type of the objects. By "
"default, it means the most recent ``Equivalence`` instance in the "
"environment, but it can be customized by declaring new ``DefaultRelation`` "
"instances. As Leibniz equality is a declared equivalence, it will fall back "
"to it if no other relation is declared on a given type."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:557
msgid ""
"Every derived tactic that is based on the unprefixed forms of the tactics "
"considered above will also work up to user defined relations. For instance, "
"it is possible to register hints for :tacn:`autorewrite` that are not proofs "
"of Leibniz equalities. In particular it is possible to exploit :tacn:"
"`autorewrite` to simulate normalization in a term rewriting system up to "
"user defined equalities."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:566
msgid "Printing relations and morphisms"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:570
msgid ""
"This command can be used to show the list of currently registered "
"``Reflexive`` (using ``Print Instances Reflexive``), ``Symmetric`` or "
"``Transitive`` relations, Equivalences, PreOrders, PERs, and Morphisms "
"(implemented as ``Proper`` instances). When the rewriting tactics refuse to "
"replace a term in a context because the latter is not a composition of "
"morphisms, the :cmd:`Print Instances` command can be useful to understand "
"what additional morphisms should be registered."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:580
msgid "Deprecated syntax and backward incompatibilities"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:584
msgid ""
"This command for declaring setoids and morphisms is also accepted due to "
"backward compatibility reasons."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:587
msgid ""
"Here ``Aeq`` is a congruence relation without parameters, ``A`` is its "
"carrier and ``ST`` is an object of type (``Setoid_Theory A Aeq``) (i.e. a "
"record packing together the reflexivity, symmetry and transitivity lemmas). "
"Notice that the syntax is not completely backward compatible since the "
"identifier was not required."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:596
msgid ""
"This command is restricted to the declaration of morphisms without "
"parameters. It is not fully backward compatible since the property the user "
"is asked to prove is slightly different: for n-ary morphisms the hypotheses "
"of the property are permuted; moreover, when the morphism returns a "
"proposition, the property is now stated using a bi-implication in place of a "
"simple implication. In practice, porting an old development to the new "
"semantics is usually quite simple."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:604
msgid ""
"Notice that several limitations of the old implementation have been lifted. "
"In particular, it is now possible to declare several relations with the same "
"carrier and several signatures for the same morphism. Moreover, it is now "
"also possible to declare several morphisms having the same signature. "
"Finally, the :tacn:`replace` and :tacn:`rewrite` tactics can be used to "
"replace terms in contexts that were refused by the old implementation. As "
"discussed in the next section, the semantics of the new :tacn:"
"`setoid_rewrite` tactic differs slightly from the old one and :tacn:"
"`rewrite`."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:616
msgid "Extensions"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:620
msgid "Rewriting under binders"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:623
msgid ""
"Due to compatibility issues, this feature is enabled only when calling the :"
"tacn:`setoid_rewrite` tactic directly and not :tacn:`rewrite`."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:626
msgid ""
"To be able to rewrite under binding constructs, one must declare morphisms "
"with respect to pointwise (setoid) equivalence of functions. Example of such "
"morphisms are the standard ``all`` and ``ex`` combinators for universal and "
"existential quantification respectively. They are declared as morphisms in "
"the ``Classes.Morphisms_Prop`` module. For example, to declare that "
"universal quantification is a morphism for logical equivalence:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:643
msgid ""
"One then has to show that if two predicates are equivalent at every point, "
"their universal quantifications are equivalent. Once we have declared such a "
"morphism, it will be used by the setoid rewriting tactic each time we try to "
"rewrite under an ``all`` application (products in ``Prop`` are implicitly "
"translated to such applications)."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:649
msgid ""
"Indeed, when rewriting under a lambda, binding variable ``x``, say from ``P "
"x`` to ``Q x`` using the relation iff, the tactic will generate a proof of "
"``pointwise_relation A iff (fun x => P x) (fun x => Q x)`` from the proof of "
"``iff (P x) (Q x)`` and a constraint of the form ``Proper "
"(pointwise_relation A iff ==> ?) m`` will be generated for the surrounding "
"morphism ``m``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:655
msgid ""
"Hence, one can add higher-order combinators as morphisms by providing "
"signatures using pointwise extension for the relations on the functional "
"arguments (or whatever subrelation of the pointwise extension). For example, "
"one could declare the ``map`` combinator on lists as a morphism:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:666
msgid ""
"where ``list_equiv`` implements an equivalence on lists parameterized by an "
"equivalence on the elements."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:669
msgid ""
"Note that when one does rewriting with a lemma under a binder using :tacn:"
"`setoid_rewrite`, the application of the lemma may capture the bound "
"variable, as the semantics are different from rewrite where the lemma is "
"first matched on the whole term. With the new :tacn:`setoid_rewrite`, "
"matching is done on each subterm separately and in its local environment, "
"and all matches are rewritten *simultaneously* by default. The semantics of "
"the previous :tacn:`setoid_rewrite` implementation can almost be recovered "
"using the ``at 1`` modifier."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:680
msgid "Subrelations"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:682
msgid ""
"Subrelations can be used to specify that one relation is included in "
"another, so that morphism signatures for one can be used for the other. If a "
"signature mentions a relation ``R`` on the left of an arrow ``==>``, then "
"the signature also applies for any relation ``S`` that is smaller than "
"``R``, and the inverse applies on the right of an arrow. One can then "
"declare only a few morphisms instances that generate the complete set of "
"signatures for a particular constant. By default, the only declared "
"subrelation is ``iff``, which is a subrelation of ``impl`` and ``inverse "
"impl`` (the dual of implication). That’s why we can declare only two "
"morphisms for conjunction: ``Proper (impl ==> impl ==> impl) and`` and "
"``Proper (iff ==> iff ==> iff) and``. This is sufficient to satisfy any "
"rewriting constraints arising from a rewrite using ``iff``, ``impl`` or "
"``inverse impl`` through ``and``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:696
msgid ""
"Subrelations are implemented in ``Classes.Morphisms`` and are a prime "
"example of a mostly user-space extension of the algorithm."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:701
msgid "Constant unfolding"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:703
msgid ""
"The resolution tactic is based on typeclasses and hence regards user- "
"defined constants as transparent by default. This may slow down the "
"resolution due to a lot of unifications (all the declared ``Proper`` "
"instances are tried at each node of the search tree). To speed it up, "
"declare your constant as rigid for proof search using the command :cmd:"
"`Typeclasses Opaque`."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:711
msgid "Strategies for rewriting"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:714
msgid "Definitions"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:716
msgid ""
"The generalized rewriting tactic is based on a set of strategies that can be "
"combined to obtain custom rewriting procedures. Its set of strategies is "
"based on Elan’s rewriting strategies :cite:`Luttik97specificationof`. "
"Rewriting strategies are applied using the tactic ``rewrite_strat s`` where "
"``s`` is a strategy expression. Strategies are defined inductively as "
"described by the following grammar:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:772
msgid ""
"Actually a few of these are defined in term of the others using a primitive "
"fixpoint operator:"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:784
msgid ""
"The basic control strategy semantics are straightforward: strategies are "
"applied to subterms of the term to rewrite, starting from the root of the "
"term. The lemma strategies unify the left-hand-side of the lemma with the "
"current subterm and on success rewrite it to the right- hand-side. "
"Composition can be used to continue rewriting on the current subterm. The "
"fail strategy always fails while the identity strategy succeeds without "
"making progress. The reflexivity strategy succeeds, making progress using a "
"reflexivity proof of rewriting. Progress tests progress of the argument "
"strategy and fails if no progress was made, while ``try`` always succeeds, "
"catching failures. Choice is left-biased: it will launch the first strategy "
"and fall back on the second one in case of failure. One can iterate a "
"strategy at least 1 time using ``repeat`` and at least 0 times using ``any``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:798
msgid ""
"The ``subterm`` and ``subterms`` strategies apply their argument strategy "
"``s`` to respectively one or all subterms of the current term under "
"consideration, left-to-right. ``subterm`` stops at the first subterm for "
"which ``s`` made progress. The composite strategies ``innermost`` and "
"``outermost`` perform a single innermost or outermost rewrite using their "
"argument strategy. Their counterparts ``bottomup`` and ``topdown`` perform "
"as many rewritings as possible, starting from the bottom or the top of the "
"term."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:807
msgid ""
"Hint databases created for :tacn:`autorewrite` can also be used by :tacn:"
"`rewrite_strat` using the ``hints`` strategy that applies any of the lemmas "
"at the current subterm. The ``terms`` strategy takes the lemma names "
"directly as arguments. The ``eval`` strategy expects a reduction expression "
"(see :ref:`performingcomputations`) and succeeds if it reduces the subterm "
"under consideration. The ``fold`` strategy takes a term ``c`` and tries to "
"*unify* it to the current subterm, converting it to ``c`` on success, it is "
"stronger than the tactic ``fold``."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:818
msgid "Usage"
msgstr ""

#: ../../addendum/generalized-rewriting.rst:824
msgid "Rewrite using the strategy s in hypothesis ident or the conclusion."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:828
msgid "If the strategy failed."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:832
msgid "If the strategy succeeded but made no progress."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:836
msgid ""
"If the strategy succeeded and made progress but the corresponding rewriting "
"constraints are not satisfied."
msgstr ""

#: ../../addendum/generalized-rewriting.rst:840
msgid ""
"The ``setoid_rewrite c`` tactic is basically equivalent to ``rewrite_strat "
"(outermost c)``."
msgstr ""

#: ../../addendum/implicit-coercions.rst:4
msgid "Implicit Coercions"
msgstr ""

#: ../../addendum/implicit-coercions.rst:6
msgid "Amokrane Saïbi"
msgstr ""

#: ../../addendum/implicit-coercions.rst:9
#: ../../addendum/universe-polymorphism.rst:9
msgid "General Presentation"
msgstr ""

#: ../../addendum/implicit-coercions.rst:11
msgid ""
"This section describes the inheritance mechanism of |Coq|. In |Coq| with "
"inheritance, we are not interested in adding any expressive power to our "
"theory, but only convenience. Given a term, possibly not typable, we are "
"interested in the problem of determining if it can be well typed modulo "
"insertion of appropriate coercions. We allow to write:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:17
msgid ""
":g:`f a` where :g:`f:(forall x:A,B)` and :g:`a:A'` when ``A'`` can be seen "
"in some sense as a subtype of ``A``."
msgstr ""

#: ../../addendum/implicit-coercions.rst:19
msgid ""
":g:`x:A` when ``A`` is not a type, but can be seen in a certain sense as a "
"type: set, group, category etc."
msgstr ""

#: ../../addendum/implicit-coercions.rst:21
msgid ""
":g:`f a` when ``f`` is not a function, but can be seen in a certain sense as "
"a function: bijection, functor, any structure morphism etc."
msgstr ""

#: ../../addendum/implicit-coercions.rst:26
msgid "Classes"
msgstr ""

#: ../../addendum/implicit-coercions.rst:28
msgid ""
"A class with `n` parameters is any defined name with a type :g:`forall (x₁:"
"A₁)..(xₙ:Aₙ),s` where ``s`` is a sort.  Thus a class with parameters is "
"considered as a single class and not as a family of classes.  An object of a "
"class ``C`` is any term of type :g:`C t₁ .. tₙ`. In addition to these user-"
"defined classes, we have two built-in classes:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:35
msgid ""
"``Sortclass``, the class of sorts; its objects are the terms whose type is a "
"sort (e.g. :g:`Prop` or :g:`Type`)."
msgstr ""

#: ../../addendum/implicit-coercions.rst:37
msgid ""
"``Funclass``, the class of functions; its objects are all the terms with a "
"functional type, i.e. of form :g:`forall x:A,B`."
msgstr ""

#: ../../addendum/implicit-coercions.rst:40
msgid "Formally, the syntax of a classes is defined as:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:49
msgid "Coercions"
msgstr ""

#: ../../addendum/implicit-coercions.rst:51
msgid ""
"A name ``f`` can be declared as a coercion between a source user-defined "
"class ``C`` with `n` parameters and a target class ``D`` if one of these "
"conditions holds:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:55
msgid ""
"``D`` is a user-defined class, then the type of ``f`` must have the form :g:"
"`forall (x₁:A₁)..(xₙ:Aₙ)(y:C x₁..xₙ), D u₁..uₘ` where `m` is the number of "
"parameters of ``D``."
msgstr ""

#: ../../addendum/implicit-coercions.rst:58
msgid ""
"``D`` is ``Funclass``, then the type of ``f`` must have the form :g:`forall "
"(x₁:A₁)..(xₙ:Aₙ)(y:C x₁..xₙ)(x:A), B`."
msgstr ""

#: ../../addendum/implicit-coercions.rst:60
msgid ""
"``D`` is ``Sortclass``, then the type of ``f`` must have the form :g:`forall "
"(x₁:A₁)..(xₙ:Aₙ)(y:C x₁..xₙ), s` with ``s`` a sort."
msgstr ""

#: ../../addendum/implicit-coercions.rst:63
msgid ""
"We then write :g:`f : C >-> D`. The restriction on the type of coercions is "
"called *the uniform inheritance condition*."
msgstr ""

#: ../../addendum/implicit-coercions.rst:66
msgid ""
"The built-in class ``Sortclass`` can be used as a source class, but the "
"built-in class ``Funclass`` cannot."
msgstr ""

#: ../../addendum/implicit-coercions.rst:69
msgid ""
"To coerce an object :g:`t:C t₁..tₙ` of ``C`` towards ``D``, we have to apply "
"the coercion ``f`` to it; the obtained term :g:`f t₁..tₙ t` is then an "
"object of ``D``."
msgstr ""

#: ../../addendum/implicit-coercions.rst:75
msgid "Identity Coercions"
msgstr ""

#: ../../addendum/implicit-coercions.rst:77
msgid ""
"Identity coercions are special cases of coercions used to go around the "
"uniform inheritance condition. Let ``C`` and ``D`` be two classes with "
"respectively `n` and `m` parameters and :g:`f:forall (x₁:T₁)..(xₖ:Tₖ)(y:C "
"u₁..uₙ), D v₁..vₘ` a function which does not verify the uniform inheritance "
"condition. To declare ``f`` as coercion, one has first to declare a subclass "
"``C'`` of ``C``:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:84
msgid ":g:`C' := fun (x₁:T₁)..(xₖ:Tₖ) => C u₁..uₙ`"
msgstr ""

#: ../../addendum/implicit-coercions.rst:86
msgid "We then define an *identity coercion* between ``C'`` and ``C``:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:88
msgid ":g:`Id_C'_C  := fun (x₁:T₁)..(xₖ:Tₖ)(y:C' x₁..xₖ) => (y:C u₁..uₙ)`"
msgstr ""

#: ../../addendum/implicit-coercions.rst:90
msgid ""
"We can now declare ``f`` as coercion from ``C'`` to ``D``, since we can "
"\"cast\" its type as :g:`forall (x₁:T₁)..(xₖ:Tₖ)(y:C' x₁..xₖ),D v₁..vₘ`."
msgstr ""

#: ../../addendum/implicit-coercions.rst:94
msgid ""
"The identity coercions have a special status: to coerce an object :g:`t:C' "
"t₁..tₖ` of ``C'`` towards ``C``, we do not have to insert explicitly "
"``Id_C'_C`` since :g:`Id_C'_C t₁..tₖ t` is convertible with ``t``.  However "
"we \"rewrite\" the type of ``t`` to become an object of ``C``; in this case, "
"it becomes :g:`C uₙ'..uₖ'` where each ``uᵢ'`` is the result of the "
"substitution in ``uᵢ`` of the variables ``xⱼ`` by ``tⱼ``."
msgstr ""

#: ../../addendum/implicit-coercions.rst:103
msgid "Inheritance Graph"
msgstr ""

#: ../../addendum/implicit-coercions.rst:105
msgid ""
"Coercions form an inheritance graph with classes as nodes.  We call "
"*coercion path* an ordered list of coercions between two nodes of the "
"graph.  A class ``C`` is said to be a subclass of ``D`` if there is a "
"coercion path in the graph from ``C`` to ``D``; we also say that ``C`` "
"inherits from ``D``. Our mechanism supports multiple inheritance since a "
"class may inherit from several classes, contrary to simple inheritance where "
"a class inherits from at most one class.  However there must be at most one "
"path between two classes. If this is not the case, only the *oldest* one is "
"valid and the others are ignored. So the order of declaration of coercions "
"is important."
msgstr ""

#: ../../addendum/implicit-coercions.rst:116
msgid ""
"We extend notations for coercions to coercion paths. For instance :g:`[f₁;..;"
"fₖ] : C >-> D` is the coercion path composed by the coercions ``f₁..fₖ``.  "
"The application of a coercion path to a term consists of the successive "
"application of its coercions."
msgstr ""

#: ../../addendum/implicit-coercions.rst:123
msgid "Declaring Coercions"
msgstr ""

#: ../../addendum/implicit-coercions.rst:127
msgid ""
"Declares the construction denoted by `qualid` as a coercion between the two "
"given classes."
msgstr ""

#: ../../addendum/implicit-coercions.rst:141
msgid ""
"When the coercion :token:`qualid` is added to the inheritance graph, invalid "
"coercion paths are ignored; they are signaled by a warning displaying these "
"paths of the form :g:`[f₁;..;fₙ] : C >-> D`."
msgstr ""

#: ../../addendum/implicit-coercions.rst:147
msgid ""
"Declares the construction denoted by `qualid` as a coercion local to the "
"current section."
msgstr ""

#: ../../addendum/implicit-coercions.rst:152
msgid ""
"This defines `ident` just like ``Definition`` `ident` ``:=`` `term`, and "
"then declares `ident` as a coercion between it source and its target."
msgstr ""

#: ../../addendum/implicit-coercions.rst:157
msgid ""
"This defines `ident` just like ``Definition`` `ident` : `type` ``:=`` "
"`term`, and then declares `ident` as a coercion between it source and its "
"target."
msgstr ""

#: ../../addendum/implicit-coercions.rst:162
msgid ""
"This defines `ident` just like ``Let`` `ident` ``:=`` `term`, and then "
"declares `ident` as a coercion between it source and its target."
msgstr ""

#: ../../addendum/implicit-coercions.rst:165
msgid ""
"Assumptions can be declared as coercions at declaration time. This extends "
"the grammar of assumptions from Figure :ref:`vernacular` as follows:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:182
msgid ""
"If the extra ``>`` is present before the type of some assumptions, these "
"assumptions are declared as coercions."
msgstr ""

#: ../../addendum/implicit-coercions.rst:185
msgid ""
"Similarly, constructors of inductive types can be declared as coercions at "
"definition time of the inductive type. This extends and modifies the grammar "
"of inductive types from Figure :ref:`vernacular` as follows:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:200
msgid ""
"Especially, if the extra ``>`` is present in a constructor declaration, this "
"constructor is declared as a coercion."
msgstr ""

#: ../../addendum/implicit-coercions.rst:205
msgid ""
"If ``C`` is the source `class` and ``D`` the destination, we check that "
"``C`` is a constant with a body of the form :g:`fun (x₁:T₁)..(xₙ:Tₙ) => D "
"t₁..tₘ` where `m` is the number of parameters of ``D``.  Then we define an "
"identity function with type :g:`forall (x₁:T₁)..(xₙ:Tₙ)(y:C x₁..xₙ),D t₁.."
"tₘ`, and we declare it as an identity coercion between ``C`` and ``D``."
msgstr ""

#: ../../addendum/implicit-coercions.rst:216
msgid "Same as ``Identity Coercion`` but locally to the current section."
msgstr ""

#: ../../addendum/implicit-coercions.rst:221
msgid ""
"If `type` is a class `ident'` applied to some arguments then `ident` is "
"defined and an identity coercion of name `Id_ident_ident'` is declared. "
"Otherwise said, this is an abbreviation for"
msgstr ""

#: ../../addendum/implicit-coercions.rst:226
msgid "``Definition`` `ident` ``:=`` `type`."
msgstr ""

#: ../../addendum/implicit-coercions.rst:228
msgid "``Identity Coercion`` `Id_ident_ident'` : `ident` ``>->`` `ident'`."
msgstr ""

#: ../../addendum/implicit-coercions.rst:232
msgid "Same as before but locally to the current section."
msgstr ""

#: ../../addendum/implicit-coercions.rst:236
msgid "Displaying Available Coercions"
msgstr ""

#: ../../addendum/implicit-coercions.rst:240
msgid "Print the list of declared classes in the current context."
msgstr ""

#: ../../addendum/implicit-coercions.rst:244
msgid "Print the list of declared coercions in the current context."
msgstr ""

#: ../../addendum/implicit-coercions.rst:248
msgid "Print the list of valid coercion paths in the current context."
msgstr ""

#: ../../addendum/implicit-coercions.rst:252
msgid "Print the list of valid coercion paths between the two given classes."
msgstr ""

#: ../../addendum/implicit-coercions.rst:255
msgid "Activating the Printing of Coercions"
msgstr ""

#: ../../addendum/implicit-coercions.rst:259
msgid ""
"When on, this option forces all the coercions to be printed. By default, "
"coercions are not printed."
msgstr ""

#: ../../addendum/implicit-coercions.rst:265
msgid ""
"Specifies a set of qualids for which coercions are always displayed.  Use "
"the :cmd:`Add @table` and :cmd:`Remove @table` commands to update the set of "
"qualids."
msgstr ""

#: ../../addendum/implicit-coercions.rst:271
msgid "Classes as Records"
msgstr ""

#: ../../addendum/implicit-coercions.rst:273
msgid ""
"We allow the definition of *Structures with Inheritance* (or classes as "
"records) by extending the existing :cmd:`Record` macro. Its new syntax is:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:278
msgid ""
"The first identifier `ident` is the name of the defined record and `sort` is "
"its type. The optional identifier after ``:=`` is the name of the constuctor "
"(it will be ``Build_``\\ `ident` if not given). The other identifiers are "
"the names of the fields, and the `term` are their respective types. If ``:"
">`` is used instead of ``:`` in the declaration of a field, then the name of "
"this field is automatically declared as a coercion from the record name to "
"the class of this field type. Remark that the fields always verify the "
"uniform inheritance condition. If the optional ``>`` is given before the "
"record name, then the constructor name is automatically declared as a "
"coercion from the class of the last field type to the record name (this may "
"fail if the uniform inheritance condition is not satisfied)."
msgstr ""

#: ../../addendum/implicit-coercions.rst:295
msgid "This is a synonym of :cmd:`Record`."
msgstr ""

#: ../../addendum/implicit-coercions.rst:299
msgid "Coercions and Sections"
msgstr ""

#: ../../addendum/implicit-coercions.rst:301
msgid ""
"The inheritance mechanism is compatible with the section mechanism. The "
"global classes and coercions defined inside a section are redefined after "
"its closing, using their new value and new type. The classes and coercions "
"which are local to the section are simply forgotten. Coercions with a local "
"source class or a local target class, and coercions which do not verify the "
"uniform inheritance condition any longer are also forgotten."
msgstr ""

#: ../../addendum/implicit-coercions.rst:311
msgid "Coercions and Modules"
msgstr ""

#: ../../addendum/implicit-coercions.rst:315
msgid ""
"Since |Coq| version 8.3, the coercions present in a module are activated "
"only when the module is explicitly imported. Formerly, the coercions were "
"activated as soon as the module was required, whether it was imported or not."
msgstr ""

#: ../../addendum/implicit-coercions.rst:320
msgid ""
"This option makes it possible to recover the behavior of the versions of |"
"Coq| prior to 8.3."
msgstr ""

#: ../../addendum/implicit-coercions.rst:324
msgid "Examples"
msgstr ""

#: ../../addendum/implicit-coercions.rst:326
msgid "There are three situations:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:329
msgid "Coercion at function application"
msgstr ""

#: ../../addendum/implicit-coercions.rst:331
msgid ""
":g:`f a` is ill-typed where :g:`f:forall x:A,B` and :g:`a:A'`. If there is a "
"coercion path between ``A'`` and ``A``, then :g:`f a` is transformed into :g:"
"`f a'` where ``a'`` is the result of the application of this coercion path "
"to ``a``."
msgstr ""

#: ../../addendum/implicit-coercions.rst:336
msgid "We first give an example of coercion between atomic inductive types"
msgstr ""

#: ../../addendum/implicit-coercions.rst:350
msgid ""
"Note that ``Check true=O`` would fail. This is \"normal\" behavior of "
"coercions. To validate ``true=O``, the coercion is searched from ``nat`` to "
"``bool``. There is none."
msgstr ""

#: ../../addendum/implicit-coercions.rst:354
msgid "We give an example of coercion between classes with parameters."
msgstr ""

#: ../../addendum/implicit-coercions.rst:370
msgid "We give now an example using identity coercions."
msgstr ""

#: ../../addendum/implicit-coercions.rst:384
msgid ""
"In the case of functional arguments, we use the monotonic rule of sub-"
"typing. To coerce :g:`t : forall x : A, B` towards :g:`forall x : A', B'`, "
"we have to coerce ``A'`` towards ``A`` and ``B`` towards ``B'``. An example "
"is given below:"
msgstr ""

#: ../../addendum/implicit-coercions.rst:400
msgid ""
"Remark the changes in the result following the modification of the previous "
"example."
msgstr ""

#: ../../addendum/implicit-coercions.rst:414
msgid "Coercion to a type"
msgstr ""

#: ../../addendum/implicit-coercions.rst:416
msgid ""
"An assumption ``x:A`` when ``A`` is not a type, is ill-typed.  It is "
"replaced by ``x:A'`` where ``A'`` is the result of the application to ``A`` "
"of the coercion path between the class of ``A`` and ``Sortclass`` if it "
"exists.  This case occurs in the abstraction :g:`fun x:A => t`, universal "
"quantification :g:`forall x:A,B`, global variables and parameters of "
"(co-)inductive definitions and functions. In :g:`forall x:A,B`, such a "
"coercion path may also be applied to ``B`` if necessary."
msgstr ""

#: ../../addendum/implicit-coercions.rst:441
msgid "Coercion to a function"
msgstr ""

#: ../../addendum/implicit-coercions.rst:443
msgid ""
"``f a`` is ill-typed because ``f:A`` is not a function. The term ``f`` is "
"replaced by the term obtained by applying to ``f`` the coercion path between "
"``A`` and ``Funclass`` if it exists."
msgstr ""

#: ../../addendum/implicit-coercions.rst:458
msgid "Let us see the resulting graph after all these examples."
msgstr ""

#: ../../addendum/micromega.rst:4
msgid "Micromega: tactics for solving arithmetic goals over ordered rings"
msgstr ""

#: ../../addendum/micromega.rst:6
msgid "Frédéric Besson and Evgeny Makarov"
msgstr ""

#: ../../addendum/micromega.rst:9
msgid "Short description of the tactics"
msgstr ""

#: ../../addendum/micromega.rst:11
msgid ""
"The Psatz module (``Require Import Psatz.``) gives access to several tactics "
"for solving arithmetic goals over :math:`\\mathbb{Z}`, :math:`\\mathbb{Q}`, "
"and :math:`\\mathbb{R}` [#]_. It also possible to get the tactics for "
"integers by a ``Require Import Lia``, rationals ``Require Import Lqa`` and "
"reals ``Require Import Lra``."
msgstr ""

#: ../../addendum/micromega.rst:16
msgid ":tacn:`lia` is a decision procedure for linear integer arithmetic;"
msgstr ""

#: ../../addendum/micromega.rst:17
msgid ""
":tacn:`nia` is an incomplete proof procedure for integer non-linear "
"arithmetic;"
msgstr ""

#: ../../addendum/micromega.rst:19
msgid ""
":tacn:`lra` is a decision procedure for linear (real or rational) arithmetic;"
msgstr ""

#: ../../addendum/micromega.rst:20
msgid ""
":tacn:`nra` is an incomplete proof procedure for non-linear (real or "
"rational) arithmetic;"
msgstr ""

#: ../../addendum/micromega.rst:22
msgid ""
":tacn:`psatz` ``D n`` where ``D`` is :math:`\\mathbb{Z}` or :math:`"
"\\mathbb{Q}` or :math:`\\mathbb{R}`, and ``n`` is an optional integer "
"limiting the proof search depth, is an incomplete proof procedure for non-"
"linear arithmetic. It is based on John Harrison’s HOL Light driver to the "
"external prover `csdp` [#]_. Note that the `csdp` driver is generating a "
"*proof cache* which makes it possible to rerun scripts even without `csdp`."
msgstr ""

#: ../../addendum/micromega.rst:30
msgid ""
"The tactics solve propositional formulas parameterized by atomic arithmetic "
"expressions interpreted over a domain :math:`D` ∈ {ℤ, ℚ, ℝ}. The syntax of "
"the formulas is the following:"
msgstr ""

#: ../../addendum/micromega.rst:39
msgid ""
"where :math:`c` is a numeric constant, :math:`x \\in D` is a numeric "
"variable, the operators :math:`−, +, ×` are respectively subtraction, "
"addition, and product; :math:`p ^ n` is exponentiation by a constant :math:"
"`n`, :math:`P` is an arbitrary proposition. For :math:`\\mathbb{Q}`, "
"equality is not Leibniz equality = but the equality of rationals ==."
msgstr ""

#: ../../addendum/micromega.rst:45
msgid ""
"For :math:`\\mathbb{Z}` (resp. :math:`\\mathbb{Q}`), :math:`c` ranges over "
"integer constants (resp. rational constants). For :math:`\\mathbb{R}`, the "
"tactic recognizes as real constants the following expressions:"
msgstr ""

#: ../../addendum/micromega.rst:53
msgid ""
"where :math:`z` is a constant in :math:`\\mathbb{Z}` and :math:`q` is a "
"constant in :math:`\\mathbb{Q}`. This includes integer constants written "
"using the decimal notation, *i.e.*, c%R."
msgstr ""

#: ../../addendum/micromega.rst:58
msgid "*Positivstellensatz* refutations"
msgstr ""

#: ../../addendum/micromega.rst:60
msgid ""
"The name `psatz` is an abbreviation for *positivstellensatz* – literally "
"\"positivity theorem\" – which generalizes Hilbert’s *nullstellensatz*. It "
"relies on the notion of Cone. Given a (finite) set of polynomials :math:"
"`S`, :math:`\\mathit{Cone}(S)` is inductively defined as the smallest set of "
"polynomials closed under the following rules:"
msgstr ""

#: ../../addendum/micromega.rst:66
msgid ""
":math:`\\begin{array}{l} \\dfrac{p \\in S}{p \\in \\mathit{Cone}(S)} \\quad "
"\\dfrac{}{p^2 \\in \\mathit{Cone}(S)} \\quad \\dfrac{p_1 \\in \\mathit{Cone}"
"(S) \\quad p_2 \\in \\mathit{Cone}(S) \\quad \\Join \\in \\{+,*\\}} {p_1 "
"\\Join p_2 \\in \\mathit{Cone}(S)}\\\\ \\end{array}`"
msgstr ""

#: ../../addendum/micromega.rst:73
msgid ""
"The following theorem provides a proof principle for checking that a set of "
"polynomial inequalities does not have solutions [#]_."
msgstr ""

#: ../../addendum/micromega.rst:78
msgid ""
"**Theorem (Psatz)**. Let :math:`S` be a set of polynomials. If :math:`-1` "
"belongs to :math:`\\mathit{Cone}(S)`, then the conjunction :math:`"
"\\bigwedge_{p \\in S} p\\ge 0`  is unsatisfiable. A proof based on this "
"theorem is called a *positivstellensatz* refutation. The tactics work as "
"follows. Formulas are normalized into conjunctive normal form :math:`"
"\\bigwedge_i C_i` where :math:`C_i` has the general form :math:"
"`(\\bigwedge_{j\\in S_i} p_j \\Join 0) \\to \\mathit{False}` and :math:`"
"\\Join \\in \\{>,\\ge,=\\}` for :math:`D\\in \\{\\mathbb{Q},\\mathbb{R}\\}` "
"and :math:`\\Join \\in \\{\\ge, =\\}` for :math:`\\mathbb{Z}`."
msgstr ""

#: ../../addendum/micromega.rst:88
msgid ""
"For each conjunct :math:`C_i`, the tactic calls an oracle which searches "
"for :math:`-1` within the cone. Upon success, the oracle returns a *cone "
"expression* that is normalized by the ring tactic (see :ref:"
"`theringandfieldtacticfamilies`) and checked to be :math:`-1`."
msgstr ""

#: ../../addendum/micromega.rst:94
msgid "`lra`: a decision procedure for linear real and rational arithmetic"
msgstr ""

#: ../../addendum/micromega.rst:99
msgid ""
"This tactic is searching for *linear* refutations using Fourier elimination "
"[#]_. As a result, this tactic explores a subset of the *Cone* defined as"
msgstr ""

#: ../../addendum/micromega.rst:103
msgid ""
":math:`\\mathit{LinCone}(S) =\\left\\{ \\left. \\sum_{p \\in S} \\alpha_p "
"\\times p~\\right|~\\alpha_p \\mbox{ are positive constants} \\right\\}`"
msgstr ""

#: ../../addendum/micromega.rst:105
msgid ""
"The deductive power of `lra` is the combined deductive power of "
"`ring_simplify` and `fourier`. There is also an overlap with the field "
"tactic *e.g.*, :math:`x = 10 * x / 10` is solved by `lra`."
msgstr ""

#: ../../addendum/micromega.rst:111
msgid "`lia`: a tactic for linear integer arithmetic"
msgstr ""

#: ../../addendum/micromega.rst:116
msgid ""
"This tactic offers an alternative to the :tacn:`omega` and :tacn:`romega` "
"tactics. Roughly speaking, the deductive power of lia is the combined "
"deductive power of :tacn:`ring_simplify` and :tacn:`omega`. However, it "
"solves linear goals that :tacn:`omega` and :tacn:`romega` do not solve, such "
"as the following so-called *omega nightmare* :cite:`TheOmegaPaper`."
msgstr ""

#: ../../addendum/micromega.rst:128
msgid ""
"The estimation of the relative efficiency of :tacn:`lia` *vs* :tacn:`omega` "
"and :tacn:`romega` is under evaluation."
msgstr ""

#: ../../addendum/micromega.rst:132
msgid "High level view of `lia`"
msgstr ""

#: ../../addendum/micromega.rst:134
msgid ""
"Over :math:`\\mathbb{R}`, *positivstellensatz* refutations are a complete "
"proof principle [#]_. However, this is not the case over :math:`\\mathbb{Z}"
"`. Actually, *positivstellensatz* refutations are not even sufficient to "
"decide linear *integer* arithmetic. The canonical example is :math:`2 * x = "
"1 -> \\mathtt{False}` which is a theorem of :math:`\\mathbb{Z}` but not a "
"theorem of :math:`{\\mathbb{R}}`. To remedy this weakness, the `lia` tactic "
"is using recursively a combination of:"
msgstr ""

#: ../../addendum/micromega.rst:141
msgid "linear *positivstellensatz* refutations;"
msgstr ""

#: ../../addendum/micromega.rst:142
msgid "cutting plane proofs;"
msgstr ""

#: ../../addendum/micromega.rst:143
msgid "case split."
msgstr ""

#: ../../addendum/micromega.rst:146
msgid "Cutting plane proofs"
msgstr ""

#: ../../addendum/micromega.rst:148
msgid ""
"are a way to take into account the discreteness of :math:`\\mathbb{Z}` by "
"rounding up (rational) constants up-to the closest integer."
msgstr ""

#: ../../addendum/micromega.rst:155
msgid ""
"Let :math:`p` be an integer and :math:`c` a rational constant. Then :math:`p "
"\\ge c \\rightarrow p \\ge \\lceil{c}\\rceil`."
msgstr ""

#: ../../addendum/micromega.rst:158
msgid "For instance, from 2 x = 1 we can deduce"
msgstr ""

#: ../../addendum/micromega.rst:160
msgid ""
":math:`x \\ge 1/2` whose cut plane is :math:`x \\ge \\lceil{1/2}\\rceil = 1`;"
msgstr ""

#: ../../addendum/micromega.rst:161
msgid ""
":math:`x \\le 1/2` whose cut plane is :math:`x \\le \\lfloor{1/2}\\rfloor = "
"0`."
msgstr ""

#: ../../addendum/micromega.rst:163
msgid ""
"By combining these two facts (in normal form) :math:`x − 1 \\ge 0` and :math:"
"`-x \\ge 0`, we conclude by exhibiting a *positivstellensatz* refutation: :"
"math:`−1 \\equiv x−1 + −x \\in \\mathit{Cone}({x−1,x})`."
msgstr ""

#: ../../addendum/micromega.rst:167
msgid ""
"Cutting plane proofs and linear *positivstellensatz* refutations are a "
"complete proof principle for integer linear arithmetic."
msgstr ""

#: ../../addendum/micromega.rst:171
msgid "Case split"
msgstr ""

#: ../../addendum/micromega.rst:173
msgid "enumerates over the possible values of an expression."
msgstr ""

#: ../../addendum/micromega.rst:177
msgid ""
"**Theorem**. Let :math:`p` be an integer and :math:`c_1` and :math:`c_2` "
"integer constants. Then:"
msgstr ""

#: ../../addendum/micromega.rst:180
msgid ""
":math:`c_1 \\le p \\le c_2 \\Rightarrow \\bigvee_{x \\in [c_1,c_2]} p = x`"
msgstr ""

#: ../../addendum/micromega.rst:182
msgid ""
"Our current oracle tries to find an expression :math:`e` with a small range :"
"math:`[c_1,c_2]`. We generate :math:`c_2 − c_1` subgoals which contexts are "
"enriched with an equation :math:`e = i` for :math:`i \\in [c_1,c_2]` and "
"recursively search for a proof."
msgstr ""

#: ../../addendum/micromega.rst:188
msgid "`nra`: a proof procedure for non-linear arithmetic"
msgstr ""

#: ../../addendum/micromega.rst:193
msgid ""
"This tactic is an *experimental* proof procedure for non-linear arithmetic. "
"The tactic performs a limited amount of non-linear reasoning before running "
"the linear prover of `lra`. This pre-processing does the following:"
msgstr ""

#: ../../addendum/micromega.rst:199
msgid ""
"If the context contains an arithmetic expression of the form :math:`e[x^2]` "
"where :math:`x` is a monomial, the context is enriched with :math:`x^2 \\ge "
"0`;"
msgstr ""

#: ../../addendum/micromega.rst:202
msgid ""
"For all pairs of hypotheses :math:`e_1 \\ge 0`, :math:`e_2 \\ge 0`, the "
"context is enriched with :math:`e_1 \\times e_2 \\ge 0`."
msgstr ""

#: ../../addendum/micromega.rst:205
msgid ""
"After this pre-processing, the linear prover of `lra` searches for a proof "
"by abstracting monomials by variables."
msgstr ""

#: ../../addendum/micromega.rst:209
msgid "`nia`: a proof procedure for non-linear integer arithmetic"
msgstr ""

#: ../../addendum/micromega.rst:214
msgid ""
"This tactic is a proof procedure for non-linear integer arithmetic. It "
"performs a pre-processing similar to `nra`. The obtained goal is solved "
"using the linear integer prover `lia`."
msgstr ""

#: ../../addendum/micromega.rst:219
msgid "`psatz`: a proof procedure for non-linear arithmetic"
msgstr ""

#: ../../addendum/micromega.rst:224
msgid ""
"This tactic explores the :math:`\\mathit{Cone}` by increasing degrees – "
"hence the depth parameter :math:`n`. In theory, such a proof search is "
"complete – if the goal is provable the search eventually stops. "
"Unfortunately, the external oracle is using numeric (approximate) "
"optimization techniques that might miss a refutation."
msgstr ""

#: ../../addendum/micromega.rst:230
msgid ""
"To illustrate the working of the tactic, consider we wish to prove the "
"following Coq goal:"
msgstr ""

#: ../../addendum/micromega.rst:241
msgid ""
"As shown, such a goal is solved by ``intro x. psatz Z 2.``. The oracle "
"returns the cone expression :math:`2 \\times (x-1) + (\\mathbf{x-1}) \\times "
"(\\mathbf{x−1}) + -x^2` (polynomial hypotheses are printed in bold). By "
"construction, this expression belongs to :math:`\\mathit{Cone}({−x^2,x "
"-1})`. Moreover, by running `ring` we obtain :math:`-1`. By Theorem :ref:"
"`Psatz <psatz_thm>`, the goal is valid."
msgstr ""

#: ../../addendum/micromega.rst:247
msgid ""
"Support for `nat` and :math:`\\mathbb{N}` is obtained by pre-processing the "
"goal with the `zify` tactic."
msgstr ""

#: ../../addendum/micromega.rst:249
msgid "Sources and binaries can be found at https://projects.coin-or.org/Csdp"
msgstr ""

#: ../../addendum/micromega.rst:250
msgid "Variants deal with equalities and strict inequalities."
msgstr ""

#: ../../addendum/micromega.rst:251
msgid "More efficient linear programming techniques could equally be employed."
msgstr ""

#: ../../addendum/micromega.rst:252
msgid "In practice, the oracle might fail to produce such a refutation."
msgstr ""

#: ../../addendum/miscellaneous-extensions.rst:4
msgid "Miscellaneous extensions"
msgstr ""

#: ../../addendum/miscellaneous-extensions.rst:7
msgid "Program derivation"
msgstr ""

#: ../../addendum/miscellaneous-extensions.rst:9
msgid ""
"|Coq| comes with an extension called ``Derive``, which supports program "
"derivation. Typically in the style of Bird and Meertens or derivations of "
"program refinements. To use the Derive extension it must first be required "
"with ``Require Coq.derive.Derive``. When the extension is loaded, it "
"provides the following command:"
msgstr ""

#: ../../addendum/miscellaneous-extensions.rst:17
msgid ""
"The first `ident` can appear in `term`. This command opens a new proof "
"presenting the user with a goal for term in which the name `ident` is bound "
"to an existential variable `?x` (formally, there are other goals standing "
"for the existential variables but they are shelved, as described in :tacn:"
"`shelve`)."
msgstr ""

#: ../../addendum/miscellaneous-extensions.rst:23
msgid "When the proof ends two constants are defined:"
msgstr ""

#: ../../addendum/miscellaneous-extensions.rst:25
msgid ""
"The first one is named using the first `ident` and is defined as the proof "
"of the shelved goal (which is also the value of `?x`). It is always "
"transparent."
msgstr ""

#: ../../addendum/miscellaneous-extensions.rst:28
msgid ""
"The second one is named using the second `ident`. It has type `term`, and "
"its body is the proof of the initially visible goal. It is opaque if the "
"proof ends with ``Qed``, and transparent if the proof ends with ``Defined``."
msgstr ""

#: ../../addendum/miscellaneous-extensions.rst:55
msgid ""
"Any property can be used as `term`, not only an equation. In particular, it "
"could be an order relation specifying some form of program refinement or a "
"non-executable property from which deriving a program is convenient."
msgstr ""

#: ../../addendum/nsatz.rst:4
msgid "Nsatz: tactics for proving equalities in integral domains"
msgstr ""

#: ../../addendum/nsatz.rst:6
msgid "Loïc Pottier"
msgstr ""

#: ../../addendum/nsatz.rst:11
msgid "This tactic is for solving goals of the form"
msgstr ""

#: ../../addendum/nsatz.rst:13
msgid ""
":math:`\\begin{array}{l} \\forall X_1, \\ldots, X_n \\in A, \\\\ P_1(X_1, "
"\\ldots, X_n) = Q_1(X_1, \\ldots, X_n), \\ldots, P_s(X_1, \\ldots, X_n) = "
"Q_s(X_1, \\ldots, X_n) \\\\ \\vdash P(X_1, \\ldots, X_n) = Q(X_1, \\ldots, "
"X_n) \\\\ \\end{array}`"
msgstr ""

#: ../../addendum/nsatz.rst:19
msgid ""
"where :math:`P, Q, P_1, Q_1, \\ldots, P_s, Q_s` are polynomials and :math:"
"`A` is an integral domain, i.e. a commutative ring with no zero divisors. "
"For example, :math:`A` can be :math:`\\mathbb{R}`, :math:`\\mathbb{Z}`, or :"
"math:`\\mathbb{Q}`. Note that the equality :math:`=` used in these goals can "
"be any setoid equality (see :ref:`tactics-enabled-on-user-provided-"
"relations`) , not only Leibniz equality."
msgstr ""

#: ../../addendum/nsatz.rst:25
msgid "It also proves formulas"
msgstr ""

#: ../../addendum/nsatz.rst:27
msgid ""
":math:`\\begin{array}{l} \\forall X_1, \\ldots, X_n \\in A, \\\\ P_1(X_1, "
"\\ldots, X_n) = Q_1(X_1, \\ldots, X_n) \\wedge \\ldots \\wedge P_s(X_1, "
"\\ldots, X_n) = Q_s(X_1, \\ldots, X_n) \\\\ \\rightarrow P(X_1, \\ldots, "
"X_n) = Q(X_1, \\ldots, X_n) \\\\ \\end{array}`"
msgstr ""

#: ../../addendum/nsatz.rst:33
msgid "doing automatic introductions."
msgstr ""

#: ../../addendum/nsatz.rst:35
msgid ""
"You can load the ``Nsatz`` module with the command ``Require Import Nsatz``."
msgstr ""

#: ../../addendum/nsatz.rst:38
msgid "More about `nsatz`"
msgstr ""

#: ../../addendum/nsatz.rst:40
msgid ""
"Hilbert’s Nullstellensatz theorem shows how to reduce proofs of equalities "
"on polynomials on a commutative ring :math:`A` with no zero divisors to "
"algebraic computations: it is easy to see that if a polynomial :math:`P` in :"
"math:`A[X_1,\\ldots,X_n]` verifies :math:`c P^r = \\sum_{i=1}^{s} S_i P_i`, "
"with :math:`c \\in A`, :math:`c \\not = 0`, :math:`r` a positive integer, "
"and the :math:`S_i` s in :math:`A[X_1,\\ldots,X_n ]`, then :math:`P` is zero "
"whenever polynomials :math:`P_1,\\ldots,P_s` are zero (the converse is also "
"true when :math:`A` is an algebraically closed field: the method is "
"complete)."
msgstr ""

#: ../../addendum/nsatz.rst:50
msgid ""
"So, solving our initial problem reduces to finding :math:`S_1, \\ldots, "
"S_s`, :math:`c` and :math:`r` such that :math:`c (P-Q)^r = \\sum_{i} S_i "
"(P_i-Q_i)`, which will be proved by the tactic ring."
msgstr ""

#: ../../addendum/nsatz.rst:54
msgid ""
"This is achieved by the computation of a Gröbner basis of the ideal "
"generated by :math:`P_1-Q_1,...,P_s-Q_s`, with an adapted version of the "
"Buchberger algorithm."
msgstr ""

#: ../../addendum/nsatz.rst:58
msgid ""
"This computation is done after a step of *reification*, which is performed "
"using :ref:`typeclasses`."
msgstr ""

#: ../../addendum/nsatz.rst:63
msgid "Most complete syntax for `nsatz`."
msgstr ""

#: ../../addendum/nsatz.rst:65
msgid ""
"`radicalmax` is a bound when searching for r such that :math:`c (P−Q) r = "
"\\sum_{i=1..s} S_i (P i − Q i)`"
msgstr ""

#: ../../addendum/nsatz.rst:68
msgid ""
"`strategy` gives the order on variables :math:`X_1,\\ldots,X_n` and the "
"strategy used in Buchberger algorithm (see :cite:`sugar` for details):"
msgstr ""

#: ../../addendum/nsatz.rst:71
msgid "strategy = 0: reverse lexicographic order and newest s-polynomial."
msgstr ""

#: ../../addendum/nsatz.rst:72
msgid "strategy = 1: reverse lexicographic order and sugar strategy."
msgstr ""

#: ../../addendum/nsatz.rst:73
msgid "strategy = 2: pure lexicographic order and newest s-polynomial."
msgstr ""

#: ../../addendum/nsatz.rst:74
msgid "strategy = 3: pure lexicographic order and sugar strategy."
msgstr ""

#: ../../addendum/nsatz.rst:76
msgid ""
"`parameters` is the list of variables :math:`X_{i_1},\\ldots,X_{i_k}` among :"
"math:`X_1,\\ldots,X_n` which are considered as parameters: computation will "
"be performed with rational fractions in these variables, i.e. polynomials "
"are considered with coefficients in :math:`R(X_{i_1},\\ldots,X_{i_k})`. In "
"this case, the coefficient :math:`c` can be a non constant polynomial in :"
"math:`X_{i_1},\\ldots,X_{i_k}`, and the tactic produces a goal which states "
"that :math:`c` is not zero."
msgstr ""

#: ../../addendum/nsatz.rst:83
msgid ""
"`variables` is the list of the variables in the decreasing order in which "
"they will be used in the Buchberger algorithm. If `variables` = `(@nil R)`, "
"then `lvar` is replaced by all the variables which are not in `parameters`."
msgstr ""

#: ../../addendum/nsatz.rst:88
msgid "See the file `Nsatz.v` for many examples, especially in geometry."
msgstr ""

#: ../../addendum/omega.rst:4
msgid "Omega: a solver for quantifier-free problems in Presburger Arithmetic"
msgstr ""

#: ../../addendum/omega.rst:6
msgid "Pierre Crégut"
msgstr ""

#: ../../addendum/omega.rst:9
msgid "Description of ``omega``"
msgstr ""

#: ../../addendum/omega.rst:13
msgid ""
":tacn:`omega` is a tactic for solving goals in Presburger arithmetic, i.e. "
"for proving formulas made of equations and inequalities over the type "
"``nat`` of natural numbers or the type ``Z`` of binary-encoded integers. "
"Formulas on ``nat`` are automatically injected into ``Z``. The procedure may "
"use any hypothesis of the current proof session to solve the goal."
msgstr ""

#: ../../addendum/omega.rst:19
msgid ""
"Multiplication is handled by :tacn:`omega` but only goals where at least one "
"of the two multiplicands of products is a constant are solvable. This is the "
"restriction meant by \"Presburger arithmetic\"."
msgstr ""

#: ../../addendum/omega.rst:23
msgid ""
"If the tactic cannot solve the goal, it fails with an error message. In any "
"case, the computation eventually stops."
msgstr ""

#: ../../addendum/omega.rst:29
msgid "To be documented."
msgstr ""

#: ../../addendum/omega.rst:32
msgid "Arithmetical goals recognized by ``omega``"
msgstr ""

#: ../../addendum/omega.rst:34
msgid ""
":tacn:`omega` applies only to quantifier-free formulas built from the "
"connectives::"
msgstr ""

#: ../../addendum/omega.rst:38
msgid "on atomic formulas. Atomic formulas are built from the predicates::"
msgstr ""

#: ../../addendum/omega.rst:42
msgid ""
"on ``nat`` or ``Z``. In expressions of type ``nat``, :tacn:`omega` "
"recognizes::"
msgstr ""

#: ../../addendum/omega.rst:46
msgid ""
"and in expressions of type ``Z``, :tacn:`omega` recognizes numeral constants "
"and::"
msgstr ""

#: ../../addendum/omega.rst:50
msgid ""
"All expressions of type ``nat`` or ``Z`` not built on these operators are "
"considered abstractly as if they were arbitrary variables of type ``nat`` or "
"``Z``."
msgstr ""

#: ../../addendum/omega.rst:55
msgid "Messages from ``omega``"
msgstr ""

#: ../../addendum/omega.rst:57
msgid ""
"When :tacn:`omega` does not solve the goal, one of the following errors is "
"generated:"
msgstr ""

#: ../../addendum/omega.rst:62
msgid ""
"This may happen if your goal is not quantifier-free (if it is universally "
"quantified, try :tacn:`intros` first; if it contains existentials "
"quantifiers too, :tacn:`omega` is not strong enough to solve your goal). "
"This may happen also if your goal contains arithmetical operators not "
"recognized by :tacn:`omega`. Finally, your goal may be simply not true!"
msgstr ""

#: ../../addendum/omega.rst:71
msgid ""
"If your goal is universally quantified, you should first apply :tacn:`intro` "
"as many times as needed."
msgstr ""

#: ../../addendum/omega.rst:88
msgid "Using ``omega``"
msgstr ""

#: ../../addendum/omega.rst:90
msgid ""
"The ``omega`` tactic does not belong to the core system. It should be loaded "
"by"
msgstr ""

#: ../../addendum/omega.rst:115 ../../addendum/type-classes.rst:453
msgid "Options"
msgstr ""

#: ../../addendum/omega.rst:121
msgid ""
"This deprecated option (on by default) is for compatibility with Coq pre "
"8.5. It resets internal name counters to make executions of :tacn:`omega` "
"independent."
msgstr ""

#: ../../addendum/omega.rst:126
msgid ""
"This option (on by default) allows :tacn:`omega` to use the bodies of local "
"variables."
msgstr ""

#: ../../addendum/omega.rst:131 ../../addendum/omega.rst:135
msgid "This option (off by default) activate the printing of debug information"
msgstr ""

#: ../../addendum/omega.rst:138
msgid "Technical data"
msgstr ""

#: ../../addendum/omega.rst:141
msgid "Overview of the tactic"
msgstr ""

#: ../../addendum/omega.rst:143
msgid ""
"The goal is negated twice and the first negation is introduced as a "
"hypothesis."
msgstr ""

#: ../../addendum/omega.rst:144
msgid ""
"Hypotheses are decomposed in simple equations or inequalities. Multiple "
"goals may result from this phase."
msgstr ""

#: ../../addendum/omega.rst:146
msgid ""
"Equations and inequalities over ``nat`` are translated over ``Z``, multiple "
"goals may result from the translation of subtraction."
msgstr ""

#: ../../addendum/omega.rst:148
msgid "Equations and inequalities are normalized."
msgstr ""

#: ../../addendum/omega.rst:149
msgid "Goals are solved by the OMEGA decision procedure."
msgstr ""

#: ../../addendum/omega.rst:150
msgid "The script of the solution is replayed."
msgstr ""

#: ../../addendum/omega.rst:153
msgid "Overview of the OMEGA decision procedure"
msgstr ""

#: ../../addendum/omega.rst:155
msgid ""
"The OMEGA decision procedure involved in the :tacn:`omega` tactic uses a "
"small subset of the decision procedure presented in :cite:`TheOmegaPaper` "
"Here is an overview, refer to the original paper for more information."
msgstr ""

#: ../../addendum/omega.rst:159
msgid ""
"Equations and inequalities are normalized by division by the GCD of their "
"coefficients."
msgstr ""

#: ../../addendum/omega.rst:161
msgid ""
"Equations are eliminated, using the Banerjee test to get a coefficient equal "
"to one."
msgstr ""

#: ../../addendum/omega.rst:163
msgid "Note that each inequality cuts the Euclidean space in half."
msgstr ""

#: ../../addendum/omega.rst:164
msgid ""
"Inequalities are solved by projecting on the hyperspace defined by "
"cancelling one of the variables. They are partitioned according to the sign "
"of the coefficient of the eliminated variable. Pairs of inequalities from "
"different classes define a new edge in the projection."
msgstr ""

#: ../../addendum/omega.rst:169
msgid ""
"Redundant inequalities are eliminated or merged in new equations that can be "
"eliminated by the Banerjee test."
msgstr ""

#: ../../addendum/omega.rst:171
msgid ""
"The last two steps are iterated until a contradiction is reached (success) "
"or there is no more variable to eliminate (failure)."
msgstr ""

#: ../../addendum/omega.rst:174
msgid ""
"It may happen that there is a real solution and no integer one. The last "
"steps of the Omega procedure are not implemented, so the decision procedure "
"is only partial."
msgstr ""

#: ../../addendum/omega.rst:179
msgid "Bugs"
msgstr ""

#: ../../addendum/omega.rst:181
msgid ""
"The simplification procedure is very dumb and this results in many redundant "
"cases to explore."
msgstr ""

#: ../../addendum/omega.rst:184
msgid "Much too slow."
msgstr ""

#: ../../addendum/omega.rst:186
msgid ""
"Certainly other bugs! You can report them to https://coq.inria.fr/bugs/."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:4
msgid "Asynchronous and Parallel Proof Processing"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:6
msgid "Enrico Tassi"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:8
msgid ""
"This chapter explains how proofs can be asynchronously processed by |Coq|. "
"This feature improves the reactivity of the system when used in interactive "
"mode via |CoqIDE|. In addition, it allows |Coq| to take advantage of "
"parallel hardware when used as a batch compiler by decoupling the checking "
"of statements and definitions from the construction and checking of proofs "
"objects."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:15
msgid ""
"This feature is designed to help dealing with huge libraries of theorems "
"characterized by long proofs. In the current state, it may not be beneficial "
"on small sets of short files."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:19
msgid ""
"This feature has some technical limitations that may make it unsuitable for "
"some use cases."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:22
msgid ""
"For example, in interactive mode, some errors coming from the kernel of |"
"Coq| are signaled late. The type of errors belonging to this category are "
"universe inconsistencies."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:26
msgid ""
"At the time of writing, only opaque proofs (ending with ``Qed`` or "
"``Admitted``) can be processed asynchronously."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:29
msgid ""
"Finally, asynchronous processing is disabled when running |CoqIDE| in "
"Windows. The current implementation of the feature is not stable on Windows. "
"It can be enabled, as described below at :ref:`interactive-mode`, though "
"doing so is not recommended."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:35
msgid "Proof annotations"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:37
msgid ""
"To process a proof asynchronously |Coq| needs to know the precise statement "
"of the theorem without looking at the proof. This requires some annotations "
"if the theorem is proved inside a Section (see Section :ref:`section-"
"mechanism`)."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:42
msgid ""
"When a section ends, |Coq| looks at the proof object to decide which section "
"variables are actually used and hence have to be quantified in the statement "
"of the theorem. To avoid making the construction of proofs mandatory when "
"ending a section, one can start each proof with the ``Proof using`` command "
"(Section :ref:`proof-editing-mode`) that declares which section variables "
"the theorem uses."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:49
msgid ""
"The presence of ``Proof`` using is needed to process proofs asynchronously "
"in interactive mode."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:52
msgid ""
"It is not strictly mandatory in batch mode if it is not the first time the "
"file is compiled and if the file itself did not change. When the proof does "
"not begin with Proof using, the system records in an auxiliary file, "
"produced along with the `.vo` file, the list of section variables used."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:59
msgid "Automatic suggestion of proof annotations"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:61
msgid ""
"The flag :flag:`Suggest Proof Using` makes |Coq| suggest, when a ``Qed`` "
"command is processed, a correct proof annotation. It is up to the user to "
"modify the proof script accordingly."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:67
msgid "Proof blocks and error resilience"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:69
msgid ""
"|Coq| 8.6 introduced a mechanism for error resilience: in interactive mode |"
"Coq| is able to completely check a document containing errors instead of "
"bailing out at the first failure."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:73
msgid ""
"Two kind of errors are supported: errors occurring in vernacular commands "
"and errors occurring in proofs."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:76
msgid ""
"To properly recover from a failing tactic, |Coq| needs to recognize the "
"structure of the proof in order to confine the error to a sub proof. Proof "
"block detection is performed by looking at the syntax of the proof script (i."
"e. also looking at indentation). |Coq| comes with four kind of proof blocks, "
"and an ML API to add new ones."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:0
msgid "curly"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:82
msgid "blocks are delimited by { and }, see Chapter :ref:`proofhandling`"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:0
msgid "par"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:83
msgid ""
"blocks are atomic, i.e. just one tactic introduced by the `par:` goal "
"selector"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:0
msgid "indent"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:85
msgid "blocks end with a tactic indented less than the previous one"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:0
msgid "bullet"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:86
msgid ""
"blocks are delimited by two equal bullet signs at the same indentation level"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:90
#: ../../addendum/parallel-proof-processing.rst:138
msgid "Caveats"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:92
msgid ""
"When a vernacular command fails the subsequent error messages may be bogus, "
"i.e. caused by the first error. Error resilience for vernacular commands can "
"be switched off by passing ``-async-proofs-command-error-resilience off`` to "
"|CoqIDE|."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:97
msgid ""
"An incorrect proof block detection can result into an incorrect error "
"recovery and hence in bogus errors. Proof block detection cannot be precise "
"for bullets or any other non well parenthesized proof structure. Error "
"resilience can be turned off or selectively activated for any set of block "
"kind passing to |CoqIDE| one of the following options:"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:104
msgid "``-async-proofs-tactic-error-resilience off``"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:105
msgid "``-async-proofs-tactic-error-resilience all``"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:106
msgid "``-async-proofs-tactic-error-resilience`` :n:`{*, blocktype}`"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:108
msgid "Valid proof block types are: “curly”, “par”, “indent”, and “bullet”."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:113
msgid "Interactive mode"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:115
msgid ""
"At the time of writing the only user interface supporting asynchronous proof "
"processing is |CoqIDE|."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:118
msgid ""
"When |CoqIDE| is started, two |Coq| processes are created. The master one "
"follows the user, giving feedback as soon as possible by skipping proofs, "
"which are delegated to the worker process. The worker process, whose state "
"can be seen by clicking on the button in the lower right corner of the main |"
"CoqIDE| window, asynchronously processes the proofs. If a proof contains an "
"error, it is reported in red in the label of the very same button, that can "
"also be used to see the list of errors and jump to the corresponding line."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:127
msgid ""
"If a proof is processed asynchronously the corresponding Qed command is "
"colored using a lighter color than usual. This signals that the proof has "
"been delegated to a worker process (or will be processed lazily if the ``-"
"async-proofs lazy`` option is used). Once finished, the worker process will "
"provide the proof object, but this will not be automatically checked by the "
"kernel of the main process. To force the kernel to check all the proof "
"objects, one has to click the button with the gears (Fully check the "
"document) on the top bar. Only then all the universe constraints are checked."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:140
msgid ""
"The number of worker processes can be increased by passing |CoqIDE| the ``-"
"async-proofs-j n`` flag. Note that the memory consumption increases too, "
"since each worker requires the same amount of memory as the master process. "
"Also note that increasing the number of workers may reduce the reactivity of "
"the master process to user commands."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:146
msgid ""
"To disable this feature, one can pass the ``-async-proofs off`` flag to |"
"CoqIDE|. Conversely, on Windows, where the feature is disabled by default, "
"pass the ``-async-proofs on`` flag to enable it."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:150
msgid ""
"Proofs that are known to take little time to process are not delegated to a "
"worker process. The threshold can be configured with ``-async-proofs-"
"delegation-threshold``. Default is 0.03 seconds."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:155
msgid "Batch mode"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:157
msgid ""
"When |Coq| is used as a batch compiler by running `coqc` or `coqtop` -"
"compile, it produces a `.vo` file for each `.v` file. A `.vo` file contains, "
"among other things, theorem statements and proofs. Hence to produce a .vo |"
"Coq| need to process all the proofs of the `.v` file."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:162
msgid ""
"The asynchronous processing of proofs can decouple the generation of a "
"compiled file (like the `.vo` one) that can be loaded by ``Require`` from "
"the generation and checking of the proof objects. The ``-quick`` flag can be "
"passed to `coqc` or `coqtop` to produce, quickly, `.vio` files. "
"Alternatively, when using a Makefile produced by `coq_makefile`, the "
"``quick`` target can be used to compile all files using the ``-quick`` flag."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:169
msgid ""
"A `.vio` file can be loaded using ``Require`` exactly as a `.vo` file but "
"proofs will not be available (the Print command produces an error). "
"Moreover, some universe constraints might be missing, so universes "
"inconsistencies might go unnoticed. A `.vio` file does not contain proof "
"objects, but proof tasks, i.e. what a worker process can transform into a "
"proof object."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:176
msgid ""
"Compiling a set of files with the ``-quick`` flag allows one to work, "
"interactively, on any file without waiting for all the proofs to be checked."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:180
msgid ""
"When working interactively, one can fully check all the `.v` files by "
"running `coqc` as usual."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:183
msgid ""
"Alternatively one can turn each `.vio` into the corresponding `.vo`. All ."
"vio files can be processed in parallel, hence this alternative might be "
"faster. The command ``coqtop -schedule-vio2vo 2 a b c`` can be used to "
"obtain a good scheduling for two workers to produce `a.vo`, `b.vo`, and `c."
"vo`. When using a Makefile produced by `coq_makefile`, the ``vio2vo`` target "
"can be used for that purpose. Variable `J` should be set to the number of "
"workers, e.g. ``make vio2vo J=2``. The only caveat is that, while the .vo "
"files obtained from `.vio` files are complete (they contain all proof terms "
"and universe constraints), the satisfiability of all universe constraints "
"has not been checked globally (they are checked to be consistent for every "
"single proof). Constraints will be checked when these `.vo` files are "
"(recursively) loaded with ``Require``."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:196
msgid ""
"There is an extra, possibly even faster, alternative: just check the proof "
"tasks stored in `.vio` files without producing the `.vo` files. This is "
"possibly faster because all the proof tasks are independent, hence one can "
"further partition the job to be done between workers. The ``coqtop -schedule-"
"vio-checking 6 a b c`` command can be used to obtain a good scheduling for 6 "
"workers to check all the proof tasks of `a.vio`, `b.vio`, and `c.vio`. "
"Auxiliary files are used to predict how long a proof task will take, "
"assuming it will take the same amount of time it took last time. When using "
"a Makefile produced by coq_makefile, the ``checkproofs`` target can be used "
"to check all `.vio` files. Variable `J` should be set to the number of "
"workers, e.g. ``make checkproofs J=6``. As when converting `.vio` files to `."
"vo` files, universe constraints are not checked to be globally consistent. "
"Hence this compilation mode is only useful for quick regression testing and "
"on developments not making heavy use of the `Type` hierarchy."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:213
msgid "Limiting the number of parallel workers"
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:215
msgid ""
"Many |Coq| processes may run on the same computer, and each of them may "
"start many additional worker processes. The `coqworkmgr` utility lets one "
"limit the number of workers, globally."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:219
msgid ""
"The utility accepts the ``-j`` argument to specify the maximum number of "
"workers (defaults to 2). `coqworkmgr` automatically starts in the background "
"and prints an environment variable assignment like "
"``COQWORKMGR_SOCKET=localhost:45634``. The user must set this variable in "
"all the shells from which |Coq| processes will be started. If one uses just "
"one terminal running the bash shell, then ``export ‘coqworkmgr -j 4‘`` will "
"do the job."
msgstr ""

#: ../../addendum/parallel-proof-processing.rst:227
msgid ""
"After that, all |Coq| processes, e.g. `coqide` and `coqc`, will respect the "
"limit, globally."
msgstr ""

#: ../../addendum/program.rst:6
msgid "Program"
msgstr ""

#: ../../addendum/program.rst:10
msgid ""
"We present here the |Program| tactic commands, used to build certified |Coq| "
"programs, elaborating them from their algorithmic skeleton and a rich "
"specification :cite:`sozeau06`. It can be thought of as a dual of :ref:"
"`Extraction <extraction>`. The goal of |Program| is to program as in a "
"regular functional programming language whilst using as rich a specification "
"as desired and proving that the code meets the specification using the whole "
"|Coq| proof apparatus. This is done using a technique originating from the "
"“Predicate subtyping” mechanism of PVS :cite:`Rushby98`, which generates "
"type checking conditions while typing a term constrained to a particular "
"type. Here we insert existential variables in the term, which must be filled "
"with proofs to get a complete |Coq| term. |Program| replaces the |Program| "
"tactic by Catherine Parent :cite:`Parent95b` which had a similar goal but is "
"no longer maintained."
msgstr ""

#: ../../addendum/program.rst:24
msgid ""
"The languages available as input are currently restricted to |Coq|’s term "
"language, but may be extended to OCaml, Haskell and others in the future. We "
"use the same syntax as |Coq| and permit to use implicit arguments and the "
"existing coercion mechanism. Input terms and types are typed in an extended "
"system (Russell) and interpreted into |Coq| terms. The interpretation "
"process may produce some proof obligations which need to be resolved to "
"create the final term."
msgstr ""

#: ../../addendum/program.rst:36
msgid "Elaborating programs"
msgstr ""

#: ../../addendum/program.rst:38
msgid ""
"The main difference from |Coq| is that an object in a type :g:`T : Set` can "
"be considered as an object of type :g:`{x : T | P}` for any well-formed :g:"
"`P : Prop`. If we go from :g:`T` to the subset of :g:`T` verifying property :"
"g:`P`, we must prove that the object under consideration verifies it. "
"Russell will generate an obligation for every such coercion. In the other "
"direction, Russell will automatically insert a projection."
msgstr ""

#: ../../addendum/program.rst:45
msgid ""
"Another distinction is the treatment of pattern matching. Apart from the "
"following differences, it is equivalent to the standard match operation "
"(see :ref:`extendedpatternmatching`)."
msgstr ""

#: ../../addendum/program.rst:50
msgid ""
"Generation of equalities. A match expression is always generalized by the "
"corresponding equality. As an example, the expression:"
msgstr ""

#: ../../addendum/program.rst:60
msgid "will be first rewritten to:"
msgstr ""

#: ../../addendum/program.rst:69
msgid ""
"This permits to get the proper equalities in the context of proof "
"obligations inside clauses, without which reasoning is very limited."
msgstr ""

#: ../../addendum/program.rst:72
msgid ""
"Generation of disequalities. If a pattern intersects with a previous one, a "
"disequality is added in the context of the second branch. See for example "
"the definition of div2 below, where the second branch is typed in a context "
"where :g:`∀ p, _ <> S (S p)`."
msgstr ""

#: ../../addendum/program.rst:76
msgid ""
"Coercion. If the object being matched is coercible to an inductive type, the "
"corresponding coercion will be automatically inserted. This also works with "
"the previous mechanism."
msgstr ""

#: ../../addendum/program.rst:81
msgid ""
"There are options to control the generation of equalities and coercions."
msgstr ""

#: ../../addendum/program.rst:86
msgid ""
"This controls the special treatment of pattern matching generating "
"equalities and disequalities when using |Program| (it is on by default). All "
"pattern-matches and let-patterns are handled using the standard algorithm of "
"|Coq| (see :ref:`extendedpatternmatching`) when this option is deactivated."
msgstr ""

#: ../../addendum/program.rst:94
msgid ""
"This controls the coercion of general inductive types when using |Program| "
"(the option is on by default). Coercion of subset types and pairs is still "
"active in this case."
msgstr ""

#: ../../addendum/program.rst:101
msgid "Syntactic control over equalities"
msgstr ""

#: ../../addendum/program.rst:103
msgid ""
"To give more control over the generation of equalities, the type checker "
"will fall back directly to |Coq|’s usual typing of dependent pattern "
"matching if a return or in clause is specified. Likewise, the if construct "
"is not treated specially by |Program| so boolean tests in the code are not "
"automatically reflected in the obligations. One can use the :g:`dec` "
"combinator to get the correct hypotheses as in:"
msgstr ""

#: ../../addendum/program.rst:120
msgid ""
"The :g:`let` tupling construct :g:`let (x1, ..., xn) := t in b` does not "
"produce an equality, contrary to the let pattern construct :g:`let "
"’(x1, ..., xn) := t in b`. Also, :g:`term :>` explicitly asks the system to "
"coerce term to its support type. It can be useful in notations, for example:"
msgstr ""

#: ../../addendum/program.rst:130
msgid ""
"This notation denotes equality on subset types using equality on their "
"support types, avoiding uses of proof-irrelevance that would come up when "
"reasoning with equality on the subset types themselves."
msgstr ""

#: ../../addendum/program.rst:134
msgid ""
"The next two commands are similar to their standard counterparts :cmd:"
"`Definition` and :cmd:`Fixpoint` in that they define constants. However, "
"they may require the user to prove some goals to construct the final "
"definitions."
msgstr ""

#: ../../addendum/program.rst:143
msgid "Program Definition"
msgstr ""

#: ../../addendum/program.rst:147
msgid ""
"This command types the value term in Russell and generates proof "
"obligations. Once solved using the commands shown below, it binds the final |"
"Coq| term to the name ``ident`` in the environment."
msgstr ""

#: ../../addendum/program.rst:156
msgid ""
"It interprets the type ``type``, potentially generating proof obligations to "
"be resolved. Once done with them, we have a |Coq| type |type_0|. It then "
"elaborates the preterm ``term`` into a |Coq| term |term_0|, checking that "
"the type of |term_0| is coercible to |type_0|, and registers ``ident`` as "
"being of type |type_0| once the set of obligations generated during the "
"interpretation of |term_0| and the aforementioned coercion derivation are "
"solved."
msgstr ""

#: ../../addendum/program.rst:169
msgid "This is equivalent to:"
msgstr ""

#: ../../addendum/program.rst:171
msgid ""
":g:`Program Definition ident : forall binders, type := fun binders => term`."
msgstr ""

#: ../../addendum/program.rst:175
msgid ""
"Sections :ref:`vernac-controlling-the-reduction-strategies`, :tacn:`unfold`"
msgstr ""

#: ../../addendum/program.rst:180
msgid "Program Fixpoint"
msgstr ""

#: ../../addendum/program.rst:184
msgid "The optional order annotation follows the grammar:"
msgstr ""

#: ../../addendum/program.rst:189
msgid ""
":g:`measure f ( R )` where :g:`f` is a value of type :g:`X` computed on any "
"subset of the arguments and the optional (parenthesised) term ``(R)`` is a "
"relation on ``X``. By default ``X`` defaults to ``nat`` and ``R`` to ``lt``."
msgstr ""

#: ../../addendum/program.rst:194
msgid ":g:`wf R x` which is equivalent to :g:`measure x (R)`."
msgstr ""

#: ../../addendum/program.rst:196
msgid ""
"The structural fixpoint operator behaves just like the one of |Coq| (see :"
"cmd:`Fixpoint`), except it may also generate obligations. It works with "
"mutually recursive definitions too."
msgstr ""

#: ../../addendum/program.rst:212
msgid ""
"Here we have one obligation for each branch (branches for :g:`0` and ``(S "
"0)`` are automatically generated by the pattern matching compilation "
"algorithm)."
msgstr ""

#: ../../addendum/program.rst:224
msgid ""
"One can use a well-founded order or a measure as termination orders using "
"the syntax:"
msgstr ""

#: ../../addendum/program.rst:237
msgid ""
"When defining structurally recursive functions, the generated obligations "
"should have the prototype of the currently defined functional in their "
"context. In this case, the obligations should be transparent (e.g. defined "
"using :g:`Defined`) so that the guardedness condition on recursive calls can "
"be checked by the kernel’s type- checker. There is an optimization in the "
"generation of obligations which gets rid of the hypothesis corresponding to "
"the functional when it is not necessary, so that the obligation can be "
"declared opaque (e.g. using :g:`Qed`). However, as soon as it appears in the "
"context, the proof of the obligation is *required* to be declared "
"transparent."
msgstr ""

#: ../../addendum/program.rst:248
msgid "No such problems arise when using measures or well-founded recursion."
msgstr ""

#: ../../addendum/program.rst:253
msgid "Program Lemma"
msgstr ""

#: ../../addendum/program.rst:257
msgid ""
"The Russell language can also be used to type statements of logical "
"properties. It will generate obligations, try to solve them automatically "
"and fail if some unsolved obligations remain. In this case, one can first "
"define the lemma’s statement using :g:`Program Definition` and use it as the "
"goal afterwards. Otherwise the proof will be started with the elaborated "
"version as a goal. The :g:`Program` prefix can similarly be used as a prefix "
"for :g:`Variable`, :g:`Hypothesis`, :g:`Axiom` etc."
msgstr ""

#: ../../addendum/program.rst:269
msgid "Solving obligations"
msgstr ""

#: ../../addendum/program.rst:271
msgid ""
"The following commands are available to manipulate obligations. The optional "
"identifier is used when multiple functions have unsolved obligations (e.g. "
"when defining mutually recursive blocks). The optional tactic is replaced by "
"the default one if not specified."
msgstr ""

#: ../../addendum/program.rst:279
msgid ""
"Sets the default obligation solving tactic applied to all obligations "
"automatically, whether to solve them or when starting to prove one, e.g. "
"using :g:`Next`. :g:`Local` makes the setting last only for the current "
"module. Inside sections, local is the default."
msgstr ""

#: ../../addendum/program.rst:286
msgid "Displays the current default tactic."
msgstr ""

#: ../../addendum/program.rst:290
msgid "Displays all remaining obligations."
msgstr ""

#: ../../addendum/program.rst:294
msgid "Start the proof of obligation num."
msgstr ""

#: ../../addendum/program.rst:298
msgid "Start the proof of the next unsolved obligation."
msgstr ""

#: ../../addendum/program.rst:302
msgid ""
"Tries to solve each obligation of ``ident`` using the given ``tactic`` or "
"the default one."
msgstr ""

#: ../../addendum/program.rst:306
msgid ""
"Tries to solve each obligation of every program using the given tactic or "
"the default one (useful for mutually recursive definitions)."
msgstr ""

#: ../../addendum/program.rst:311
msgid "Admits all obligations (of ``ident``)."
msgstr ""

#: ../../addendum/program.rst:313
msgid "Does not work with structurally recursive programs."
msgstr ""

#: ../../addendum/program.rst:317
msgid ""
"Shows the term that will be fed to the kernel once the obligations are "
"solved. Useful for debugging."
msgstr ""

#: ../../addendum/program.rst:322
msgid ""
"Controls whether all obligations should be declared as transparent (the "
"default), or if the system should infer which obligations can be declared "
"opaque."
msgstr ""

#: ../../addendum/program.rst:328
msgid ""
"Controls whether obligations appearing in the term should be hidden as "
"implicit arguments of the special constantProgram.Tactics.obligation."
msgstr ""

#: ../../addendum/program.rst:334
msgid "*Deprecated since 8.7*"
msgstr ""

#: ../../addendum/program.rst:336
msgid ""
"This option (on by default) controls whether obligations should have their "
"context minimized to the set of variables used in the proof of the "
"obligation, to avoid unnecessary dependencies."
msgstr ""

#: ../../addendum/program.rst:340
msgid ""
"The module :g:`Coq.Program.Tactics` defines the default tactic for solving "
"obligations called :g:`program_simpl`. Importing :g:`Coq.Program.Program` "
"also adds some useful notations, as documented in the file itself."
msgstr ""

#: ../../addendum/program.rst:347
msgid "Frequently Asked Questions"
msgstr ""

#: ../../addendum/program.rst:352
msgid ""
"This error can happen when one tries to define a function by structural "
"recursion on a subset object, which means the |Coq| function looks like:"
msgstr ""

#: ../../addendum/program.rst:359
msgid ""
"Supposing ``b : A``, the argument at the recursive call to ``f`` is not a "
"direct subterm of ``x`` as ``b`` is wrapped inside an ``exist`` constructor "
"to build an object of type ``{x : A | P}``.  Hence the definition is "
"rejected by the guardedness condition checker.  However one can use "
"wellfounded recursion on subset objects like this:"
msgstr ""

#: ../../addendum/program.rst:370
msgid ""
"One will then just have to prove that the measure decreases at each "
"recursive call. There are three drawbacks though:"
msgstr ""

#: ../../addendum/program.rst:373
msgid "A measure function has to be defined;"
msgstr ""

#: ../../addendum/program.rst:374
msgid ""
"The reduction is a little more involved, although it works well using lazy "
"evaluation;"
msgstr ""

#: ../../addendum/program.rst:376
msgid ""
"Mutual recursion on the underlying inductive type isn’t possible anymore, "
"but nested mutual recursion is always possible."
msgstr ""

#: ../../addendum/ring.rst:10
msgid "The ring and field tactic families"
msgstr ""

#: ../../addendum/ring.rst:12
msgid "Bruno Barras, Benjamin Grégoire, Assia Mahboubi, Laurent Théry [#f1]_"
msgstr ""

#: ../../addendum/ring.rst:14
msgid ""
"This chapter presents the tactics dedicated to dealing with ring and field "
"equations."
msgstr ""

#: ../../addendum/ring.rst:18
msgid "What does this tactic do?"
msgstr ""

#: ../../addendum/ring.rst:20
msgid ""
"``ring`` does associative-commutative rewriting in ring and semiring "
"structures. Assume you have two binary functions :math:`\\oplus` and :math:`"
"\\otimes` that are associative and commutative, with :math:`\\oplus` "
"distributive on :math:`\\otimes`, and two constants 0 and 1 that are unities "
"for :math:`\\oplus` and :math:`\\otimes`. A polynomial is an expression "
"built on variables :math:`V_0`, :math:`V_1`, :math:`\\dots` and constants by "
"application of :math:`\\oplus` and :math:`\\otimes`."
msgstr ""

#: ../../addendum/ring.rst:28
msgid ""
"Let an ordered product be a product of variables :math:`V_{i_1} \\otimes "
"\\dots \\otimes V_{i_n}` verifying :math:`i_1 ≤ i_2 ≤ \\dots ≤ i_n` . Let a "
"monomial be the product of a constant and an ordered product. We can order "
"the monomials by the lexicographic order on products of variables. Let a "
"canonical sum be an ordered sum of monomials that are all different, i.e. "
"each monomial in the sum is strictly less than the following monomial "
"according to the lexicographic order. It is an easy theorem to show that "
"every polynomial is equivalent (modulo the ring properties) to exactly one "
"canonical sum. This canonical sum is called the normal form of the "
"polynomial. In fact, the actual representation shares monomials with same "
"prefixes. So what does the ``ring`` tactic do? It normalizes polynomials "
"over any ring or semiring structure. The basic use of ``ring`` is to "
"simplify ring expressions, so that the user does not have to deal manually "
"with the theorems of associativity and commutativity."
msgstr ""

#: ../../addendum/ring.rst:45
msgid "In the ring of integers, the normal form of"
msgstr ""

#: ../../addendum/ring.rst:46
msgid ":math:`x (3 + yx + 25(1 − z)) + zx`"
msgstr ""

#: ../../addendum/ring.rst:47
msgid "is"
msgstr ""

#: ../../addendum/ring.rst:48
msgid ":math:`28x + (−24)xz + xxy`."
msgstr ""

#: ../../addendum/ring.rst:51
msgid ""
"``ring`` is also able to compute a normal form modulo monomial equalities. "
"For example, under the hypothesis that :math:`2x^2 = yz+1`, the normal form "
"of :math:`2(x + 1)x − x − zy` is :math:`x+1`."
msgstr ""

#: ../../addendum/ring.rst:56
msgid "The variables map"
msgstr ""

#: ../../addendum/ring.rst:58
msgid ""
"It is frequent to have an expression built with :math:`+` and :math:`"
"\\times`, but rarely on variables only. Let us associate a number to each "
"subterm of a ring expression in the Gallina language. For example, consider "
"this expression in the semiring ``nat``:"
msgstr ""

#: ../../addendum/ring.rst:69
msgid ""
"As a ring expression, it has 3 subterms. Give each subterm a number in an "
"arbitrary order:"
msgstr ""

#: ../../addendum/ring.rst:73
msgid "0"
msgstr ""

#: ../../addendum/ring.rst:73 ../../addendum/ring.rst:74
#: ../../addendum/ring.rst:75
msgid ":math:`\\mapsto`"
msgstr ""

#: ../../addendum/ring.rst:73
msgid "if b then (4) else (f (3))"
msgstr ""

#: ../../addendum/ring.rst:74
msgid "1"
msgstr ""

#: ../../addendum/ring.rst:74
msgid "(f (5))"
msgstr ""

#: ../../addendum/ring.rst:75
msgid "2"
msgstr ""

#: ../../addendum/ring.rst:75
msgid "x"
msgstr ""

#: ../../addendum/ring.rst:78
msgid ""
"Then normalize the “abstract” polynomial :math:`((V_1 \\otimes V_2 ) \\oplus "
"V_2) \\oplus (V_0 \\otimes 2)` In our example the normal form is: :math:`(2 "
"\\otimes V_0 ) \\oplus (V_1 \\otimes V_2) \\oplus (V_2 \\otimes V_2 )`. Then "
"substitute the variables by their values in the variables map to get the "
"concrete normal polynomial:"
msgstr ""

#: ../../addendum/ring.rst:92
msgid "Is it automatic?"
msgstr ""

#: ../../addendum/ring.rst:94
msgid ""
"Yes, building the variables map and doing the substitution after normalizing "
"is automatically done by the tactic. So you can just forget this paragraph "
"and use the tactic according to your intuition."
msgstr ""

#: ../../addendum/ring.rst:99
msgid "Concrete usage in Coq"
msgstr ""

#: ../../addendum/ring.rst:103
msgid ""
"The ``ring`` tactic solves equations upon polynomial expressions of a ring "
"(or semiring) structure. It proceeds by normalizing both sides of the "
"equation (w.r.t. associativity, commutativity and distributivity, constant "
"propagation, rewriting of monomials) and comparing syntactically the results."
msgstr ""

#: ../../addendum/ring.rst:111
msgid ""
"``ring_simplify`` applies the normalization procedure described above to the "
"given terms. The tactic then replaces all occurrences of the terms given in "
"the conclusion of the goal by their normal forms. If no term is given, then "
"the conclusion should be an equation and both sides are normalized. The "
"tactic can also be applied in a hypothesis."
msgstr ""

#: ../../addendum/ring.rst:117
msgid ""
"The tactic must be loaded by ``Require Import Ring``. The ring structures "
"must be declared with the ``Add Ring`` command (see below). The ring of "
"booleans is predefined; if one wants to use the tactic on |nat| one must "
"first require the module ``ArithRing`` exported by ``Arith``); for |Z|, do "
"``Require Import ZArithRing`` or simply ``Require Import ZArith``; for |N|, "
"do ``Require Import NArithRing`` or ``Require Import NArith``."
msgstr ""

#: ../../addendum/ring.rst:144
msgid ""
"decides the equality of two terms modulo ring operations and the equalities "
"defined by the :n:`@term`\\ s. Each :n:`@term` has to be a proof of some "
"equality `m = p`, where `m` is a monomial (after “abstraction”), `p` a "
"polynomial and `=` the corresponding equality of the ring structure."
msgstr ""

#: ../../addendum/ring.rst:150
msgid "performs the simplification in the hypothesis named :n:`@ident`."
msgstr ""

#: ../../addendum/ring.rst:157
msgid "is not equivalent to"
msgstr ""

#: ../../addendum/ring.rst:161
msgid ""
"In the latter case the variables map is shared between the two terms, and "
"common subterm `t` of :n:`@term1` and :n:`@term2` will have the same "
"associated variable number. So the first alternative should be avoided for "
"terms belonging to the same ring theory."
msgstr ""

#: ../../addendum/ring.rst:168 ../../addendum/ring.rst:393
msgid "Error messages:"
msgstr ""

#: ../../addendum/ring.rst:173
msgid ""
"The conclusion of the goal is not provable in the corresponding ring theory."
msgstr ""

#: ../../addendum/ring.rst:177
msgid ""
"``ring_simplify`` cannot simplify terms of several rings at the same time. "
"Invoke the tactic once per ring structure."
msgstr ""

#: ../../addendum/ring.rst:182
msgid ""
"No ring has been declared for the type of the terms to be simplified. Use "
"``Add Ring`` first."
msgstr ""

#: ../../addendum/ring.rst:187
msgid "Same as above in the case of the ``ring`` tactic."
msgstr ""

#: ../../addendum/ring.rst:191
msgid "Adding a ring structure"
msgstr ""

#: ../../addendum/ring.rst:193
msgid ""
"Declaring a new ring consists in proving that a ring signature (a carrier "
"set, an equality, and ring operations: ``Ring_theory.ring_theory`` and "
"``Ring_theory.semi_ring_theory``) satisfies the ring axioms. Semi- rings "
"(rings without + inverse) are also supported. The equality can be either "
"Leibniz equality, or any relation declared as a setoid (see :ref:`tactics-"
"enabled-on-user-provided-relations`). The definitions of ring and semiring "
"(see module ``Ring_theory``) are:"
msgstr ""

#: ../../addendum/ring.rst:227
msgid ""
"This implementation of ``ring`` also features a notion of constant that can "
"be parameterized. This can be used to improve the handling of closed "
"expressions when operations are effective. It consists in introducing a type "
"of *coefficients* and an implementation of the ring operations, and a "
"morphism from the coefficient type to the ring carrier type. The morphism "
"needs not be injective, nor surjective."
msgstr ""

#: ../../addendum/ring.rst:234
msgid ""
"As an example, one can consider the real numbers. The set of coefficients "
"could be the rational numbers, upon which the ring operations can be "
"implemented. The fact that there exists a morphism is defined by the "
"following properties:"
msgstr ""

#: ../../addendum/ring.rst:260
msgid ""
"where ``c0`` and ``cI`` denote the 0 and 1 of the coefficient set, ``+!``, "
"``*!``, ``-!`` are the implementations of the ring operations, ``==`` is the "
"equality of the coefficients, ``?+!`` is an implementation of this equality, "
"and ``[x]`` is a notation for the image of ``x`` by the ring morphism."
msgstr ""

#: ../../addendum/ring.rst:265
msgid ""
"Since |Z| is an initial ring (and |N| is an initial semiring), it can always "
"be considered as a set of coefficients. There are basically three kinds of "
"(semi-)rings:"
msgstr ""

#: ../../addendum/ring.rst:271
msgid "abstract rings"
msgstr ""

#: ../../addendum/ring.rst:270
msgid ""
"to be used when operations are not effective. The set of coefficients is |Z| "
"(or |N| for semirings)."
msgstr ""

#: ../../addendum/ring.rst:276
msgid "computational rings"
msgstr ""

#: ../../addendum/ring.rst:274
msgid ""
"to be used when operations are effective. The set of coefficients is the "
"ring itself. The user only has to provide an implementation for the equality."
msgstr ""

#: ../../addendum/ring.rst:281
msgid "customized ring"
msgstr ""

#: ../../addendum/ring.rst:279
msgid ""
"for other cases. The user has to provide the coefficient set and the "
"morphism."
msgstr ""

#: ../../addendum/ring.rst:283
msgid ""
"This implementation of ring can also recognize simple power expressions as "
"ring expressions. A power function is specified by the following property:"
msgstr ""

#: ../../addendum/ring.rst:301
msgid "The syntax for adding a new ring is"
msgstr ""

#: ../../addendum/ring.rst:305
msgid ""
"The :n:`@ident` is not relevant. It is used just for error messages. The :n:"
"`@term` is a proof that the ring signature satisfies the (semi-)ring axioms. "
"The optional list of modifiers is used to tailor the behavior of the tactic. "
"The following list describes their syntax and effects:"
msgstr ""

#: ../../addendum/ring.rst:321
msgid "abstract"
msgstr ""

#: ../../addendum/ring.rst:321
msgid "declares the ring as abstract. This is the default."
msgstr ""

#: ../../addendum/ring.rst:327
msgid "decidable :n:`@term`"
msgstr ""

#: ../../addendum/ring.rst:324
msgid ""
"declares the ring as computational. The expression :n:`@term` is the "
"correctness proof of an equality test ``?=!`` (which  hould be evaluable). "
"Its type should be of the form ``forall x y, x ?=! y = true → x == y``."
msgstr ""

#: ../../addendum/ring.rst:333
msgid "morphism :n:`@term`"
msgstr ""

#: ../../addendum/ring.rst:330
msgid ""
"declares the ring as a customized one. The expression :n:`@term` is a proof "
"that there exists a morphism between a set of coefficient and the ring "
"carrier (see ``Ring_theory.ring_morph`` and ``Ring_theory.semi_morph``)."
msgstr ""

#: ../../addendum/ring.rst:342
msgid "setoid :n:`@term` :n:`@term`"
msgstr ""

#: ../../addendum/ring.rst:336
msgid ""
"forces the use of given setoid. The first :n:`@term` is a proof that the "
"equality is indeed a setoid (see ``Setoid.Setoid_Theory``), and the second :"
"n:`@term` a proof that the ring operations are morphisms (see ``Ring_theory."
"ring_eq_ext`` and ``Ring_theory.sring_eq_ext``). This modifier needs not be "
"used if the setoid and morphisms have been declared."
msgstr ""

#: ../../addendum/ring.rst:350
msgid "constants [:n:`@ltac`]"
msgstr ""

#: ../../addendum/ring.rst:345
msgid ""
"specifies a tactic expression :n:`@ltac` that, given a term, returns either "
"an object of the coefficient set that is mapped to the expression via the "
"morphism, or returns ``InitialRing.NotConstant``. The default behavior is to "
"map only 0 and 1 to their counterpart in the coefficient set. This is "
"generally not desirable for non trivial computational rings."
msgstr ""

#: ../../addendum/ring.rst:356
msgid "preprocess [:n:`@ltac`]"
msgstr ""

#: ../../addendum/ring.rst:353
msgid ""
"specifies a tactic :n:`@ltac` that is applied as a preliminary step for "
"``ring`` and ``ring_simplify``. It can be used to transform a goal so that "
"it is better recognized. For instance, ``S n`` can be changed to ``plus 1 "
"n``."
msgstr ""

#: ../../addendum/ring.rst:361
msgid "postprocess [:n:`@ltac`]"
msgstr ""

#: ../../addendum/ring.rst:359
msgid ""
"specifies a tactic :n:`@ltac` that is applied as a final step for "
"``ring_simplify``. For instance, it can be used to undo modifications of the "
"preprocessor."
msgstr ""

#: ../../addendum/ring.rst:375
msgid "power_tac :n:`@term` [:n:`@ltac`]"
msgstr ""

#: ../../addendum/ring.rst:364
msgid ""
"allows ``ring`` and ``ring_simplify`` to recognize power expressions with a "
"constant positive integer exponent (example: ::math:`x^2` ). The term :n:"
"`@term` is a proof that a given power function satisfies the specification "
"of a power function (term has to be a proof of ``Ring_theory.power_theory``) "
"and :n:`@ltac` specifies a tactic expression that, given a term, “abstracts” "
"it into an object of type |N| whose interpretation via ``Cp_phi`` (the "
"evaluation function of power coefficient) is the original term, or returns "
"``InitialRing.NotConstant`` if not a constant coefficient (i.e. |L_tac| is "
"the inverse function of ``Cp_phi``). See files ``plugins/setoid_ring/"
"ZArithRing.v`` and ``plugins/setoid_ring/RealField.v`` for examples. By "
"default the tactic does not recognize power expressions as ring expressions."
msgstr ""

#: ../../addendum/ring.rst:382
msgid "sign :n:`@term`"
msgstr ""

#: ../../addendum/ring.rst:378
msgid ""
"allows ``ring_simplify`` to use a minus operation when outputting its normal "
"form, i.e writing ``x − y`` instead of ``x + (− y)``. The term `:n:`@term` "
"is a proof that a given sign function indicates expressions that are signed "
"(`term` has to be a proof of ``Ring_theory.get_sign``). See ``plugins/"
"setoid_ring/InitialRing.v`` for examples of sign function."
msgstr ""

#: ../../addendum/ring.rst:391
msgid "div :n:`@term`"
msgstr ""

#: ../../addendum/ring.rst:385
msgid ""
"allows ``ring`` and ``ring_simplify`` to use monomials with coefficients "
"other than 1 in the rewriting. The term :n:`@term` is a proof that a given "
"division function satisfies the specification of an euclidean division "
"function (:n:`@term` has to be a proof of ``Ring_theory.div_theory``). For "
"example, this function is called when trying to rewrite :math:`7x` by :math:"
"`2x = z` to tell that :math:`7 = 3 \\times 2 + 1`. See ``plugins/setoid_ring/"
"InitialRing.v`` for examples of div function."
msgstr ""

#: ../../addendum/ring.rst:397
msgid "The proof of the ring structure provided is not of the expected type."
msgstr ""

#: ../../addendum/ring.rst:402
msgid ""
"The equality function provided in the case of a computational ring has not "
"the expected type."
msgstr ""

#: ../../addendum/ring.rst:408
msgid ""
"A setoid associated to the carrier of the ring structure has been found, but "
"the ring operation should be declared as morphism. See :ref:`tactics-enabled-"
"on-user-provided-relations`."
msgstr ""

#: ../../addendum/ring.rst:412
msgid "How does it work?"
msgstr ""

#: ../../addendum/ring.rst:414
msgid ""
"The code of ``ring`` is a good example of a tactic written using "
"*reflection*. What is reflection? Basically, using it means that a part of a "
"tactic is written in Gallina, Coq's language of terms, rather than |Ltac| or "
"|OCaml|. From the philosophical point of view, reflection is using the "
"ability of the Calculus of Constructions to speak and reason about itself. "
"For the ``ring`` tactic we used Coq as a programming language and also as a "
"proof environment to build a tactic and to prove its correctness."
msgstr ""

#: ../../addendum/ring.rst:422
msgid ""
"The interested reader is strongly advised to have a look at the file "
"``Ring_polynom.v``. Here a type for polynomials is defined:"
msgstr ""

#: ../../addendum/ring.rst:438
msgid "Polynomials in normal form are defined as:"
msgstr ""

#: ../../addendum/ring.rst:449
msgid ""
"where ``Pinj n P`` denotes ``P`` in which :math:`V_i` is replaced by :math:"
"`V_{i+n}` , and ``PX P n Q`` denotes :math:`P \\otimes V_1^n \\oplus Q'`, "
"`Q'` being `Q` where :math:`V_i` is replaced by :math:`V_{i+1}`."
msgstr ""

#: ../../addendum/ring.rst:452
msgid ""
"Variable maps are represented by lists of ring elements, and two "
"interpretation functions, one that maps a variables map and a polynomial to "
"an element of the concrete ring, and the second one that does the same for "
"normal forms:"
msgstr ""

#: ../../addendum/ring.rst:465
msgid ""
"A function to normalize polynomials is defined, and the big theorem is its "
"correctness w.r.t interpretation, that is:"
msgstr ""

#: ../../addendum/ring.rst:476
msgid ""
"So now, what is the scheme for a normalization proof? Let p be the "
"polynomial expression that the user wants to normalize. First a little piece "
"of |ML| code guesses the type of `p`, the ring theory `T` to use, an "
"abstract polynomial `ap` and a variables map `v` such that `p` is |bdi|- "
"equivalent to ``(PEeval`` `v` `ap`\\ ``)``. Then we replace it by "
"``(Pphi_dev`` `v` ``(norm`` `ap`\\ ``))``, using the main correctness "
"theorem and we reduce it to a concrete expression `p’`, which is the "
"concrete normal form of `p`. This is summarized in this diagram:"
msgstr ""

#: ../../addendum/ring.rst:485
msgid "`p`"
msgstr ""

#: ../../addendum/ring.rst:485
msgid "|ra|"
msgstr ""

#: ../../addendum/ring.rst:485
msgid "|re|"
msgstr ""

#: ../../addendum/ring.rst:486
msgid "\\"
msgstr ""

#: ../../addendum/ring.rst:486
msgid "|eq|"
msgstr ""

#: ../../addendum/ring.rst:487
msgid "`p’`"
msgstr ""

#: ../../addendum/ring.rst:487
msgid "|la|"
msgstr ""

#: ../../addendum/ring.rst:487
msgid "|le|"
msgstr ""

#: ../../addendum/ring.rst:490
msgid ""
"The user does not see the right part of the diagram. From outside, the "
"tactic behaves like a |bdi| simplification extended with rewriting rules for "
"associativity and commutativity. Basically, the proof is only the "
"application of the main correctness theorem to well-chosen arguments."
msgstr ""

#: ../../addendum/ring.rst:496
msgid "Dealing with fields"
msgstr ""

#: ../../addendum/ring.rst:500
msgid ""
"The ``field`` tactic is an extension of the ``ring`` tactic that deals with "
"rational expressions. Given a rational expression :math:`F = 0`. It first "
"reduces the expression `F` to a common denominator :math:`N/D = 0` where `N` "
"and `D` are two ring expressions. For example, if we take :math:`F = (1 − 1/"
"x) x − x + 1`, this gives :math:`N = (x − 1) x − x^2 + x` and :math:`D = x`. "
"It then calls ring to solve :math:`N = 0`. Note that ``field`` also "
"generates nonzero conditions for all the denominators it encounters in the "
"reduction. In our example, it generates the condition :math:`x \\neq 0`. "
"These conditions appear as one subgoal which is a conjunction if there are "
"several denominators. Nonzero conditions are always polynomial expressions. "
"For example when reducing the expression :math:`1/(1 + 1/x)`, two side "
"conditions are generated: :math:`x \\neq 0` and :math:`x + 1 \\neq 0`. "
"Factorized expressions are broken since a field is an integral domain, and "
"when the equality test on coefficients is complete w.r.t. the equality of "
"the target field, constants can be proven different from zero automatically."
msgstr ""

#: ../../addendum/ring.rst:517
msgid ""
"The tactic must be loaded by ``Require Import Field``. New field structures "
"can be declared to the system with the ``Add Field`` command (see below). "
"The field of real numbers is defined in module ``RealField`` (in ``plugins/"
"setoid_ring``). It is exported by module ``Rbase``, so that requiring "
"``Rbase`` or ``Reals`` is enough to use the field tactics on real numbers. "
"Rational numbers in canonical form are also declared as a field in the "
"module ``Qcanon``."
msgstr ""

#: ../../addendum/ring.rst:543
msgid ""
"decides the equality of two terms modulo field operations and the equalities "
"defined by the :n:`@term`\\ s. Each :n:`@term` has to be a proof of some "
"equality `m` ``=`` `p`, where `m` is a monomial (after “abstraction”), `p` a "
"polynomial and ``=`` the corresponding equality of the field structure."
msgstr ""

#: ../../addendum/ring.rst:551
msgid ""
"rewriting works with the equality  `m` ``=`` `p` only if `p` is a polynomial "
"since rewriting is handled by the underlying ring tactic."
msgstr ""

#: ../../addendum/ring.rst:556
msgid ""
"performs the simplification in the conclusion of the goal, :math:`F_1 = F_2` "
"becomes :math:`N_1 / D_1 = N_2 / D_2`. A normalization step (the same as the "
"one for rings) is then applied to :math:`N_1`, :math:`D_1`, :math:`N_2` and :"
"math:`D_2`. This way, polynomials remain in factorized form during fraction "
"simplification. This yields smaller expressions when reducing to the same "
"denominator since common factors can be canceled."
msgstr ""

#: ../../addendum/ring.rst:565
msgid ""
"performs the simplification in the conclusion of the goal using the "
"equalities defined by the :n:`@term`\\ s."
msgstr ""

#: ../../addendum/ring.rst:570
msgid ""
"performs the simplification in the terms :n:`@terms`  of the conclusion of "
"the goal using the equalities defined by :n:`@term`\\ s inside the brackets."
msgstr ""

#: ../../addendum/ring.rst:575 ../../addendum/ring.rst:600
msgid "performs the simplification in the assumption :n:`@ident`."
msgstr ""

#: ../../addendum/ring.rst:579
msgid ""
"performs the simplification in the assumption :n:`@ident` using the "
"equalities defined by the :n:`@term`\\ s."
msgstr ""

#: ../../addendum/ring.rst:584
msgid ""
"performs the simplification in the :n:`@term`\\ s of the assumption :n:"
"`@ident` using the equalities defined by  the :n:`@term`\\ s inside the "
"brackets."
msgstr ""

#: ../../addendum/ring.rst:589
msgid ""
"performs the simplification in the conclusion of the goal removing the "
"denominator. :math:`F_1 = F_2` becomes :math:`N_1 D_2 = N_2 D_1`."
msgstr ""

#: ../../addendum/ring.rst:594
msgid ""
"performs the simplification in the conclusion of the goal using the "
"equalities defined by :n:`@term`\\ s."
msgstr ""

#: ../../addendum/ring.rst:604
msgid ""
"performs the simplification in the assumption :n:`@ident` using the "
"equalities defined by :n:`@terms`\\ s and removing the denominator."
msgstr ""

#: ../../addendum/ring.rst:609
msgid "Adding a new field structure"
msgstr ""

#: ../../addendum/ring.rst:611
msgid ""
"Declaring a new field consists in proving that a field signature (a carrier "
"set, an equality, and field operations: ``Field_theory.field_theory`` and "
"``Field_theory.semi_field_theory``) satisfies the field axioms. Semi-fields "
"(fields without + inverse) are also supported. The equality can be either "
"Leibniz equality, or any relation declared as a setoid (see :ref:`tactics-"
"enabled-on-user-provided-relations`). The definition of fields and "
"semifields is:"
msgstr ""

#: ../../addendum/ring.rst:636
msgid ""
"The result of the normalization process is a fraction represented by the "
"following type:"
msgstr ""

#: ../../addendum/ring.rst:648
msgid ""
"where ``num`` and ``denum`` are the numerator and denominator; ``condition`` "
"is a list of expressions that have appeared as a denominator during the "
"normalization process. These expressions must be proven different from zero "
"for the correctness of the algorithm."
msgstr ""

#: ../../addendum/ring.rst:653
msgid "The syntax for adding a new field is"
msgstr ""

#: ../../addendum/ring.rst:657
msgid ""
"The :n:`@ident` is not relevant. It is used just for error messages. :n:"
"`@term` is a proof that the field signature satisfies the (semi-)field "
"axioms. The optional list of modifiers is used to tailor the behavior of the "
"tactic."
msgstr ""

#: ../../addendum/ring.rst:665
msgid ""
"Since field tactics are built upon ``ring`` tactics, all modifiers of the "
"``Add Ring`` apply. There is only one specific modifier:"
msgstr ""

#: ../../addendum/ring.rst:678
msgid "completeness :n:`@term`"
msgstr ""

#: ../../addendum/ring.rst:670
msgid ""
"allows the field tactic to prove automatically that the image of nonzero "
"coefficients are mapped to nonzero elements of the field. :n:`@term` is a "
"proof of"
msgstr ""

#: ../../addendum/ring.rst:674
msgid "``forall x y, [x] == [y] ->  x ?=! y = true``,"
msgstr ""

#: ../../addendum/ring.rst:676
msgid ""
"which is the completeness of equality on coefficients w.r.t. the field "
"equality."
msgstr ""

#: ../../addendum/ring.rst:681
msgid "History of ring"
msgstr ""

#: ../../addendum/ring.rst:683
msgid ""
"First Samuel Boutin designed the tactic ``ACDSimpl``. This tactic did lot of "
"rewriting. But the proofs terms generated by rewriting were too big for |"
"Coq|’s type checker. Let us see why:"
msgstr ""

#: ../../addendum/ring.rst:697
msgid ""
"At each step of rewriting, the whole context is duplicated in the proof "
"term. Then, a tactic that does hundreds of rewriting generates huge proof "
"terms. Since ``ACDSimpl`` was too slow, Samuel Boutin rewrote it using "
"reflection (see :cite:`Bou97`). Later, it was rewritten by Patrick "
"Loiseleur: the new tactic does not any more require ``ACDSimpl`` to compile "
"and it makes use of |bdi|-reduction not only to replace the rewriting steps, "
"but also to achieve the interleaving of computation and reasoning (see :ref:"
"`discussion_reflection`). He also wrote some |ML| code for the ``Add Ring`` "
"command that allows registering new rings dynamically."
msgstr ""

#: ../../addendum/ring.rst:707
msgid ""
"Proofs terms generated by ring are quite small, they are linear in the "
"number of :math:`\\oplus` and :math:`\\otimes` operations in the normalized "
"terms. Type checking those terms requires some time because it makes a large "
"use of the conversion rule, but memory requirements are much smaller."
msgstr ""

#: ../../addendum/ring.rst:717
msgid "Discussion"
msgstr ""

#: ../../addendum/ring.rst:720
msgid ""
"Efficiency is not the only motivation to use reflection here. ``ring`` also "
"deals with constants, it rewrites for example the expression ``34 + 2 * x − "
"x + 12`` to the expected result ``x + 46``. For the tactic ``ACDSimpl``, the "
"only constants were 0 and 1. So the expression ``34 + 2 * (x − 1) + 12`` is "
"interpreted as :math:`V_0 \\oplus V_1 \\otimes (V_2 \\ominus 1) \\oplus V_3`"
"\\ , with the variables mapping :math:`\\{V_0 \\mapsto 34; V_1 \\mapsto 2; "
"V_2 \\mapsto x; V_3 \\mapsto 12\\}`\\ . Then it is rewritten to ``34 − x + 2 "
"* x + 12``, very far from the expected result. Here rewriting is not "
"sufficient: you have to do some kind of reduction (some kind of computation) "
"to achieve the normalization."
msgstr ""

#: ../../addendum/ring.rst:732
msgid ""
"The tactic ``ring`` is not only faster than the old one: by using "
"reflection, we get for free the integration of computation and reasoning "
"that would be very difficult to implement without it."
msgstr ""

#: ../../addendum/ring.rst:736
msgid ""
"Is it the ultimate way to write tactics? The answer is: yes and no. The "
"``ring`` tactic intensively uses the conversion rules of the Calculus of "
"Inductive Constructions, i.e. it replaces proofs by computations as much as "
"possible. It can be useful in all situations where a classical tactic "
"generates huge proof terms, like symbolic processing and tautologies. But "
"there are also tactics like ``auto`` or ``linear`` that do many complex "
"computations, using side-effects and backtracking, and generate a small "
"proof term. Clearly, it would be significantly less efficient to replace "
"them by tactics using reflection."
msgstr ""

#: ../../addendum/ring.rst:746
msgid ""
"Another idea suggested by Benjamin Werner: reflection could be used to "
"couple an external tool (a rewriting program or a model checker) with |Coq|. "
"We define (in |Coq|) a type of terms, a type of *traces*, and prove a "
"correctness theorem that states that *replaying traces* is safe with respect "
"to some interpretation. Then we let the external tool do every computation "
"(using side-effects, backtracking, exception, or others features that are "
"not available in pure lambda calculus) to produce the trace. Now we can "
"check in |Coq| that the trace has the expected semantics by applying the "
"correctness theorem."
msgstr ""

#: ../../addendum/ring.rst:761
msgid "Footnotes"
msgstr ""

#: ../../addendum/ring.rst:762
msgid "based on previous work from Patrick Loiseleur and Samuel Boutin"
msgstr ""

#: ../../addendum/type-classes.rst:4
msgid "Type Classes"
msgstr ""

#: ../../addendum/type-classes.rst:6
msgid ""
"This chapter presents a quick reference of the commands related to type "
"classes. For an actual introduction to typeclasses, there is a description "
"of the system :cite:`sozeau08` and the literature on type classes in Haskell "
"which also applies."
msgstr ""

#: ../../addendum/type-classes.rst:13
msgid "Class and Instance declarations"
msgstr ""

#: ../../addendum/type-classes.rst:15
msgid ""
"The syntax for class and instance declarations is the same as the record "
"syntax of Coq:"
msgstr ""

#: ../../addendum/type-classes.rst:18
msgid ""
"``Class Id (`` |p_1| ``:`` |t_1| ``) ⋯ (`` |p_n| ``:`` |t_n| ``) [: sort] := "
"{`` |f_1| ``:`` |u_1| ``; ⋮`` |f_m| ``:`` |u_m| ``}.``"
msgstr ""

#: ../../addendum/type-classes.rst:21
msgid ""
"``Instance ident : Id`` |p_1| ``⋯`` |p_n| ``:= {`` |f_1| ``:=`` |t_1| ``; "
"⋮`` |f_m| ``:=`` |t_m| ``}.``"
msgstr ""

#: ../../addendum/type-classes.rst:23
msgid ""
"The |p_i| ``:`` |t_i| variables are called the *parameters* of the class and "
"the |f_i| ``:`` |t_i| are called the *methods*. Each class definition gives "
"rise to a corresponding record declaration and each instance is a regular "
"definition whose name is given by ident and type is an instantiation of the "
"record type."
msgstr ""

#: ../../addendum/type-classes.rst:29
msgid "We’ll use the following example class in the rest of the chapter:"
msgstr ""

#: ../../addendum/type-classes.rst:37
msgid ""
"This class implements a boolean equality test which is compatible with "
"Leibniz equality on some type. An example implementation is:"
msgstr ""

#: ../../addendum/type-classes.rst:47
msgid ""
"If one does not give all the members in the Instance declaration, Coq enters "
"the proof-mode and the user is asked to build inhabitants of the remaining "
"fields, e.g.:"
msgstr ""

#: ../../addendum/type-classes.rst:68
msgid ""
"One has to take care that the transparency of every field is determined by "
"the transparency of the :cmd:`Instance` proof. One can use alternatively "
"the :cmd:`Program Instance` variant which has richer facilities for dealing "
"with obligations."
msgstr ""

#: ../../addendum/type-classes.rst:75
msgid "Binding classes"
msgstr ""

#: ../../addendum/type-classes.rst:77
msgid "Once a typeclass is declared, one can use it in class binders:"
msgstr ""

#: ../../addendum/type-classes.rst:83
msgid ""
"When one calls a class method, a constraint is generated that is satisfied "
"only in contexts where the appropriate instances can be found. In the "
"example above, a constraint ``EqDec A`` is generated and satisfied by "
"``eqa : EqDec A``. In case no satisfying constraint can be found, an error "
"is raised:"
msgstr ""

#: ../../addendum/type-classes.rst:93
msgid ""
"The algorithm used to solve constraints is a variant of the :tacn:`eauto` "
"tactic that does proof search with a set of lemmas (the instances). It will "
"use local hypotheses as well as declared lemmas in the "
"``typeclass_instances`` database. Hence the example can also be written:"
msgstr ""

#: ../../addendum/type-classes.rst:103
msgid ""
"However, the generalizing binders should be used instead as they have "
"particular support for typeclasses:"
msgstr ""

#: ../../addendum/type-classes.rst:106
msgid ""
"They automatically set the maximally implicit status for typeclass "
"arguments, making derived functions as easy to use as class methods. In the "
"example above, ``A`` and ``eqa`` should be set maximally implicit."
msgstr ""

#: ../../addendum/type-classes.rst:109
msgid ""
"They support implicit quantification on partially applied type classes (:ref:"
"`implicit-generalization`). Any argument not given as part of a typeclass "
"binder will be automatically generalized."
msgstr ""

#: ../../addendum/type-classes.rst:112
msgid "They also support implicit quantification on :ref:`superclasses`."
msgstr ""

#: ../../addendum/type-classes.rst:115
msgid "Following the previous example, one can write:"
msgstr ""

#: ../../addendum/type-classes.rst:123
msgid ""
"Here ``A`` is implicitly generalized, and the resulting function is "
"equivalent to the one above."
msgstr ""

#: ../../addendum/type-classes.rst:127
msgid "Parameterized Instances"
msgstr ""

#: ../../addendum/type-classes.rst:129
msgid ""
"One can declare parameterized instances as in Haskell simply by giving the "
"constraints as a binding context before the instance, e.g.:"
msgstr ""

#: ../../addendum/type-classes.rst:143
msgid ""
"These instances are used just as well as lemmas in the instance hint "
"database."
msgstr ""

#: ../../addendum/type-classes.rst:147
msgid "Sections and contexts"
msgstr ""

#: ../../addendum/type-classes.rst:149
msgid ""
"To ease the parametrization of developments by typeclasses, we provide a new "
"way to introduce variables into section contexts, compatible with the "
"implicit argument mechanism. The new command works similarly to the :cmd:"
"`Variables` vernacular, except it accepts any binding context as argument. "
"For example:"
msgstr ""

#: ../../addendum/type-classes.rst:172
msgid ""
"Here the Global modifier redeclares the instance at the end of the section, "
"once it has been generalized by the context variables it uses."
msgstr ""

#: ../../addendum/type-classes.rst:178
msgid "Building hierarchies"
msgstr ""

#: ../../addendum/type-classes.rst:183
msgid "Superclasses"
msgstr ""

#: ../../addendum/type-classes.rst:185
msgid ""
"One can also parameterize classes by other classes, generating a hierarchy "
"of classes and superclasses. In the same way, we give the superclasses as a "
"binding context:"
msgstr ""

#: ../../addendum/type-classes.rst:193
msgid ""
"Contrary to Haskell, we have no special syntax for superclasses, but this "
"declaration is equivalent to:"
msgstr ""

#: ../../addendum/type-classes.rst:202
msgid ""
"This declaration means that any instance of the ``Ord`` class must have an "
"instance of ``EqDec``. The parameters of the subclass contain at least all "
"the parameters of its superclasses in their order of appearance (here A is "
"the only one). As we have seen, ``Ord`` is encoded as a record type with two "
"parameters: a type ``A`` and an ``E`` of type ``EqDec A``. However, one can "
"still use it as if it had a single parameter inside generalizing binders: "
"the generalization of superclasses will be done automatically."
msgstr ""

#: ../../addendum/type-classes.rst:215
msgid ""
"In some cases, to be able to specify sharing of structures, one may want to "
"give explicitly the superclasses. It is is possible to do it directly in "
"regular binders, and using the ``!`` modifier in class binders. For example:"
msgstr ""

#: ../../addendum/type-classes.rst:224
msgid ""
"The ``!`` modifier switches the way a binder is parsed back to the regular "
"interpretation of Coq. In particular, it uses the implicit arguments "
"mechanism if available, as shown in the example."
msgstr ""

#: ../../addendum/type-classes.rst:229
msgid "Substructures"
msgstr ""

#: ../../addendum/type-classes.rst:231
msgid ""
"Substructures are components of a class which are instances of a class "
"themselves. They often arise when using classes for logical properties, e.g.:"
msgstr ""

#: ../../addendum/type-classes.rst:247
msgid ""
"This declares singleton classes for reflexive and transitive relations, (see "
"the :ref:`singleton class <singleton-class>` variant for an explanation). "
"These may be used as parts of other classes:"
msgstr ""

#: ../../addendum/type-classes.rst:257
msgid ""
"The syntax ``:>`` indicates that each ``PreOrder`` can be seen as a "
"``Reflexive`` relation. So each time a reflexive relation is needed, a "
"preorder can be used instead. This is very similar to the coercion mechanism "
"of ``Structure`` declarations. The implementation simply declares each "
"projection as an instance."
msgstr ""

#: ../../addendum/type-classes.rst:263
msgid ""
"One can also declare existing objects or structure projections using the "
"Existing Instance command to achieve the same effect."
msgstr ""

#: ../../addendum/type-classes.rst:268
msgid "Summary of the commands"
msgstr ""

#: ../../addendum/type-classes.rst:272
msgid ""
"The :cmd:`Class` command is used to declare a typeclass with parameters "
"``binders`` and fields the declared record fields."
msgstr ""

#: ../../addendum/type-classes.rst:275
msgid "Variants:"
msgstr ""

#: ../../addendum/type-classes.rst:281
msgid ""
"This variant declares a *singleton* class with a single method.  This "
"singleton class is a so-called definitional class, represented simply as a "
"definition ``ident binders := term`` and whose instances are themselves "
"objects of this type. Definitional classes are not wrapped inside records, "
"and the trivial projection of an instance of such a class is convertible to "
"the instance itself. This can be useful to make instances of existing "
"objects easily and to reduce proof size by not inserting useless "
"projections. The class constant itself is declared rigid during resolution "
"so that the class abstraction is maintained."
msgstr ""

#: ../../addendum/type-classes.rst:294
msgid ""
"This variant declares a class a posteriori from a constant or inductive "
"definition. No methods or instances are defined."
msgstr ""

#: ../../addendum/type-classes.rst:299
msgid ""
"The :cmd:`Instance` command is used to declare a typeclass instance named "
"``ident`` of the class :cmd:`Class` with parameters ``t1`` to ``tn`` and "
"fields ``b1`` to ``bi``, where each field must be a declared field of the "
"class.  Missing fields must be filled in interactive proof mode."
msgstr ""

#: ../../addendum/type-classes.rst:304
msgid ""
"An arbitrary context of ``binders`` can be put after the name of the "
"instance and before the colon to declare a parameterized instance. An "
"optional priority can be declared, 0 being the highest priority as for :tacn:"
"`auto` hints. If the priority is not specified, it defaults to the number of "
"non-dependent binders of the instance."
msgstr ""

#: ../../addendum/type-classes.rst:312
msgid ""
"This syntax is used for declaration of singleton class instances or for "
"directly giving an explicit term of type ``forall binders, Class t1 … tn``.  "
"One need not even mention the unique field name for singleton classes."
msgstr ""

#: ../../addendum/type-classes.rst:319
msgid ""
"One can use the ``Global`` modifier on instances declared in a section so "
"that their generalization is automatically redeclared after the section is "
"closed."
msgstr ""

#: ../../addendum/type-classes.rst:326
msgid ""
"Switches the type checking to Program (chapter :ref:`programs`) and uses the "
"obligation mechanism to manage missing fields."
msgstr ""

#: ../../addendum/type-classes.rst:332
msgid ""
"In a Module Type, this command states that a corresponding concrete instance "
"should exist in any implementation of this Module Type. This is similar to "
"the distinction between :cmd:`Parameter` vs. :cmd:`Definition`, or between :"
"cmd:`Declare Module` and :cmd:`Module`."
msgstr ""

#: ../../addendum/type-classes.rst:338
msgid ""
"Besides the :cmd:`Class` and :cmd:`Instance` vernacular commands, there are "
"a few other commands related to typeclasses."
msgstr ""

#: ../../addendum/type-classes.rst:343
msgid ""
"This command adds an arbitrary list of constants whose type ends with an "
"applied typeclass to the instance database with an optional priority.  It "
"can be used for redeclaring instances at the end of sections, or declaring "
"structure projections as instances. This is equivalent to ``Hint Resolve "
"ident : typeclass_instances``, except it registers instances for :cmd:`Print "
"Instances`."
msgstr ""

#: ../../addendum/type-classes.rst:352
msgid ""
"Declares variables according to the given binding context, which might use :"
"ref:`implicit-generalization`."
msgstr ""

#: ../../addendum/type-classes.rst:358
msgid ""
"This tactic uses a different resolution engine than :tacn:`eauto` and :tacn:"
"`auto`. The main differences are the following:"
msgstr ""

#: ../../addendum/type-classes.rst:361
msgid ""
"Contrary to :tacn:`eauto` and :tacn:`auto`, the resolution is done entirely "
"in the new proof engine (as of Coq 8.6), meaning that backtracking is "
"available among dependent subgoals, and shelving goals is supported. "
"``typeclasses eauto`` is a multi-goal tactic. It analyses the dependencies "
"between subgoals to avoid backtracking on subgoals that are entirely "
"independent."
msgstr ""

#: ../../addendum/type-classes.rst:368
msgid ""
"When called with no arguments, ``typeclasses eauto`` uses the "
"``typeclass_instances`` database by default (instead of core). Dependent "
"subgoals are automatically shelved, and shelved goals can remain after "
"resolution ends (following the behavior of Coq 8.5)."
msgstr ""

#: ../../addendum/type-classes.rst:374
msgid ""
"As of Coq 8.6, ``all:once (typeclasses eauto)`` faithfully mimicks what "
"happens during typeclass resolution when it is called during refinement/type "
"inference, except that *only* declared class subgoals are considered at the "
"start of resolution during type inference, while ``all`` can select non-"
"class subgoals as well. It might move to ``all:typeclasses eauto`` in future "
"versions when the refinement engine will be able to backtrack."
msgstr ""

#: ../../addendum/type-classes.rst:382
msgid ""
"When called with specific databases (e.g. with), ``typeclasses eauto`` "
"allows shelved goals to remain at any point during search and treat "
"typeclass goals like any other."
msgstr ""

#: ../../addendum/type-classes.rst:386
msgid ""
"The transparency information of databases is used consistently for all hints "
"declared in them. It is always used when calling the unifier. When "
"considering local hypotheses, we use the transparent state of the first hint "
"database given. Using an empty database (created with :cmd:`Create HintDb` "
"for example) with unfoldable variables and constants as the first argument "
"of ``typeclasses eauto`` hence makes resolution with the local hypotheses "
"use full conversion during unification."
msgstr ""

#: ../../addendum/type-classes.rst:399
msgid ""
"The semantics for the limit :n:`@num` is different than for auto. By "
"default, if no limit is given, the search is unbounded. Contrary to :tacn:"
"`auto`, introduction steps are counted, which might result in larger limits "
"being necessary when searching with ``typeclasses eauto`` than with :tacn:"
"`auto`."
msgstr ""

#: ../../addendum/type-classes.rst:407
msgid ""
"This variant runs resolution with the given hint databases. It treats "
"typeclass subgoals the same as other subgoals (no shelving of non-typeclass "
"goals in particular)."
msgstr ""

#: ../../addendum/type-classes.rst:414
msgid ""
"The tactic ``autoapply`` applies a term using the transparency information "
"of the hint database ident, and does *no* typeclass resolution. This can be "
"used in :cmd:`Hint Extern`’s for typeclass instances (in the hint database "
"``typeclass_instances``) to allow backtracking on the typeclass subgoals "
"created by the lemma application, rather than doing typeclass resolution "
"locally at the hint application time."
msgstr ""

#: ../../addendum/type-classes.rst:424
msgid "Typeclasses Transparent, Typclasses Opaque"
msgstr ""

#: ../../addendum/type-classes.rst:428
msgid ""
"This command makes the identifiers transparent during typeclass resolution."
msgstr ""

#: ../../addendum/type-classes.rst:433
msgid ""
"Make the identifiers opaque for typeclass search. It is useful when some "
"constants prevent some unifications and make resolution fail. It is also "
"useful to declare constants which should never be unfolded during proof-"
"search, like fixpoints or anything which does not look like an abbreviation. "
"This can additionally speed up proof search as the typeclass map can be "
"indexed by such rigid constants (see :ref:"
"`thehintsdatabasesforautoandeauto`)."
msgstr ""

#: ../../addendum/type-classes.rst:441
msgid ""
"By default, all constants and local variables are considered transparent. "
"One should take care not to make opaque any constant that is used to "
"abbreviate a type, like:"
msgstr ""

#: ../../addendum/type-classes.rst:449
msgid ""
"This is equivalent to ``Hint Transparent, Opaque ident : "
"typeclass_instances``."
msgstr ""

#: ../../addendum/type-classes.rst:457
msgid ""
"This option (on by default since 8.6) respects the dependency order between "
"subgoals, meaning that subgoals on which other subgoals depend come first, "
"while the non-dependent subgoals were put before the dependent ones "
"previously (Coq 8.5 and below). This can result in quite different "
"performance behaviors of proof search."
msgstr ""

#: ../../addendum/type-classes.rst:466
msgid ""
"This option, available since Coq 8.6 and off by default, switches the hint "
"application procedure to a filter-then-unify strategy. To apply a hint, we "
"first check that the goal *matches* syntactically the inferred or specified "
"pattern of the hint, and only then try to *unify* the goal with the "
"conclusion of the hint. This can drastically improve performance by calling "
"unification less often, matching syntactic patterns being very quick. This "
"also provides more control on the triggering of instances. For example, "
"forcing a constant to explicitely appear in the pattern will make it never "
"apply on a goal where there is a hole in that place."
msgstr ""

#: ../../addendum/type-classes.rst:480
msgid ""
"This option (on by default) controls the ability to apply hints while "
"avoiding (functional) eta-expansions in the generated proof term. It does so "
"by allowing hints that conclude in a product to apply to a goal with a "
"matching product directly, avoiding an introduction."
msgstr ""

#: ../../addendum/type-classes.rst:487
msgid ""
"This can be expensive as it requires rebuilding hint clauses dynamically, "
"and does not benefit from the invertibility status of the product "
"introduction rule, resulting in potentially more expensive proof-search (i."
"e. more useless backtracking)."
msgstr ""

#: ../../addendum/type-classes.rst:494
msgid ""
"This option (on by default) controls the use of typeclass resolution when a "
"unification problem cannot be solved during elaboration/type inference. With "
"this option on, when a unification fails, typeclass resolution is tried "
"before launching unification once again."
msgstr ""

#: ../../addendum/type-classes.rst:502
msgid ""
"Typeclass declarations introduced when this option is set have a stricter "
"resolution behavior (the option is off by default). When looking for "
"unifications of a goal with an instance of this class, we “freeze” all the "
"existentials appearing in the goals, meaning that they are considered rigid "
"during unification and cannot be instantiated."
msgstr ""

#: ../../addendum/type-classes.rst:512
msgid ""
"When a typeclass resolution is launched we ensure that it has a single "
"solution or fail. This ensures that the resolution is canonical, but can "
"make proof search much more expensive."
msgstr ""

#: ../../addendum/type-classes.rst:519
msgid ""
"Typeclass declarations introduced when this option is set have a more "
"efficient resolution behavior (the option is off by default). When a "
"solution to the typeclass goal of this class is found, we never backtrack on "
"it, assuming that it is canonical."
msgstr ""

#: ../../addendum/type-classes.rst:526
msgid ""
"Controls whether typeclass resolution steps are shown during search.  "
"Setting this flag also sets :opt:`Typeclasses Debug Verbosity` to 1."
msgstr ""

#: ../../addendum/type-classes.rst:532
msgid ""
"Determines how much information is shown for typeclass resolution steps "
"during search. 1 is the default level.  2 shows additional information such "
"as tried tactics and shelving of goals.  Setting this option also sets :flag:"
"`Typeclasses Debug`."
msgstr ""

#: ../../addendum/type-classes.rst:538
msgid ""
"This option allows to switch the behavior of instance declarations made "
"through the Instance command."
msgstr ""

#: ../../addendum/type-classes.rst:541
msgid ""
"When it is on (the default), instances that have unsolved holes in their "
"proof-term silently open the proof mode with the remaining obligations to "
"prove."
msgstr ""

#: ../../addendum/type-classes.rst:545
msgid "When it is off, they fail with an error instead."
msgstr ""

#: ../../addendum/type-classes.rst:548
msgid "Typeclasses eauto `:=`"
msgstr ""

#: ../../addendum/type-classes.rst:552
msgid ""
"This command allows more global customization of the typeclass resolution "
"tactic. The semantics of the options are:"
msgstr ""

#: ../../addendum/type-classes.rst:555
msgid ""
"``debug`` In debug mode, the trace of successfully applied tactics is "
"printed."
msgstr ""

#: ../../addendum/type-classes.rst:558
msgid ""
"``dfs, bfs`` This sets the search strategy to depth-first search (the "
"default) or breadth-first search."
msgstr ""

#: ../../addendum/type-classes.rst:561
msgid "``depth`` This sets the depth limit of the search."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:4
msgid "Polymorphic Universes"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:13
msgid "The status of Universe Polymorphism is experimental."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:15
msgid ""
"This section describes the universe polymorphic extension of |Coq|. Universe "
"polymorphism makes it possible to write generic definitions making use of "
"universes and reuse them at different and sometimes incompatible universe "
"levels."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:20
msgid ""
"A standard example of the difference between universe *polymorphic* and "
"*monomorphic* definitions is given by the identity function:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:27
msgid ""
"By default, constant declarations are monomorphic, hence the identity "
"function declares a global universe (say ``Top.1``) for its domain. "
"Subsequently, if we try to self-apply the identity, we will get an error:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:36
msgid ""
"Indeed, the global level ``Top.1`` would have to be strictly smaller than "
"itself for this self-application to type check, as the type of :g:"
"`(@identity)` is :g:`forall (A : Type@{Top.1}), A -> A` whose type is "
"itself :g:`Type@{Top.1+1}`."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:41
msgid ""
"A universe polymorphic identity function binds its domain universe level at "
"the definition level instead of making it global."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:52
msgid "It is then possible to reuse the constant at different levels, like so:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:59
msgid ""
"Of course, the two instances of :g:`pidentity` in this definition are "
"different. This can be seen when the :flag:`Printing Universes` flag is on:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:70
msgid ""
"Now :g:`pidentity` is used at two different levels: at the head of the "
"application it is instantiated at ``Top.3`` while in the argument position "
"it is instantiated at ``Top.4``. This definition is only valid as long as "
"``Top.4`` is strictly smaller than ``Top.3``, as shown by the constraints. "
"Note that this definition is monomorphic (not universe polymorphic), so the "
"two universes (in this case ``Top.3`` and ``Top.4``) are actually global "
"levels."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:78
msgid ""
"When printing :g:`pidentity`, we can see the universes it binds in the "
"annotation :g:`@{Top.2}`. Additionally, when :flag:`Printing Universes` is "
"on we print the \"universe context\" of :g:`pidentity` consisting of the "
"bound universes and the constraints they must verify (for :g:`pidentity` "
"there are no constraints)."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:84
msgid ""
"Inductive types can also be declared universes polymorphic on universes "
"appearing in their parameters or fields. A typical example is given by "
"monoids:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:97
msgid ""
"The Monoid's carrier universe is polymorphic, hence it is possible to "
"instantiate it for example with :g:`Monoid` itself. First we build the "
"trivial unit monoid in :g:`Set`:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:106
msgid ""
"From this we can build a definition for the monoid of :g:`Set`\\-monoids "
"(where multiplication would be given by the product of monoids)."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:119
msgid ""
"As one can see from the constraints, this monoid is “large”, it lives in a "
"universe strictly higher than :g:`Set`."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:123
msgid "Polymorphic, Monomorphic"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:127
msgid ""
"As shown in the examples, polymorphic definitions and inductives can be "
"declared using the ``Polymorphic`` prefix."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:132
msgid ""
"Once enabled, this option will implicitly prepend ``Polymorphic`` to any "
"definition of the user."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:137
msgid ""
"When the :flag:`Universe Polymorphism` option is set, to make a definition "
"producing global universe constraints, one can use the ``Monomorphic`` "
"prefix."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:140
msgid "Many other commands support the ``Polymorphic`` flag, including:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:144
msgid ""
"``Lemma``, ``Axiom``, and all the other “definition” keywords support "
"polymorphism."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:147
msgid ""
"``Variables``, ``Context``, ``Universe`` and ``Constraint`` in a section "
"support polymorphism. This means that the universe variables (and associated "
"constraints) are discharged polymorphically over definitions that use them. "
"In other words, two definitions in the section sharing a common variable "
"will both get parameterized by the universes produced by the variable "
"declaration. This is in contrast to a “mononorphic” variable which "
"introduces global universes and constraints, making the two definitions "
"depend on the *same* global universes associated to the variable."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:157
msgid ""
":cmd:`Hint Resolve` and :cmd:`Hint Rewrite` will use the auto/rewrite hint "
"polymorphically, not at a single instance."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:161
msgid "Cumulative, NonCumulative"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:163
msgid ""
"Polymorphic inductive types, coinductive types, variants and records can be "
"declared cumulative using the :g:`Cumulative` prefix."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:168
msgid "Declares the inductive as cumulative"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:170
msgid ""
"Alternatively, there is a flag :flag:`Polymorphic Inductive Cumulativity` "
"which when set, makes all subsequent *polymorphic* inductive definitions "
"cumulative.  When set, inductive types and the like can be enforced to be "
"non-cumulative using the :g:`NonCumulative` prefix."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:178
msgid "Declares the inductive as non-cumulative"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:182
msgid ""
"When this option is on, it sets all following polymorphic inductive types as "
"cumulative (it is off by default)."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:185
msgid "Consider the examples below."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:197
msgid ""
"When printing :g:`list`, the universe context indicates the subtyping "
"constraints by prefixing the level names with symbols."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:200
msgid ""
"Because inductive subtypings are only produced by comparing inductives to "
"themselves with universes changed, they amount to variance information: each "
"universe is either invariant, covariant or irrelevant (there are no "
"contravariant subtypings in Coq), respectively represented by the symbols "
"`=`, `+` and `*`."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:206
msgid ""
"Here we see that :g:`list` binds an irrelevant universe, so any two "
"instances of :g:`list` are convertible: :math:`E[Γ] ⊢ \\mathsf{list}@\\{i\\}"
"~A =_{βδιζη} \\mathsf{list}@\\{j\\}~B` whenever :math:`E[Γ] ⊢ A =_{βδιζη} B` "
"and this applies also to their corresponding constructors, when they are "
"comparable at the same type."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:212
msgid ""
"See :ref:`Conversion-rules` for more details on convertibility and "
"subtyping. The following is an example of a record with non-trivial "
"subtyping relation:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:219
msgid ":g:`packType` binds a covariant universe, i.e."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:226
msgid ""
"Cumulative inductive types, coninductive types, variants and records only "
"make sense when they are universe polymorphic. Therefore, an error is issued "
"whenever the user uses the :g:`Cumulative` or :g:`NonCumulative` prefix in a "
"monomorphic context. Notice that this is not the case for the option :flag:"
"`Polymorphic Inductive Cumulativity`. That is, this option, when set, makes "
"all subsequent *polymorphic* inductive declarations cumulative (unless, of "
"course the :g:`NonCumulative` prefix is used) but has no effect on "
"*monomorphic* inductive declarations."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:235
msgid "Consider the following examples."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:251
msgid "An example of a proof using cumulativity"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:276
msgid "Cumulativity Weak Constraints"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:280
msgid ""
"When set, which is the default, causes \"weak\" constraints to be produced "
"when comparing universes in an irrelevant position. Processing weak "
"constraints is delayed until minimization time. A weak constraint between "
"`u` and `v` when neither is smaller than the other and one is flexible "
"causes them to be unified. Otherwise the constraint is silently discarded."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:287
msgid ""
"This heuristic is experimental and may change in future versions. Disabling "
"weak constraints is more predictable but may produce arbitrary numbers of "
"universes."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:293
msgid "Global and local universes"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:295
msgid ""
"Each universe is declared in a global or local environment before it can be "
"used. To ensure compatibility, every *global* universe is set to be strictly "
"greater than :g:`Set` when it is introduced, while every *local* (i.e. "
"polymorphically quantified) universe is introduced as greater or equal to :g:"
"`Set`."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:303
msgid "Conversion and unification"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:305
msgid ""
"The semantics of conversion and unification have to be modified a little to "
"account for the new universe instance arguments to polymorphic references. "
"The semantics respect the fact that definitions are transparent, so "
"indistinguishable from their bodies during conversion."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:311
msgid ""
"This is accomplished by changing one rule of unification, the first- order "
"approximation rule, which applies when two applicative terms with the same "
"head are compared. It tries to short-cut unfolding by comparing the "
"arguments directly. In case the constant is universe polymorphic, we allow "
"this rule to fire only when unifying the universes results in instantiating "
"a so-called flexible universe variables (not given by the user). Similarly "
"for conversion, if such an equation of applicative terms fail due to a "
"universe comparison not being satisfied, the terms are unfolded. This change "
"implies that conversion and unification can have different unfolding "
"behaviors on the same development with universe polymorphism switched on or "
"off."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:325
msgid "Minimization"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:327
msgid ""
"Universe polymorphism with cumulativity tends to generate many useless "
"inclusion constraints in general. Typically at each application of a "
"polymorphic constant :g:`f`, if an argument has expected type :g:`Type@{i}` "
"and is given a term of type :g:`Type@{j}`, a :math:`j ≤ i` constraint will "
"be generated. It is however often the case that an equation :math:`j = i` "
"would be more appropriate, when :g:`f`\\'s universes are fresh for example. "
"Consider the following example:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:348
msgid ""
"This definition is elaborated by minimizing the universe of :g:`id0` to "
"level :g:`Set` while the more general definition would keep the fresh level :"
"g:`i` generated at the application of :g:`id` and a constraint that :g:"
"`Set` :math:`≤ i`. This minimization process is applied only to fresh "
"universe variables. It simply adds an equation between the variable and its "
"lower bound if it is an atomic universe (i.e. not an algebraic max() "
"universe)."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:357
msgid ""
"Turning this flag off (it is on by default) disallows minimization to the "
"sort :g:`Set` and only collapses floating universes between themselves."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:363
msgid "Explicit Universes"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:365
msgid ""
"The syntax has been extended to allow users to explicitly bind names to "
"universes and explicitly instantiate polymorphic definitions."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:370
msgid ""
"In the monorphic case, this command declares a new global universe named :g:"
"`ident`, which can be referred to using its qualified name as well. Global "
"universe names live in a separate namespace. The command supports the "
"polymorphic flag only in sections, meaning the universe quantification will "
"be discharged on each section definition independently. One cannot mix "
"polymorphic and monomorphic declarations in the same section."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:381
msgid ""
"This command declares a new constraint between named universes. The order "
"relation :n:`@ord` can be one of :math:`<`, :math:`≤` or :math:`=`. If "
"consistent, the constraint is then enforced in the global environment. Like "
"``Universe``, it can be used with the ``Polymorphic`` prefix in sections "
"only to declare constraints discharged at section closing time. One cannot "
"declare a global constraint on polymorphic universes."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:394
msgid "Polymorphic definitions"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:396
msgid ""
"For polymorphic definitions, the declaration of (all) universe levels "
"introduced by a definition uses the following syntax:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:407
msgid ""
"During refinement we find that :g:`j` must be larger or equal than :g:`i`, "
"as we are using :g:`A : Type@{i} <= Type@{j}`, hence the generated "
"constraint. At the end of a definition or proof, we check that the only "
"remaining universes are the ones declared. In the term and in general in "
"proof mode, introduced universe names can be referred to in terms. Note that "
"local universe names shadow global universe names. During a proof, one can "
"use :cmd:`Show Universes` to display the current context of universes."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:415
msgid ""
"Definitions can also be instantiated explicitly, giving their full instance:"
msgstr ""

#: ../../addendum/universe-polymorphism.rst:424
msgid ""
"User-named universes and the anonymous universe implicitly attached to an "
"explicit :g:`Type` are considered rigid for unification and are never "
"minimized. Flexible anonymous universes can be produced with an underscore "
"or by omitting the annotation to a polymorphic definition."
msgstr ""

#: ../../addendum/universe-polymorphism.rst:439
msgid ""
"Turning this option off allows one to freely use identifiers for universes "
"without declaring them first, with the semantics that the first use declares "
"it. In this mode, the universe names are not associated with the definition "
"or proof once it has been defined. This is meant mainly for debugging "
"purposes."
msgstr ""
