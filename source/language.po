# Japanese translations for Coq package.
# Copyright (C) 1999-2018, Inria
# This file is distributed under the same license as the Coq package.
# Automatically generated, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Coq 8.8.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-11 17:48+0900\n"
"PO-Revision-Date: 2018-11-11 17:48+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../language/cic.rst:5
msgid "Calculus of Inductive Constructions"
msgstr ""

#: ../../language/cic.rst:7
msgid ""
"The underlying formal language of |Coq| is a *Calculus of Inductive "
"Constructions* (|Cic|) whose inference rules are presented in this chapter. "
"The history of this formalism as well as pointers to related work are "
"provided in a separate chapter; see *Credits*."
msgstr ""

#: ../../language/cic.rst:16
msgid "The terms"
msgstr ""

#: ../../language/cic.rst:18
msgid ""
"The expressions of the |Cic| are *terms* and all terms have a *type*. There "
"are types for functions (or programs), there are atomic types (especially "
"datatypes)... but also types for proofs and types for the types themselves. "
"Especially, any object handled in the formalism must belong to a type. For "
"instance, universal quantification is relative to a type and takes the form "
"\"*for all x of type T, P* \". The expression “x of type T” is written :g:`x:"
"T`. Informally, :g:`x:T` can be thought as “x belongs to T”."
msgstr ""

#: ../../language/cic.rst:27
msgid ""
"The types of types are *sorts*. Types and sorts are themselves terms so that "
"terms, types and sorts are all components of a common syntactic language of "
"terms which is described in Section :ref:`terms` but, first, we describe "
"sorts."
msgstr ""

#: ../../language/cic.rst:36
#: ../../language/gallina-specification-language.rst:225
msgid "Sorts"
msgstr ""

#: ../../language/cic.rst:38
msgid ""
"All sorts have a type and there is an infinite well-founded typing hierarchy "
"of sorts whose base sorts are :math:`\\Prop` and :math:`\\Set`."
msgstr ""

#: ../../language/cic.rst:41
msgid ""
"The sort :math:`\\Prop` intends to be the type of logical propositions. If :"
"math:`M` is a logical proposition then it denotes the class of terms "
"representing proofs of :math:`M`. An object :math:`m` belonging to :math:`M` "
"witnesses the fact that :math:`M` is provable. An object of type :math:`"
"\\Prop` is called a proposition."
msgstr ""

#: ../../language/cic.rst:46
msgid ""
"The sort :math:`\\Set` intends to be the type of small sets. This includes "
"data types such as booleans and naturals, but also products, subsets, and "
"function types over these data types."
msgstr ""

#: ../../language/cic.rst:50
msgid ""
":math:`\\Prop` and :math:`\\Set` themselves can be manipulated as ordinary "
"terms. Consequently they also have a type. Because assuming simply that :"
"math:`\\Set` has type :math:`\\Set` leads to an inconsistent theory :cite:"
"`Coq86`, the language of |Cic| has infinitely many sorts. There are, in "
"addition to :math:`\\Set` and :math:`\\Prop` a hierarchy of universes :math:`"
"\\Type(i)` for any integer :math:`i`."
msgstr ""

#: ../../language/cic.rst:56
msgid ""
"Like :math:`\\Set`, all of the sorts :math:`\\Type(i)` contain small sets "
"such as booleans, natural numbers, as well as products, subsets and function "
"types over small sets. But, unlike :math:`\\Set`, they also contain large "
"sets, namely the sorts :math:`\\Set` and :math:`\\Type(j)` for :math:`j<i`, "
"and all products, subsets and function types over these sorts."
msgstr ""

#: ../../language/cic.rst:62
msgid "Formally, we call :math:`\\Sort` the set of sorts which is defined by:"
msgstr ""

#: ../../language/cic.rst:68
msgid ""
"Their properties, such as: :math:`\\Prop:\\Type(1)`, :math:`\\Set:"
"\\Type(1)`, and :math:`\\Type(i):\\Type(i+1)`, are defined in Section :ref:"
"`subtyping-rules`."
msgstr ""

#: ../../language/cic.rst:71
msgid ""
"The user does not have to mention explicitly the index :math:`i` when "
"referring to the universe :math:`\\Type(i)`. One only writes :math:`\\Type`. "
"The system itself generates for each instance of :math:`\\Type` a new index "
"for the universe and checks that the constraints between these indexes can "
"be solved. From the user point of view we consequently have :math:`\\Type:"
"\\Type`. We shall make precise in the typing rules the constraints between "
"the indices."
msgstr ""

#: ../../language/cic.rst:82
msgid ""
"**Implementation issues** In practice, the Type hierarchy is implemented "
"using *algebraic universes*. An algebraic universe :math:`u` is either a "
"variable (a qualified identifier with a number) or a successor of an "
"algebraic universe (an expression :math:`u+1`), or an upper bound of "
"algebraic universes (an expression :math:`\\max(u 1 ,...,u n )`), or the "
"base universe (the expression :math:`0`) which corresponds, in the arity of "
"template polymorphic inductive types (see Section :ref:`well-formed-"
"inductive-definitions`), to the predicative sort :math:`\\Set`. A graph of "
"constraints between the universe variables is maintained globally. To ensure "
"the existence of a mapping of the universes to the positive integers, the "
"graph of constraints must remain acyclic. Typing expressions that violate "
"the acyclicity of the graph of constraints results in a Universe "
"inconsistency error."
msgstr ""

#: ../../language/cic.rst:98
msgid "Section :ref:`printing-universes`."
msgstr ""

#: ../../language/cic.rst:104
#: ../../language/gallina-specification-language.rst:117
msgid "Terms"
msgstr ""

#: ../../language/cic.rst:108
msgid ""
"Terms are built from sorts, variables, constants, abstractions, "
"applications, local definitions, and products. From a syntactic point of "
"view, types cannot be distinguished from terms, except that they cannot "
"start by an abstraction or a constructor. More precisely the language of the "
"*Calculus of Inductive Constructions* is built from the following rules."
msgstr ""

#: ../../language/cic.rst:116
msgid "the sorts :math:`\\Set`, :math:`\\Prop`, :math:`\\Type(i)` are terms."
msgstr ""

#: ../../language/cic.rst:117
msgid ""
"variables, hereafter ranged over by letters :math:`x`, :math:`y`, etc., are "
"terms"
msgstr ""

#: ../../language/cic.rst:118
msgid ""
"constants, hereafter ranged over by letters :math:`c`, :math:`d`, etc., are "
"terms."
msgstr ""

#: ../../language/cic.rst:119
msgid ""
"if :math:`x` is a variable and :math:`T`, :math:`U` are terms then :math:`∀ "
"x:T,U` (:g:`forall x:T, U`   in |Coq| concrete syntax) is a term. If :math:"
"`x` occurs in :math:`U`, :math:`∀ x:T,U` reads as “for all :math:`x` of "
"type :math:`T`, :math:`U`”. As :math:`U` depends on :math:`x`, one says "
"that :math:`∀ x:T,U` is a *dependent product*. If :math:`x` does not occur "
"in :math:`U` then :math:`∀ x:T,U` reads as “if :math:`T` then :math:`U`”. A "
"*non dependent product* can be written: :math:`T \\rightarrow U`."
msgstr ""

#: ../../language/cic.rst:128
msgid ""
"if :math:`x` is a variable and :math:`T`, :math:`u` are terms then :math:`λ "
"x:T . u` (:g:`fun x:T => u` in |Coq| concrete syntax) is a term. This is a "
"notation for the λ-abstraction of λ-calculus :cite:`Bar81`. The term :math:"
"`λ x:T . u` is a function which maps elements of :math:`T` to the "
"expression :math:`u`."
msgstr ""

#: ../../language/cic.rst:133
msgid ""
"if :math:`t` and :math:`u` are terms then :math:`(t~u)` is a term (:g:`t u` "
"in |Coq| concrete syntax). The term :math:`(t~u)` reads as “t applied to u”."
msgstr ""

#: ../../language/cic.rst:136
msgid ""
"if :g:`x` is a variable, and :math:`t`, :math:`T` and :math:`u` are terms "
"then :g:`let x:=t:T in u` is a term which denotes the term :math:`u` where "
"the variable :math:`x` is locally bound to :math:`t` of type :math:`T`. This "
"stands for the common “let-in” construction of functional programs such as "
"ML or Scheme."
msgstr ""

#: ../../language/cic.rst:146
msgid ""
"**Free variables.** The notion of free variables is defined as usual. In the "
"expressions :g:`λx:T. U` and :g:`∀ x:T, U` the occurrences of :math:`x` in :"
"math:`U` are bound."
msgstr ""

#: ../../language/cic.rst:153
msgid ""
"**Substitution.** The notion of substituting a term :math:`t` to free "
"occurrences of a variable :math:`x` in a term :math:`u` is defined as usual. "
"The resulting term is written :math:`\\subst{u}{x}{t}`."
msgstr ""

#: ../../language/cic.rst:161
msgid ""
"**The logical vs programming readings.** The constructions of the |Cic| can "
"be used to express both logical and programming notions, accordingly to the "
"Curry-Howard correspondence between proofs and programs, and between "
"propositions and types :cite:`Cur58,How80,Bru72`."
msgstr ""

#: ../../language/cic.rst:167
msgid ""
"For instance, let us assume that :math:`\\nat` is the type of natural "
"numbers with zero element written :math:`0` and that :g:`True` is the always "
"true proposition. Then :math:`→` is used both to denote :math:`\\nat→\\nat` "
"which is the type of functions from :math:`\\nat` to :math:`\\nat`, to "
"denote True→True which is an implicative proposition, to denote :math:`\\nat "
"→\\Prop` which is the type of unary predicates over the natural numbers, etc."
msgstr ""

#: ../../language/cic.rst:174
msgid ""
"Let us assume that ``mult`` is a function of type :math:`\\nat→\\nat→\\nat` "
"and ``eqnat`` a predicate of type \\nat→\\nat→ \\Prop. The λ-abstraction can "
"serve to build “ordinary” functions as in :math:`λ x:\\nat.(\\kw{mult}~x~x)` "
"(i.e. :g:`fun x:nat => mult x x` in |Coq| notation) but may build also "
"predicates over the natural numbers. For instance :math:`λ x:\\nat."
"(\\kw{eqnat}~x~0)` (i.e. :g:`fun x:nat => eqnat x 0` in |Coq| notation) will "
"represent the predicate of one variable :math:`x` which asserts the equality "
"of :math:`x` with :math:`0`. This predicate has type :math:`\\nat → \\Prop` "
"and it can be applied to any expression of type :math:`\\nat`, say :math:"
"`t`, to give an object :math:`P~t` of type :math:`\\Prop`, namely a "
"proposition."
msgstr ""

#: ../../language/cic.rst:187
msgid ""
"Furthermore :g:`forall x:nat, P x` will represent the type of functions "
"which associate to each natural number :math:`n` an object of type :math:"
"`(P~n)` and consequently represent the type of proofs of the formula “:math:"
"`∀ x. P(x`)”."
msgstr ""

#: ../../language/cic.rst:195
msgid "Typing rules"
msgstr ""

#: ../../language/cic.rst:197
msgid ""
"As objects of type theory, terms are subjected to *type discipline*. The "
"well typing of a term depends on a global environment and a local context."
msgstr ""

#: ../../language/cic.rst:204
msgid ""
"**Local context.** A *local context* is an ordered list of *local "
"declarations* of names which we call *variables*. The declaration of some "
"variable :math:`x` is either a *local assumption*, written :math:`x:T` (:"
"math:`T` is a type) or a *local definition*, written :math:`x:=t:T`. We use "
"brackets to write local contexts. A typical example is :math:`[x:T;y:=u:U;z:"
"V]`. Notice that the variables declared in a local context must be distinct. "
"If :math:`Γ` is a local context that declares some :math:`x`, we write :math:"
"`x ∈ Γ`. By writing :math:`(x:T) ∈ Γ` we mean that either :math:`x:T` is an "
"assumption in :math:`Γ` or that there exists some :math:`t` such that :math:"
"`x:=t:T` is a definition in :math:`Γ`. If :math:`Γ` defines some :math:`x:=t:"
"T`, we also write :math:`(x:=t:T) ∈ Γ`. For the rest of the chapter, :math:"
"`Γ::(y:T)` denotes the local context :math:`Γ` enriched with the local "
"assumption :math:`y:T`. Similarly, :math:`Γ::(y:=t:T)` denotes the local "
"context :math:`Γ` enriched with the local definition :math:`(y:=t:T)`. The "
"notation :math:`[]` denotes the empty local context. By :math:`Γ_1 ; Γ_2` we "
"mean concatenation of the local context :math:`Γ_1` and the local context :"
"math:`Γ_2` ."
msgstr ""

#: ../../language/cic.rst:224
msgid ""
"**Global environment.** A *global environment* is an ordered list of *global "
"declarations*. Global declarations are either *global assumptions* or "
"*global definitions*, but also declarations of inductive objects. Inductive "
"objects themselves declare both inductive or coinductive types and "
"constructors (see Section :ref:`inductive-definitions`)."
msgstr ""

#: ../../language/cic.rst:231
msgid ""
"A *global assumption* will be represented in the global environment as :math:"
"`(c:T)` which assumes the name :math:`c` to be of some type :math:`T`. A "
"*global definition* will be represented in the global environment as :math:"
"`c:=t:T` which defines the name :math:`c` to have value :math:`t` and type :"
"math:`T`. We shall call such names *constants*. For the rest of the chapter, "
"the :math:`E;c:T` denotes the global environment :math:`E` enriched with the "
"global assumption :math:`c:T`. Similarly, :math:`E;c:=t:T` denotes the "
"global environment :math:`E` enriched with the global definition :math:`(c:"
"=t:T)`."
msgstr ""

#: ../../language/cic.rst:240
msgid ""
"The rules for inductive definitions (see Section :ref:`inductive-"
"definitions`) have to be considered as assumption rules to which the "
"following definitions apply: if the name :math:`c` is declared in :math:`E`, "
"we write :math:`c ∈ E` and if :math:`c:T` or :math:`c:=t:T` is declared in :"
"math:`E`, we write :math:`(c : T) ∈ E`."
msgstr ""

#: ../../language/cic.rst:249
msgid ""
"**Typing rules.** In the following, we define simultaneously two judgments. "
"The first one :math:`\\WTEG{t}{T}` means the term :math:`t` is well-typed "
"and has type :math:`T` in the global environment :math:`E` and local "
"context :math:`Γ`. The second judgment :math:`\\WFE{Γ}` means that the "
"global environment :math:`E` is well-formed and the local context :math:`Γ` "
"is a valid local context in this global environment."
msgstr ""

#: ../../language/cic.rst:256
msgid ""
"A term :math:`t` is well typed in a global environment :math:`E` iff there "
"exists a local context :math:`\\Gamma` and a term :math:`T` such that the "
"judgment :math:`\\WTEG{t}{T}` can be derived from the following rules."
msgstr ""

#: ../../language/cic.rst:376
msgid ""
"**Prod-Prop** and **Prod-Set** typing-rules make sense if we consider the "
"semantic difference between :math:`\\Prop` and :math:`\\Set`:"
msgstr ""

#: ../../language/cic.rst:379
msgid "All values of a type that has a sort :math:`\\Set` are extractable."
msgstr ""

#: ../../language/cic.rst:380
msgid "No values of a type that has a sort :math:`\\Prop` are extractable."
msgstr ""

#: ../../language/cic.rst:385
msgid ""
"We may have :math:`\\letin{x}{t:T}{u}` well-typed without having :math:`((λ "
"x:T.u) t)` well-typed (where :math:`T` is a type of :math:`t`). This is "
"because the value :math:`t` associated to :math:`x` may be used in a "
"conversion rule (see Section :ref:`Conversion-rules`)."
msgstr ""

#: ../../language/cic.rst:395
msgid "Conversion rules"
msgstr ""

#: ../../language/cic.rst:397
msgid ""
"In |Cic|, there is an internal reduction mechanism. In particular, it can "
"decide if two programs are *intentionally* equal (one says *convertible*). "
"Convertibility is described in this section."
msgstr ""

#: ../../language/cic.rst:405
msgid "β-reduction"
msgstr ""

#: ../../language/cic.rst:407
msgid ""
"We want to be able to identify some terms as we can identify the application "
"of a function to a given argument with its result. For instance the identity "
"function over a given type T can be written :math:`λx:T. x`. In any global "
"environment :math:`E` and local context :math:`Γ`, we want to identify any "
"object :math:`a` (of type :math:`T`) with the application :math:`((λ x:T. x) "
"a)`.  We define for this a *reduction* (or a *conversion*) rule we call :"
"math:`β`:"
msgstr ""

#: ../../language/cic.rst:419
msgid ""
"We say that :math:`\\subst{t}{x}{u}` is the *β-contraction* of :math:`((λx:"
"T. t) u)` and, conversely, that :math:`((λ x:T. t) u)` is the *β-expansion* "
"of :math:`\\subst{t}{x}{u}`."
msgstr ""

#: ../../language/cic.rst:423
msgid ""
"According to β-reduction, terms of the *Calculus of Inductive Constructions* "
"enjoy some fundamental properties such as confluence, strong normalization, "
"subject reduction. These results are theoretically of great importance but "
"we will not detail them here and refer the interested reader to :cite:"
"`Coq85`."
msgstr ""

#: ../../language/cic.rst:433
msgid "ι-reduction"
msgstr ""

#: ../../language/cic.rst:435
msgid ""
"A specific conversion rule is associated to the inductive objects in the "
"global environment. We shall give later on (see Section :ref:`Well-formed-"
"inductive-definitions`) the precise rules but it just says that a destructor "
"applied to an object built from a constructor behaves as expected. This "
"reduction is called ι-reduction and is more precisely studied in :cite:"
"`Moh93,Wer94`."
msgstr ""

#: ../../language/cic.rst:446
msgid "δ-reduction"
msgstr ""

#: ../../language/cic.rst:448
msgid ""
"We may have variables defined in local contexts or constants defined in the "
"global environment. It is legal to identify such a reference with its value, "
"that is to expand (or unfold) it into its value. This reduction is called δ-"
"reduction and shows as follows."
msgstr ""

#: ../../language/cic.rst:471
msgid "ζ-reduction"
msgstr ""

#: ../../language/cic.rst:473
msgid ""
"|Coq| allows also to remove local definitions occurring in terms by "
"replacing the defined variable by its value. The declaration being "
"destroyed, this reduction differs from δ-reduction. It is called ζ-reduction "
"and shows as follows."
msgstr ""

#: ../../language/cic.rst:490
msgid "η-expansion"
msgstr ""

#: ../../language/cic.rst:492
msgid ""
"Another important concept is η-expansion. It is legal to identify any term :"
"math:`t` of functional type :math:`∀ x:T, U` with its so-called η-expansion"
msgstr ""

#: ../../language/cic.rst:498
msgid "for :math:`x` an arbitrary variable name fresh in :math:`t`."
msgstr ""

#: ../../language/cic.rst:503
msgid "We deliberately do not define η-reduction:"
msgstr ""

#: ../../language/cic.rst:508
msgid ""
"This is because, in general, the type of :math:`t` need not to be "
"convertible to the type of :math:`λ x:T. (t~x)`. E.g., if we take :math:`f` "
"such that:"
msgstr ""

#: ../../language/cic.rst:514
msgid "then"
msgstr ""

#: ../../language/cic.rst:519
msgid "We could not allow"
msgstr ""

#: ../../language/cic.rst:524
msgid ""
"because the type of the reduced term :math:`∀ x:\\Type(2),\\Type(1)` would "
"not be convertible to the type of the original term :math:`∀ x:\\Type(1),"
"\\Type(1).`"
msgstr ""

#: ../../language/cic.rst:531
msgid "Convertibility"
msgstr ""

#: ../../language/cic.rst:533
msgid ""
"Let us write :math:`E[Γ] ⊢ t \\triangleright u` for the contextual closure "
"of the relation :math:`t` reduces to :math:`u` in the global environment :"
"math:`E` and local context :math:`Γ` with one of the previous reductions β, "
"ι, δ or ζ."
msgstr ""

#: ../../language/cic.rst:538
msgid ""
"We say that two terms :math:`t_1` and :math:`t_2` are *βιδζη-convertible*, "
"or simply *convertible*, or *equivalent*, in the global environment :math:"
"`E` and local context :math:`Γ` iff there exist terms :math:`u_1` and :math:"
"`u_2` such that :math:`E[Γ] ⊢ t_1 \\triangleright … \\triangleright u_1` "
"and :math:`E[Γ] ⊢ t_2 \\triangleright … \\triangleright u_2` and either :"
"math:`u_1` and :math:`u_2` are identical, or they are convertible up to η-"
"expansion, i.e. :math:`u_1` is :math:`λ x:T. u_1'` and :math:`u_2 x` is "
"recursively convertible to :math:`u_1'` , or, symmetrically, :math:`u_2` is :"
"math:`λx:T. u_2'` and :math:`u_1 x` is recursively convertible to u_2′ . We "
"then write :math:`E[Γ] ⊢ t_1 =_{βδιζη} t_2` ."
msgstr ""

#: ../../language/cic.rst:550
msgid ""
"Apart from this we consider two instances of polymorphic and cumulative (see "
"Chapter :ref:`polymorphicuniverses`) inductive types (see below) convertible"
msgstr ""

#: ../../language/cic.rst:557
msgid "if we have subtypings (see below) in both directions, i.e.,"
msgstr ""

#: ../../language/cic.rst:562 ../../language/cic.rst:584
#: ../../language/cic.rst:631 ../../language/cic.rst:654
#: ../../language/gallina-extensions.rst:432
msgid "and"
msgstr ""

#: ../../language/cic.rst:567
msgid "Furthermore, we consider"
msgstr ""

#: ../../language/cic.rst:572
msgid "convertible if"
msgstr ""

#: ../../language/cic.rst:577
msgid ""
"and we have that :math:`c` and :math:`c'` are the same constructors of "
"different instances of the same inductive types (differing only in universe "
"levels) such that"
msgstr ""

#: ../../language/cic.rst:589
msgid "and we have"
msgstr ""

#: ../../language/cic.rst:594
msgid ""
"The convertibility relation allows introducing a new typing rule which says "
"that two convertible well-formed types have the same inhabitants."
msgstr ""

#: ../../language/cic.rst:601
msgid "Subtyping rules"
msgstr ""

#: ../../language/cic.rst:603
msgid ""
"At the moment, we did not take into account one rule between universes which "
"says that any term in a universe of index i is also a term in the universe "
"of index i+1 (this is the *cumulativity* rule of |Cic|). This property "
"extends the equivalence relation of convertibility into a *subtyping* "
"relation inductively defined by:"
msgstr ""

#: ../../language/cic.rst:610
msgid "if :math:`E[Γ] ⊢ t =_{βδιζη} u` then :math:`E[Γ] ⊢ t ≤_{βδιζη} u`,"
msgstr ""

#: ../../language/cic.rst:611
msgid "if :math:`i ≤ j` then :math:`E[Γ] ⊢ \\Type(i) ≤_{βδιζη} \\Type(j)`,"
msgstr ""

#: ../../language/cic.rst:612
msgid "for any :math:`i`, :math:`E[Γ] ⊢ \\Set ≤_{βδιζη} \\Type(i)`,"
msgstr ""

#: ../../language/cic.rst:613
msgid ""
":math:`E[Γ] ⊢ \\Prop ≤_{βδιζη} \\Set`, hence, by transitivity, :math:`E[Γ] ⊢ "
"\\Prop ≤_{βδιζη} \\Type(i)`, for any :math:`i`"
msgstr ""

#: ../../language/cic.rst:615
msgid ""
"if :math:`E[Γ] ⊢ T =_{βδιζη} U` and :math:`E[Γ::(x:T)] ⊢ T' ≤_{βδιζη} U'` "
"then :math:`E[Γ] ⊢ ∀x:T, T′ ≤_{βδιζη} ∀ x:U, U′`."
msgstr ""

#: ../../language/cic.rst:618
msgid ""
"if :math:`\\ind{p}{Γ_I}{Γ_C}` is a universe polymorphic and cumulative (see "
"Chapter :ref:`polymorphicuniverses`) inductive type (see below) and :math:"
"`(t : ∀Γ_P ,∀Γ_{\\mathit{Arr}(t)}, \\Sort)∈Γ_I` and :math:`(t' : ∀Γ_P' ,"
"∀Γ_{\\mathit{Arr}(t)}', \\Sort')∈Γ_I` are two different instances of *the "
"same* inductive type (differing only in universe levels) with constructors"
msgstr ""

#: ../../language/cic.rst:637
msgid "respectively then"
msgstr ""

#: ../../language/cic.rst:642
msgid ""
"(notice that :math:`t` and :math:`t'` are both fully applied, i.e., they "
"have a sort as a type) if"
msgstr ""

#: ../../language/cic.rst:648
msgid "for :math:`1 ≤ i ≤ m` and we have"
msgstr ""

#: ../../language/cic.rst:659
msgid ""
"where :math:`Γ_{\\mathit{Arr}(t)} = [a_1 : A_1 ;  … ; a_l : A_l ]` and :math:"
"`Γ_{\\mathit{Arr}(t)}' = [a_1 : A_1';  … ; a_l : A_l']`."
msgstr ""

#: ../../language/cic.rst:663
msgid "The conversion rule up to subtyping is now exactly:"
msgstr ""

#: ../../language/cic.rst:676
msgid ""
"**Normal form**. A term which cannot be any more reduced is said to be in "
"*normal form*. There are several ways (or strategies) to apply the reduction "
"rules. Among them, we have to mention the *head reduction* which will play "
"an important role (see Chapter :ref:`tactics`). Any term :math:`t` can be "
"written as :math:`λ x_1 :T_1 . … λ x_k :T_k . (t_0~t_1 … t_n )` where :math:"
"`t_0` is not an application. We say then that :math:`t~0` is the *head of* :"
"math:`t`. If we assume that :math:`t_0` is :math:`λ x:T. u_0` then one step "
"of β-head reduction of :math:`t` is:"
msgstr ""

#: ../../language/cic.rst:688
msgid ""
"Iterating the process of head reduction until the head of the reduced term "
"is no more an abstraction leads to the *β-head normal form* of :math:`t`:"
msgstr ""

#: ../../language/cic.rst:694
msgid ""
"where :math:`v` is not an abstraction (nor an application). Note that the "
"head normal form must not be confused with the normal form since some :math:"
"`u_i` can be reducible. Similar notions of head-normal forms involving δ, ι "
"and ζ reductions or any combination of those can also be defined."
msgstr ""

#: ../../language/cic.rst:703
msgid "Inductive Definitions"
msgstr ""

#: ../../language/cic.rst:705
msgid ""
"Formally, we can represent any *inductive definition* as :math:`\\ind{p}{Γ_I}"
"{Γ_C}` where:"
msgstr ""

#: ../../language/cic.rst:708
msgid ":math:`Γ_I` determines the names and types of inductive types;"
msgstr ""

#: ../../language/cic.rst:709
msgid ""
":math:`Γ_C` determines the names and types of constructors of these "
"inductive types;"
msgstr ""

#: ../../language/cic.rst:711
msgid ":math:`p` determines the number of parameters of these inductive types."
msgstr ""

#: ../../language/cic.rst:714
msgid ""
"These inductive definitions, together with global assumptions and global "
"definitions, then form the global environment. Additionally, for any :math:"
"`p` there always exists :math:`Γ_P =[a_1 :A_1 ;…;a_p :A_p ]` such that each :"
"math:`T` in :math:`(t:T)∈Γ_I \\cup Γ_C` can be written as: :math:`∀Γ_P , T'` "
"where :math:`Γ_P` is called the *context of parameters*. Furthermore, we "
"must have that each :math:`T` in :math:`(t:T)∈Γ_I` can be written as: :math:"
"`∀Γ_P,∀Γ_{\\mathit{Arr}(t)}, S` where :math:`Γ_{\\mathit{Arr}(t)}` is called "
"the *Arity* of the inductive type t and :math:`S` is called the sort of the "
"inductive type t (not to be confused with :math:`\\Sort` which is the set of "
"sorts)."
msgstr ""

#: ../../language/cic.rst:723 ../../language/cic.rst:742
#: ../../language/cic.rst:765 ../../language/cic.rst:814
#: ../../language/cic.rst:847 ../../language/cic.rst:859
#: ../../language/cic.rst:872 ../../language/cic.rst:923
#: ../../language/cic.rst:990 ../../language/cic.rst:1108
#: ../../language/cic.rst:1125 ../../language/cic.rst:1134
#: ../../language/cic.rst:1145 ../../language/cic.rst:1334
#: ../../language/cic.rst:1345 ../../language/cic.rst:1369
#: ../../language/cic.rst:1403 ../../language/cic.rst:1435
#: ../../language/cic.rst:1502 ../../language/cic.rst:1652
#: ../../language/cic.rst:1831 ../../language/coq-library.rst:529
#: ../../language/coq-library.rst:848 ../../language/coq-library.rst:888
#: ../../language/coq-library.rst:908 ../../language/coq-library.rst:922
#: ../../language/coq-library.rst:937 ../../language/gallina-extensions.rst:46
#: ../../language/gallina-extensions.rst:70
#: ../../language/gallina-extensions.rst:155
#: ../../language/gallina-extensions.rst:373
#: ../../language/gallina-extensions.rst:573
#: ../../language/gallina-extensions.rst:773
#: ../../language/gallina-extensions.rst:967
#: ../../language/gallina-extensions.rst:1153
#: ../../language/gallina-extensions.rst:1180
#: ../../language/gallina-extensions.rst:1292
#: ../../language/gallina-extensions.rst:1609
#: ../../language/gallina-extensions.rst:1667
#: ../../language/gallina-extensions.rst:1923
#: ../../language/gallina-extensions.rst:1971
#: ../../language/gallina-extensions.rst:1995
#: ../../language/gallina-specification-language.rst:778
#: ../../language/gallina-specification-language.rst:818
#: ../../language/gallina-specification-language.rst:832
#: ../../language/gallina-specification-language.rst:874
#: ../../language/gallina-specification-language.rst:971
#: ../../language/gallina-specification-language.rst:1044
#: ../../language/gallina-specification-language.rst:1064
#: ../../language/gallina-specification-language.rst:1127
#: ../../language/gallina-specification-language.rst:1151
#: ../../language/gallina-specification-language.rst:1175
#: ../../language/gallina-specification-language.rst:1200
msgid "Example"
msgstr ""

#: ../../language/cic.rst:725
msgid "The declaration for parameterized lists is:"
msgstr ""

#: ../../language/cic.rst:734 ../../language/cic.rst:755
#: ../../language/cic.rst:778
msgid "which corresponds to the result of the |Coq| declaration:"
msgstr ""

#: ../../language/cic.rst:744
msgid ""
"The declaration for a mutual inductive definition of tree and forest is:"
msgstr ""

#: ../../language/cic.rst:767
msgid "The declaration for a mutual inductive definition of even and odd is:"
msgstr ""

#: ../../language/cic.rst:793
msgid "Types of inductive objects"
msgstr ""

#: ../../language/cic.rst:795
msgid ""
"We have to give the type of constants in a global environment E which "
"contains an inductive declaration."
msgstr ""

#: ../../language/cic.rst:816
msgid ""
"Provided that our environment :math:`E` contains inductive definitions we "
"showed before, these two inference rules above enable us to conclude that:"
msgstr ""

#: ../../language/cic.rst:834
msgid "Well-formed inductive definitions"
msgstr ""

#: ../../language/cic.rst:836
msgid ""
"We cannot accept any inductive declaration because some of them lead to "
"inconsistent systems. We restrict ourselves to definitions which satisfy a "
"syntactic criterion of positivity. Before giving the formal rules, we need a "
"few definitions:"
msgstr ""

#: ../../language/cic.rst:842
msgid "Arity of a given sort"
msgstr ""

#: ../../language/cic.rst:844
msgid ""
"A type :math:`T` is an *arity of sort* :math:`s` if it converts to the sort :"
"math:`s` or to a product :math:`∀ x:T,U` with :math:`U` an arity of sort :"
"math:`s`."
msgstr ""

#: ../../language/cic.rst:849
msgid ""
":math:`A→\\Set` is an arity of sort :math:`\\Set`. :math:`∀ A:\\Prop,A→ "
"\\Prop` is an arity of sort :math:`\\Prop`."
msgstr ""

#: ../../language/cic.rst:854
msgid "Arity"
msgstr ""

#: ../../language/cic.rst:855
msgid ""
"A type :math:`T` is an *arity* if there is a :math:`s∈ \\Sort` such that :"
"math:`T` is an arity of sort :math:`s`."
msgstr ""

#: ../../language/cic.rst:861
msgid ":math:`A→ Set` and :math:`∀ A:\\Prop,A→ \\Prop` are arities."
msgstr ""

#: ../../language/cic.rst:865
msgid "Type constructor"
msgstr ""

#: ../../language/cic.rst:866
msgid ""
"We say that T is a *type of constructor of I* in one of the following two "
"cases:"
msgstr ""

#: ../../language/cic.rst:869
msgid ":math:`T` is :math:`(I~t_1 … t_n )`"
msgstr ""

#: ../../language/cic.rst:870
msgid ""
":math:`T` is :math:`∀ x:U,T'` where :math:`T'` is also a type of constructor "
"of :math:`I`"
msgstr ""

#: ../../language/cic.rst:874
msgid ""
":math:`\\nat` and :math:`\\nat→\\nat` are types of constructor of :math:`"
"\\nat`. :math:`∀ A:Type,\\List~A` and :math:`∀ A:Type,A→\\List~A→\\List~A` "
"are types of constructor of :math:`\\List`."
msgstr ""

#: ../../language/cic.rst:880
msgid "Positivity Condition"
msgstr ""

#: ../../language/cic.rst:882
msgid ""
"The type of constructor :math:`T` will be said to *satisfy the positivity "
"condition* for a constant :math:`X` in the following cases:"
msgstr ""

#: ../../language/cic.rst:885
msgid ""
":math:`T=(X~t_1 … t_n )` and :math:`X` does not occur free in any :math:`t_i`"
msgstr ""

#: ../../language/cic.rst:886
msgid ""
":math:`T=∀ x:U,V` and :math:`X` occurs only strictly positively in :math:`U` "
"and the type :math:`V` satisfies the positivity condition for :math:`X`."
msgstr ""

#: ../../language/cic.rst:890
msgid "Strict positivity"
msgstr ""

#: ../../language/cic.rst:892
msgid ""
"The constant :math:`X` *occurs strictly positively* in :math:`T` in the "
"following cases:"
msgstr ""

#: ../../language/cic.rst:896
msgid ":math:`X` does not occur in :math:`T`"
msgstr ""

#: ../../language/cic.rst:897
msgid ""
":math:`T` converts to :math:`(X~t_1 … t_n )` and :math:`X` does not occur in "
"any of :math:`t_i`"
msgstr ""

#: ../../language/cic.rst:898
msgid ""
":math:`T` converts to :math:`∀ x:U,V` and :math:`X` does not occur in type :"
"math:`U` but occurs strictly positively in type :math:`V`"
msgstr ""

#: ../../language/cic.rst:900
msgid ""
":math:`T` converts to :math:`(I~a_1 … a_m~t_1 … t_p )` where :math:`I` is "
"the name of an inductive declaration of the form"
msgstr ""

#: ../../language/cic.rst:906
msgid ""
"(in particular, it is not mutually defined and it has :math:`m` parameters) "
"and :math:`X` does not occur in any of the :math:`t_i`, and the "
"(instantiated) types of constructor :math:`\\subst{C_i}{p_j}{a_j}_{j=1… m}` "
"of :math:`I` satisfy the nested positivity condition for :math:`X`"
msgstr ""

#: ../../language/cic.rst:912
msgid "Nested Positivity"
msgstr ""

#: ../../language/cic.rst:914
msgid ""
"The type of constructor :math:`T` of :math:`I` *satisfies the nested "
"positivity condition* for a constant :math:`X` in the following cases:"
msgstr ""

#: ../../language/cic.rst:917
msgid ""
":math:`T=(I~b_1 … b_m~u_1 … u_p)`, :math:`I` is an inductive definition "
"with :math:`m` parameters and :math:`X` does not occur in any :math:`u_i`"
msgstr ""

#: ../../language/cic.rst:919
msgid ""
":math:`T=∀ x:U,V` and :math:`X` occurs only strictly positively in :math:`U` "
"and the type :math:`V` satisfies the nested positivity condition for :math:"
"`X`"
msgstr ""

#: ../../language/cic.rst:925
msgid ""
"For instance, if one considers the following variant of a tree type "
"branching over the natural numbers:"
msgstr ""

#: ../../language/cic.rst:935
msgid ""
"Then every instantiated constructor of ``nattree A`` satisfies the nested "
"positivity condition for ``nattree``:"
msgstr ""

#: ../../language/cic.rst:938
msgid ""
"Type ``nattree A`` of constructor ``leaf`` satisfies the positivity "
"condition for ``nattree`` because ``nattree`` does not appear in any (real) "
"arguments of the type of that constructor (primarily because ``nattree`` "
"does not have any (real) arguments) ... (bullet 1)"
msgstr ""

#: ../../language/cic.rst:943
msgid ""
"Type ``A → (nat → nattree A) → nattree A`` of constructor ``node`` satisfies "
"the positivity condition for ``nattree`` because:"
msgstr ""

#: ../../language/cic.rst:946
msgid "``nattree`` occurs only strictly positively in ``A`` ... (bullet 3)"
msgstr ""

#: ../../language/cic.rst:948
msgid ""
"``nattree`` occurs only strictly positively in ``nat → nattree A`` ... "
"(bullet 3 + 2)"
msgstr ""

#: ../../language/cic.rst:950
msgid ""
"``nattree`` satisfies the positivity condition for ``nattree A`` ... (bullet "
"1)"
msgstr ""

#: ../../language/cic.rst:955
msgid "Correctness rules"
msgstr ""

#: ../../language/cic.rst:957
msgid ""
"We shall now describe the rules allowing the introduction of a new inductive "
"definition."
msgstr ""

#: ../../language/cic.rst:960
msgid ""
"Let :math:`E` be a global environment and :math:`Γ_P`, :math:`Γ_I`, :math:"
"`Γ_C` be contexts such that :math:`Γ_I` is :math:`[I_1 :∀ Γ_P ,A_1 ;…;I_k :∀ "
"Γ_P ,A_k]`, and :math:`Γ_C` is :math:`[c_1:∀ Γ_P ,C_1 ;…;c_n :∀ Γ_P ,C_n ]`. "
"Then"
msgstr ""

#: ../../language/cic.rst:973 ../../language/cic.rst:1058
msgid "provided that the following side conditions hold:"
msgstr ""

#: ../../language/cic.rst:975
msgid ""
":math:`k>0` and all of :math:`I_j` and :math:`c_i` are distinct names for :"
"math:`j=1… k` and :math:`i=1… n`,"
msgstr ""

#: ../../language/cic.rst:976
msgid ""
":math:`p` is the number of parameters of :math:`\\ind{p}{Γ_I}{Γ_C}` and :"
"math:`Γ_P` is the context of parameters,"
msgstr ""

#: ../../language/cic.rst:978
msgid ""
"for :math:`j=1… k` we have that :math:`A_j` is an arity of sort :math:`s_j` "
"and :math:`I_j ∉ E`,"
msgstr ""

#: ../../language/cic.rst:979
msgid ""
"for :math:`i=1… n` we have that :math:`C_i` is a type of constructor of :"
"math:`I_{q_i}` which satisfies the positivity condition for :math:`I_1 … "
"I_k` and :math:`c_i ∉ Γ ∪ E`."
msgstr ""

#: ../../language/cic.rst:982
msgid ""
"One can remark that there is a constraint between the sort of the arity of "
"the inductive type and the sort of the type of its constructors which will "
"always be satisfied for the impredicative sort :math:`\\Prop` but may fail "
"to define inductive definition on sort :math:`\\Set` and generate "
"constraints between universes for inductive definitions in the Type "
"hierarchy."
msgstr ""

#: ../../language/cic.rst:992
msgid ""
"It is well known that the existential quantifier can be encoded as an "
"inductive definition. The following declaration introduces the second- order "
"existential quantifier :math:`∃ X.P(X)`."
msgstr ""

#: ../../language/cic.rst:1001
msgid "The same definition on :math:`\\Set` is not allowed and fails:"
msgstr ""

#: ../../language/cic.rst:1008
msgid ""
"It is possible to declare the same inductive definition in the universe :"
"math:`\\Type`. The :g:`exType` inductive definition has type :math:"
"`(\\Type(i)→\\Prop)→\\Type(j)` with the constraint that the parameter :math:"
"`X` of :math:`\\kw{exT}_{\\kw{intro}}` has type :math:`\\Type(k)` with :math:"
"`k<j` and :math:`k≤ i`."
msgstr ""

#: ../../language/cic.rst:1023
msgid "Template polymorphism"
msgstr ""

#: ../../language/cic.rst:1025
msgid ""
"Inductive types declared in :math:`\\Type` are polymorphic over their "
"arguments in :math:`\\Type`. If :math:`A` is an arity of some sort and :math:"
"`s` is a sort, we write :math:`A_{/s}` for the arity obtained from :math:`A` "
"by replacing its sort with :math:`s`. Especially, if :math:`A` is well-typed "
"in some global environment and local context, then :math:`A_{/s}` is typable "
"by typability of all products in the Calculus of Inductive Constructions. "
"The following typing rule is added to the theory."
msgstr ""

#: ../../language/cic.rst:1033
msgid ""
"Let :math:`\\ind{p}{Γ_I}{Γ_C}` be an inductive definition. Let :math:`Γ_P = "
"[p_1 :P_1 ;…;p_p :P_p ]` be its context of parameters, :math:`Γ_I = [I_1:∀ "
"Γ_P ,A_1 ;…;I_k :∀ Γ_P ,A_k ]` its context of definitions and :math:`Γ_C = "
"[c_1 :∀ Γ_P ,C_1 ;…;c_n :∀ Γ_P ,C_n]` its context of constructors, with :"
"math:`c_i` a constructor of :math:`I_{q_i}`. Let :math:`m ≤ p` be the length "
"of the longest prefix of parameters such that the :math:`m` first arguments "
"of all occurrences of all :math:`I_j` in all :math:`C_k` (even the "
"occurrences in the hypotheses of :math:`C_k`) are exactly applied to :math:"
"`p_1 … p_m` (:math:`m` is the number of *recursively uniform parameters* and "
"the :math:`p−m` remaining parameters are the *recursively non-uniform "
"parameters*). Let :math:`q_1 , …, q_r` , with :math:`0≤ r≤ m`, be a "
"(possibly) partial instantiation of the recursively uniform parameters of :"
"math:`Γ_P` . We have:"
msgstr ""

#: ../../language/cic.rst:1060
msgid ""
":math:`Γ_{P′}` is the context obtained from :math:`Γ_P` by replacing each :"
"math:`P_l` that is an arity with :math:`P_l'` for :math:`1≤ l ≤ r` (notice "
"that :math:`P_l` arity implies :math:`P_l'` arity since :math:`(E[] ⊢ P_l' "
"≤_{βδιζη} \\subst{P_l}{p_u}{q_u}_{u=1\\ldots l-1} )`;"
msgstr ""

#: ../../language/cic.rst:1063
msgid ""
"there are sorts :math:`s_i` , for :math:`1 ≤ i ≤ k` such that, for :math:"
"`Γ_{I'} = [I_1 :∀ Γ_{P'} ,(A_1)_{/s_1} ;…;I_k :∀ Γ_{P'} ,(A_k)_{/s_k}]` we "
"have :math:`(E[Γ_{I′} ;Γ_{P′}] ⊢ C_i : s_{q_i})_{i=1… n}` ;"
msgstr ""

#: ../../language/cic.rst:1066
msgid ""
"the sorts :math:`s_i` are such that all eliminations, to :math:`\\Prop`, :"
"math:`\\Set` and :math:`\\Type(j)`, are allowed (see Section :ref:"
"`Destructors`)."
msgstr ""

#: ../../language/cic.rst:1072
msgid ""
"Notice that if :math:`I_j~q_1 … q_r` is typable using the rules **Ind-"
"Const** and **App**, then it is typable using the rule **Ind-Family**. "
"Conversely, the extended theory is not stronger than the theory without "
"**Ind-Family**. We get an equiconsistency result by mapping each :math:`"
"\\ind{p}{Γ_I}{Γ_C}` occurring into a given derivation into as many different "
"inductive types and constructors as the number of different (partial) "
"replacements of sorts, needed for this derivation, in the parameters that "
"are arities (this is possible because :math:`\\ind{p}{Γ_I}{Γ_C}` well-formed "
"implies that :math:`\\ind{p}{Γ_{I'}}{Γ_{C'}}` is well-formed and has the "
"same allowed eliminations, where :math:`Γ_{I′}` is defined as above and :"
"math:`Γ_{C′} = [c_1 :∀ Γ_{P′} ,C_1 ;…;c_n :∀ Γ_{P′} ,C_n ]`). That is, the "
"changes in the types of each partial instance :math:`q_1 … q_r` can be "
"characterized by the ordered sets of arity sorts among the types of "
"parameters, and to each signature is associated a new inductive definition "
"with fresh names. Conversion is preserved as any (partial) instance :math:"
"`I_j~q_1 … q_r` or :math:`C_i~q_1 … q_r` is mapped to the names chosen in "
"the specific instance of :math:`\\ind{p}{Γ_I}{Γ_C}`."
msgstr ""

#: ../../language/cic.rst:1090
msgid ""
"In practice, the rule **Ind-Family** is used by |Coq| only when all the "
"inductive types of the inductive definition are declared with an arity whose "
"sort is in the Type hierarchy. Then, the polymorphism is over the parameters "
"whose type is an arity of sort in the Type hierarchy. The sorts :math:`s_j` "
"are chosen canonically so that each :math:`s_j` is minimal with respect to "
"the hierarchy :math:`\\Prop ⊂ \\Set_p ⊂ \\Type` where :math:`\\Set_p` is "
"predicative :math:`\\Set`. More precisely, an empty or small singleton "
"inductive definition (i.e. an inductive definition of which all inductive "
"types are singleton – see Section :ref:`Destructors`) is set in :math:`"
"\\Prop`, a small non-singleton inductive type is set in :math:`\\Set` (even "
"in case :math:`\\Set` is impredicative – see Section The-Calculus-of-"
"Inductive-Construction-with-impredicative-Set_), and otherwise in the Type "
"hierarchy."
msgstr ""

#: ../../language/cic.rst:1103
msgid ""
"Note that the side-condition about allowed elimination sorts in the rule "
"**Ind-Family** is just to avoid to recompute the allowed elimination sorts "
"at each instance of a pattern matching (see Section :ref:`Destructors`). As "
"an example, let us consider the following definition:"
msgstr ""

#: ../../language/cic.rst:1116
msgid ""
"As the definition is set in the Type hierarchy, it is used polymorphically "
"over its parameters whose types are arities of a sort in the Type hierarchy. "
"Here, the parameter :math:`A` has this property, hence, if :g:`option` is "
"applied to a type in :math:`\\Set`, the result is in :math:`\\Set`. Note "
"that if :g:`option` is applied to a type in :math:`\\Prop`, then, the result "
"is not set in :math:`\\Prop` but in :math:`\\Set` still. This is because :g:"
"`option` is not a singleton type (see Section :ref:`Destructors`) and it "
"would lose the elimination to :math:`\\Set` and :math:`\\Type` if set in :"
"math:`\\Prop`."
msgstr ""

#: ../../language/cic.rst:1132
msgid "Here is another example."
msgstr ""

#: ../../language/cic.rst:1140
msgid ""
"As :g:`prod` is a singleton type, it will be in :math:`\\Prop` if applied "
"twice to propositions, in :math:`\\Set` if applied twice to at least one "
"type in :math:`\\Set` and none in :math:`\\Type`, and in :math:`\\Type` "
"otherwise. In all cases, the three kind of eliminations schemes are allowed."
msgstr ""

#: ../../language/cic.rst:1155
msgid ""
"Template polymorphism used to be called “sort-polymorphism of inductive "
"types” before universe polymorphism (see Chapter :ref:"
"`polymorphicuniverses`) was introduced."
msgstr ""

#: ../../language/cic.rst:1163
msgid "Destructors"
msgstr ""

#: ../../language/cic.rst:1165
msgid ""
"The specification of inductive definitions with arities and constructors is "
"quite natural. But we still have to say how to use an object in an inductive "
"type."
msgstr ""

#: ../../language/cic.rst:1169
msgid ""
"This problem is rather delicate. There are actually several different ways "
"to do that. Some of them are logically equivalent but not always equivalent "
"from the computational point of view or from the user point of view."
msgstr ""

#: ../../language/cic.rst:1174
msgid ""
"From the computational point of view, we want to be able to define a "
"function whose domain is an inductively defined type by using a combination "
"of case analysis over the possible constructors of the object and recursion."
msgstr ""

#: ../../language/cic.rst:1179
msgid ""
"Because we need to keep a consistent theory and also we prefer to keep a "
"strongly normalizing reduction, we cannot accept any sort of recursion (even "
"terminating). So the basic idea is to restrict ourselves to primitive "
"recursive functions and functionals."
msgstr ""

#: ../../language/cic.rst:1184
msgid ""
"For instance, assuming a parameter :g:`A:Set` exists in the local context, "
"we want to build a function length of type :g:`list A -> nat` which computes "
"the length of the list, such that :g:`(length (nil A)) = O` and :g:`(length "
"(cons A a l)) = (S (length l))`. We want these equalities to be recognized "
"implicitly and taken into account in the conversion rule."
msgstr ""

#: ../../language/cic.rst:1190
msgid ""
"From the logical point of view, we have built a type family by giving a set "
"of constructors. We want to capture the fact that we do not have any other "
"way to build an object in this type. So when trying to prove a property "
"about an object :math:`m` in an inductive definition it is enough to "
"enumerate all the cases where :math:`m` starts with a different constructor."
msgstr ""

#: ../../language/cic.rst:1197
msgid ""
"In case the inductive definition is effectively a recursive one, we want to "
"capture the extra property that we have built the smallest fixed point of "
"this recursive equation. This says that we are only manipulating finite "
"objects. This analysis provides induction principles. For instance, in order "
"to prove :g:`∀ l:list A,(has_length A l (length l))` it is enough to prove:"
msgstr ""

#: ../../language/cic.rst:1205
msgid ":g:`(has_length A (nil A) (length (nil A)))`"
msgstr ""

#: ../../language/cic.rst:1206
msgid ""
":g:`∀ a:A, ∀ l:list A, (has_length A l (length l)) →` :g:`(has_length A "
"(cons A a l) (length (cons A a l)))`"
msgstr ""

#: ../../language/cic.rst:1210
msgid ""
"which given the conversion equalities satisfied by length is the same as "
"proving:"
msgstr ""

#: ../../language/cic.rst:1214
msgid ":g:`(has_length A (nil A) O)`"
msgstr ""

#: ../../language/cic.rst:1215
msgid ""
":g:`∀ a:A, ∀ l:list A, (has_length A l (length l)) →` :g:`(has_length A "
"(cons A a l) (S (length l)))`"
msgstr ""

#: ../../language/cic.rst:1219
msgid ""
"One conceptually simple way to do that, following the basic scheme proposed "
"by Martin-Löf in his Intuitionistic Type Theory, is to introduce for each "
"inductive definition an elimination operator. At the logical level it is a "
"proof of the usual induction principle and at the computational level it "
"implements a generic operator for doing primitive recursion over the "
"structure."
msgstr ""

#: ../../language/cic.rst:1226
msgid ""
"But this operator is rather tedious to implement and use. We choose in this "
"version of |Coq| to factorize the operator for primitive recursion into two "
"more primitive operations as was first suggested by Th. Coquand in :cite:"
"`Coq92`. One is the definition by pattern matching. The second one is a "
"definition by guarded fixpoints."
msgstr ""

#: ../../language/cic.rst:1236
msgid "The match ... with ... end construction"
msgstr ""

#: ../../language/cic.rst:1238
msgid ""
"The basic idea of this operator is that we have an object :math:`m` in an "
"inductive type :math:`I` and we want to prove a property which possibly "
"depends on :math:`m`. For this, it is enough to prove the property for :math:"
"`m = (c_i~u_1 … u_{p_i} )` for each constructor of :math:`I`. The |Coq| term "
"for this proof will be written:"
msgstr ""

#: ../../language/cic.rst:1248
msgid ""
"In this expression, if :math:`m` eventually happens to evaluate to :math:"
"`(c_i~u_1 … u_{p_i})` then the expression will behave as specified in its :"
"math:`i`-th branch and it will reduce to :math:`f_i` where the :math:`x_{i1} "
"…x_{ip_i}` are replaced by the :math:`u_1 … u_{p_i}` according to the ι-"
"reduction."
msgstr ""

#: ../../language/cic.rst:1253
msgid ""
"Actually, for type checking a :math:`\\Match…\\with…\\kwend` expression we "
"also need to know the predicate P to be proved by case analysis. In the "
"general case where :math:`I` is an inductively defined :math:`n`-ary "
"relation, :math:`P` is a predicate over :math:`n+1` arguments: the :math:`n` "
"first ones correspond to the arguments of :math:`I` (parameters excluded), "
"and the last one corresponds to object :math:`m`. |Coq| can sometimes infer "
"this predicate but sometimes not. The concrete syntax for describing this "
"predicate uses the :math:`\\as…\\In…\\return` construction. For instance, "
"let us assume that :math:`I` is an unary predicate with one parameter and "
"one argument. The predicate is made explicit using the syntax:"
msgstr ""

#: ../../language/cic.rst:1269
msgid ""
"The :math:`\\as` part can be omitted if either the result type does not "
"depend on :math:`m` (non-dependent elimination) or :math:`m` is a variable "
"(in this case, :math:`m` can occur in :math:`P` where it is considered a "
"bound variable). The :math:`\\In` part can be omitted if the result type "
"does not depend on the arguments of :math:`I`. Note that the arguments of :"
"math:`I` corresponding to parameters *must* be :math:`\\_`, because the "
"result type is not generalized to all possible values of the parameters. The "
"other arguments of :math:`I` (sometimes called indices in the literature) "
"have to be variables (:math:`a` above) and these variables can occur in :"
"math:`P`. The expression after :math:`\\In` must be seen as an *inductive "
"type pattern*. Notice that expansion of implicit arguments and notations "
"apply to this pattern. For the purpose of presenting the inference rules, we "
"use a more compact notation:"
msgstr ""

#: ../../language/cic.rst:1288
msgid ""
"**Allowed elimination sorts.** An important question for building the typing "
"rule for match is what can be the type of :math:`λ a x . P` with respect to "
"the type of :math:`m`. If :math:`m:I` and :math:`I:A` and :math:`λ a x . P : "
"B` then by :math:`[I:A|B]` we mean that one can use :math:`λ a x . P` with :"
"math:`m` in the above match-construct."
msgstr ""

#: ../../language/cic.rst:1296
msgid ""
"**Notations.** The :math:`[I:A|B]` is defined as the smallest relation "
"satisfying the following rules: We write :math:`[I|B]` for :math:`[I:A|B]` "
"where :math:`A` is the type of :math:`I`."
msgstr ""

#: ../../language/cic.rst:1299
msgid ""
"The case of inductive definitions in sorts :math:`\\Set` or :math:`\\Type` "
"is simple. There is no restriction on the sort of the predicate to be "
"eliminated."
msgstr ""

#: ../../language/cic.rst:1317
msgid ""
"The case of Inductive definitions of sort :math:`\\Prop` is a bit more "
"complicated, because of our interpretation of this sort. The only harmless "
"allowed elimination, is the one when predicate :math:`P` is also of sort :"
"math:`\\Prop`."
msgstr ""

#: ../../language/cic.rst:1329
msgid ""
":math:`\\Prop` is the type of logical propositions, the proofs of "
"properties :math:`P` in :math:`\\Prop` could not be used for computation and "
"are consequently ignored by the extraction mechanism. Assume :math:`A` and :"
"math:`B` are two propositions, and the logical disjunction :math:`A ∨ B` is "
"defined inductively by:"
msgstr ""

#: ../../language/cic.rst:1342
msgid ""
"The following definition which computes a boolean value by case over the "
"proof of :g:`or A B` is not accepted:"
msgstr ""

#: ../../language/cic.rst:1352
msgid ""
"From the computational point of view, the structure of the proof of :g:`(or "
"A B)` in this term is needed for computing the boolean value."
msgstr ""

#: ../../language/cic.rst:1355
msgid ""
"In general, if :math:`I` has type :math:`\\Prop` then :math:`P` cannot have "
"type :math:`I→Set,` because it will mean to build an informative proof of "
"type :math:`(P~m)` doing a case analysis over a non-computational object "
"that will disappear in the extracted program. But the other way is safe with "
"respect to our interpretation we can have :math:`I` a computational object "
"and :math:`P` a non-computational one, it just corresponds to proving a "
"logical property of a computational object."
msgstr ""

#: ../../language/cic.rst:1363
msgid ""
"In the same spirit, elimination on :math:`P` of type :math:`I→Type` cannot "
"be allowed because it trivially implies the elimination on :math:`P` of "
"type :math:`I→ Set` by cumulativity. It also implies that there are two "
"proofs of the same property which are provably different, contradicting the "
"proof- irrelevance property which is sometimes a useful axiom:"
msgstr ""

#: ../../language/cic.rst:1375
msgid ""
"The elimination of an inductive definition of type :math:`\\Prop` on a "
"predicate :math:`P` of type :math:`I→ Type` leads to a paradox when applied "
"to impredicative inductive definition like the second-order existential "
"quantifier :g:`exProp` defined above, because it gives access to the two "
"projections on this type."
msgstr ""

#: ../../language/cic.rst:1384
msgid ""
"**Empty and singleton elimination.** There are special inductive definitions "
"in :math:`\\Prop` for which more eliminations are allowed."
msgstr ""

#: ../../language/cic.rst:1394
msgid ""
"A *singleton definition* has only one constructor and all the arguments of "
"this constructor have type :math:`\\Prop`. In that case, there is a "
"canonical way to interpret the informative extraction on an object in that "
"type, such that the elimination on any sort :math:`s` is legal. Typical "
"examples are the conjunction of non-informative propositions and the "
"equality. If there is a hypothesis :math:`h:a=b` in the local context, it "
"can be used for rewriting not only in logical propositions but also in any "
"type."
msgstr ""

#: ../../language/cic.rst:1411
msgid ""
"An empty definition has no constructors, in that case also, elimination on "
"any sort is allowed."
msgstr ""

#: ../../language/cic.rst:1417
msgid ""
"**Type of branches.** Let :math:`c` be a term of type :math:`C`, we assume :"
"math:`C` is a type of constructor for an inductive type :math:`I`. Let :math:"
"`P` be a term that represents the property to be proved. We assume :math:`r` "
"is the number of parameters and :math:`p` is the number of arguments."
msgstr ""

#: ../../language/cic.rst:1423
msgid ""
"We define a new type :math:`\\{c:C\\}^P` which represents the type of the "
"branch corresponding to the :math:`c:C` constructor."
msgstr ""

#: ../../language/cic.rst:1432
msgid ""
"We write :math:`\\{c\\}^P` for :math:`\\{c:C\\}^P` with :math:`C` the type "
"of :math:`c`."
msgstr ""

#: ../../language/cic.rst:1437
msgid "The following term in concrete syntax::"
msgstr ""

#: ../../language/cic.rst:1445
msgid "can be represented in abstract syntax as"
msgstr ""

#: ../../language/cic.rst:1450
msgid "where"
msgstr ""

#: ../../language/cic.rst:1461
msgid "According to the definition:"
msgstr ""

#: ../../language/cic.rst:1475
msgid ""
"Given some :math:`P` then :math:`\\{(\\kw{nil}~\\nat)\\}^P` represents the "
"expected type of :math:`f_1` , and :math:`\\{(\\kw{cons}~\\nat)\\}^P` "
"represents the expected type of :math:`f_2`."
msgstr ""

#: ../../language/cic.rst:1481
msgid ""
"**Typing rule.** Our very general destructor for inductive definition enjoys "
"the following typing rule"
msgstr ""

#: ../../language/cic.rst:1496
msgid ""
"provided :math:`I` is an inductive type in a definition :math:`\\ind{r}{Γ_I}"
"{Γ_C}` with :math:`Γ_C = [c_1 :C_1 ;…;c_n :C_n ]` and :math:`c_{p_1} … "
"c_{p_l}` are the only constructors of :math:`I`."
msgstr ""

#: ../../language/cic.rst:1504
msgid "Below is a typing rule for the term shown in the previous example:"
msgstr ""

#: ../../language/cic.rst:1521
msgid ""
"**Definition of ι-reduction.** We still have to define the ι-reduction in "
"the general case."
msgstr ""

#: ../../language/cic.rst:1524
msgid "An ι-redex is a term of the following form:"
msgstr ""

#: ../../language/cic.rst:1529
msgid ""
"with :math:`c_{p_i}` the :math:`i`-th constructor of the inductive type :"
"math:`I` with :math:`r` parameters."
msgstr ""

#: ../../language/cic.rst:1532
msgid ""
"The ι-contraction of this term is :math:`(f_i~a_1 … a_m )` leading to the "
"general reduction rule:"
msgstr ""

#: ../../language/cic.rst:1542
msgid "Fixpoint definitions"
msgstr ""

#: ../../language/cic.rst:1544
msgid ""
"The second operator for elimination is fixpoint definition. This fixpoint "
"may involve several mutually recursive definitions. The basic concrete "
"syntax for a recursive set of mutually recursive declarations is (with :math:"
"`Γ_i` contexts):"
msgstr ""

#: ../../language/cic.rst:1553
msgid ""
"The terms are obtained by projections from this set of declarations and are "
"written"
msgstr ""

#: ../../language/cic.rst:1559
msgid "In the inference rules, we represent such a term by"
msgstr ""

#: ../../language/cic.rst:1564
msgid ""
"with :math:`t_i'` (resp. :math:`A_i'`) representing the term :math:`t_i` "
"abstracted (resp. generalized) with respect to the bindings in the context "
"Γ_i , namely :math:`t_i'=λ Γ_i . t_i` and :math:`A_i'=∀ Γ_i , A_i`."
msgstr ""

#: ../../language/cic.rst:1570
msgid "Typing rule"
msgstr ""

#: ../../language/cic.rst:1572
msgid "The typing rule is the expected one for a fixpoint."
msgstr ""

#: ../../language/cic.rst:1582
msgid ""
"Any fixpoint definition cannot be accepted because non-normalizing terms "
"allow proofs of absurdity. The basic scheme of recursion that should be "
"allowed is the one needed for defining primitive recursive functionals. In "
"that case the fixpoint enjoys a special syntactic restriction, namely one of "
"the arguments belongs to an inductive type, the function starts with a case "
"analysis and recursive calls are done on variables coming from patterns and "
"representing subterms. For instance in the case of natural numbers, a proof "
"of the induction principle of type"
msgstr ""

#: ../../language/cic.rst:1595
msgid "can be represented by the term:"
msgstr ""

#: ../../language/cic.rst:1603
msgid ""
"Before accepting a fixpoint definition as being correctly typed, we check "
"that the definition is “guarded”. A precise analysis of this notion can be "
"found in :cite:`Gim94`. The first stage is to precise on which argument the "
"fixpoint will be decreasing. The type of this argument should be an "
"inductive definition. For doing this, the syntax of fixpoints is extended "
"and becomes"
msgstr ""

#: ../../language/cic.rst:1614
msgid ""
"where :math:`k_i` are positive integers. Each :math:`k_i` represents the "
"index of parameter of :math:`f_i` , on which :math:`f_i` is decreasing. "
"Each :math:`A_i` should be a type (reducible to a term) starting with at "
"least :math:`k_i` products :math:`∀ y_1 :B_1 ,… ∀ y_{k_i} :B_{k_i} , A_i'` "
"and :math:`B_{k_i}` an inductive type."
msgstr ""

#: ../../language/cic.rst:1619
msgid ""
"Now in the definition :math:`t_i`, if :math:`f_j` occurs then it should be "
"applied to at least :math:`k_j` arguments and the :math:`k_j`-th argument "
"should be syntactically recognized as structurally smaller than :math:"
"`y_{k_i}`."
msgstr ""

#: ../../language/cic.rst:1623
msgid ""
"The definition of being structurally smaller is a bit technical. One needs "
"first to define the notion of *recursive arguments of a constructor*. For an "
"inductive definition :math:`\\ind{r}{Γ_I}{Γ_C}`, if the type of a "
"constructor :math:`c` has the form :math:`∀ p_1 :P_1 ,… ∀ p_r :P_r, ∀ x_1:"
"T_1, … ∀ x_r :T_r, (I_j~p_1 … p_r~t_1 … t_s )`, then the recursive arguments "
"will correspond to :math:`T_i` in which one of the :math:`I_l` occurs."
msgstr ""

#: ../../language/cic.rst:1631
msgid ""
"The main rules for being structurally smaller are the following. Given a "
"variable :math:`y` of an inductively defined type in a declaration :math:`"
"\\ind{r}{Γ_I}{Γ_C}` where :math:`Γ_I` is :math:`[I_1 :A_1 ;…;I_k :A_k]`, "
"and :math:`Γ_C` is :math:`[c_1 :C_1 ;…;c_n :C_n ]`, the terms structurally "
"smaller than :math:`y` are:"
msgstr ""

#: ../../language/cic.rst:1637
msgid ""
":math:`(t~u)` and :math:`λ x:u . t` when :math:`t` is structurally smaller "
"than :math:`y`."
msgstr ""

#: ../../language/cic.rst:1638
msgid ""
":math:`\\case(c,P,f_1 … f_n)` when each :math:`f_i` is structurally smaller "
"than :math:`y`. If :math:`c` is :math:`y` or is structurally smaller than :"
"math:`y`, its type is an inductive definition :math:`I_p` part of the "
"inductive declaration corresponding to :math:`y`. Each :math:`f_i` "
"corresponds to a type of constructor :math:`C_q ≡ ∀ p_1 :P_1 ,…,∀ p_r :P_r , "
"∀ y_1 :B_1 , … ∀ y_k :B_k , (I~a_1 … a_k )` and can consequently be written :"
"math:`λ y_1 :B_1' . … λ y_k :B_k'. g_i`. (:math:`B_i'` is obtained from :"
"math:`B_i` by substituting parameters for variables) the variables :math:"
"`y_j` occurring in :math:`g_i` corresponding to recursive arguments :math:"
"`B_i` (the ones in which one of the :math:`I_l` occurs) are structurally "
"smaller than y."
msgstr ""

#: ../../language/cic.rst:1649
msgid ""
"The following definitions are correct, we enter them using the :cmd:"
"`Fixpoint` command and show the internal representation."
msgstr ""

#: ../../language/cic.rst:1680
msgid "Reduction rule"
msgstr ""

#: ../../language/cic.rst:1682
msgid ""
"Let :math:`F` be the set of declarations: :math:`f_1 /k_1 :A_1 :=t_1 …f_n /"
"k_n :A_n:=t_n`. The reduction for fixpoints is:"
msgstr ""

#: ../../language/cic.rst:1689
msgid ""
"when :math:`a_{k_i}` starts with a constructor. This last restriction is "
"needed in order to keep strong normalization and corresponds to the "
"reduction for primitive recursive operators. The following reductions are "
"now possible:"
msgstr ""

#: ../../language/cic.rst:1707
msgid "**Mutual induction**"
msgstr ""

#: ../../language/cic.rst:1709
msgid ""
"The principles of mutual induction can be automatically generated using the "
"Scheme command described in Section :ref:`proofschemes-induction-principles`."
msgstr ""

#: ../../language/cic.rst:1716
msgid "Admissible rules for global environments"
msgstr ""

#: ../../language/cic.rst:1718
msgid ""
"From the original rules of the type system, one can show the admissibility "
"of rules which change the local context of definition of objects in the "
"global environment. We show here the admissible rules that are used in the "
"discharge mechanism at the end of a section."
msgstr ""

#: ../../language/cic.rst:1726
msgid ""
"**Abstraction.** One can modify a global declaration by generalizing it over "
"a previously assumed constant :math:`c`. For doing that, we need to modify "
"the reference to the global declaration in the subsequent global environment "
"and local context by explicitly applying this constant to the constant :math:"
"`c'`."
msgstr ""

#: ../../language/cic.rst:1733
msgid ""
"Below, if :math:`Γ` is a context of the form :math:`[y_1 :A_1 ;…;y_n :A_n]`, "
"we write :math:`∀x:U,\\subst{Γ}{c}{x}` to mean :math:`[y_1 :∀ x:U,"
"\\subst{A_1}{c}{x};…;y_n :∀ x:U,\\subst{A_n}{c}{x}]` and :math:`\\subst{E}{|"
"Γ|}{|Γ|c}` to mean the parallel substitution :math:`E\\{y_1 /(y_1~c)\\}…"
"\\{y_n/(y_n~c)\\}`."
msgstr ""

#: ../../language/cic.rst:1742
msgid "**First abstracting property:**"
msgstr ""

#: ../../language/cic.rst:1760
msgid ""
"One can similarly modify a global declaration by generalizing it over a "
"previously defined constant :math:`c′`. Below, if :math:`Γ` is a context of "
"the form :math:`[y_1 :A_1 ;…;y_n :A_n]`, we write :math:`\\subst{Γ}{c}{u}` "
"to mean :math:`[y_1 :\\subst{A_1} {c}{u};…;y_n:\\subst{A_n} {c}{u}]`."
msgstr ""

#: ../../language/cic.rst:1768
msgid "**Second abstracting property:**"
msgstr ""

#: ../../language/cic.rst:1784
msgid ""
"**Pruning the local context.** If one abstracts or substitutes constants "
"with the above rules then it may happen that some declared or defined "
"constant does not occur any more in the subsequent global environment and in "
"the local context. One can consequently derive the following property."
msgstr ""

#: ../../language/cic.rst:1814
#: ../../language/gallina-specification-language.rst:1026
msgid "Co-inductive types"
msgstr ""

#: ../../language/cic.rst:1816
msgid ""
"The implementation contains also co-inductive definitions, which are types "
"inhabited by infinite objects. More information on co-inductive definitions "
"can be found in :cite:`Gimenez95b,Gim98,GimCas05`."
msgstr ""

#: ../../language/cic.rst:1824
msgid "The Calculus of Inductive Constructions with impredicative Set"
msgstr ""

#: ../../language/cic.rst:1826
msgid ""
"|Coq| can be used as a type checker for the Calculus of Inductive "
"Constructions with an impredicative sort :math:`\\Set` by using the compiler "
"option ``-impredicative-set``. For example, using the ordinary `coqtop` "
"command, the following is rejected,"
msgstr ""

#: ../../language/cic.rst:1837
msgid ""
"while it will type check, if one uses instead the `coqtop` ``-impredicative-"
"set`` option.."
msgstr ""

#: ../../language/cic.rst:1840
msgid ""
"The major change in the theory concerns the rule for product formation in "
"the sort :math:`\\Set`, which is extended to a domain in any sort:"
msgstr ""

#: ../../language/cic.rst:1851
msgid ""
"This extension has consequences on the inductive definitions which are "
"allowed. In the impredicative system, one can build so-called *large "
"inductive definitions* like the example of second-order existential "
"quantifier (:g:`exSet`)."
msgstr ""

#: ../../language/cic.rst:1856
msgid ""
"There should be restrictions on the eliminations which can be performed on "
"such definitions. The elimination rules in the impredicative system for "
"sort :math:`\\Set` become:"
msgstr ""

#: ../../language/coq-library.rst:4
msgid "The |Coq| library"
msgstr ""

#: ../../language/coq-library.rst:10
msgid "The |Coq| library is structured into two parts:"
msgstr ""

#: ../../language/coq-library.rst:12
msgid ""
"**The initial library**: it contains elementary logical notions and data-"
"types. It constitutes the basic state of the system directly available when "
"running |Coq|;"
msgstr ""

#: ../../language/coq-library.rst:16
msgid ""
"**The standard library**: general-purpose libraries containing various "
"developments of |Coq| axiomatizations about sets, lists, sorting, "
"arithmetic, etc. This library comes with the system and its modules are "
"directly accessible through the ``Require`` command (see Section :ref:"
"`compiled-files`);"
msgstr ""

#: ../../language/coq-library.rst:22
msgid ""
"In addition, user-provided libraries or developments are provided by |Coq| "
"users' community. These libraries and developments are available for "
"download at http://coq.inria.fr (see Section :ref:`userscontributions`)."
msgstr ""

#: ../../language/coq-library.rst:27
msgid ""
"This chapter briefly reviews the |Coq| libraries whose contents can also be "
"browsed at http://coq.inria.fr/stdlib."
msgstr ""

#: ../../language/coq-library.rst:34
msgid "The basic library"
msgstr ""

#: ../../language/coq-library.rst:36
msgid ""
"This section lists the basic notions and results which are directly "
"available in the standard |Coq| system. Most of these constructions are "
"defined in the ``Prelude`` module in directory ``theories/Init`` at the |"
"Coq| root directory; this includes the modules ``Notations``, ``Logic``, "
"``Datatypes``, ``Specif``, ``Peano``, ``Wf`` and ``Tactics``. Module "
"``Logic_Type`` also makes it in the initial state."
msgstr ""

#: ../../language/coq-library.rst:52
msgid "Notations"
msgstr ""

#: ../../language/coq-library.rst:54
msgid ""
"This module defines the parsing and pretty-printing of many symbols "
"(infixes, prefixes, etc.). However, it does not assign a meaning to these "
"notations. The purpose of this is to define and fix once for all the "
"precedence and associativity of very common notations. The main notations "
"fixed in the initial state are :"
msgstr ""

#: ../../language/coq-library.rst:61 ../../language/coq-library.rst:788
#: ../../language/coq-library.rst:827 ../../language/coq-library.rst:869
#: ../../language/coq-library.rst:984
msgid "Notation"
msgstr ""

#: ../../language/coq-library.rst:61 ../../language/coq-library.rst:827
#: ../../language/coq-library.rst:984
msgid "Precedence"
msgstr ""

#: ../../language/coq-library.rst:61 ../../language/coq-library.rst:827
#: ../../language/coq-library.rst:984
msgid "Associativity"
msgstr ""

#: ../../language/coq-library.rst:63
msgid "``_ -> _``"
msgstr ""

#: ../../language/coq-library.rst:63
msgid "99"
msgstr ""

#: ../../language/coq-library.rst:63 ../../language/coq-library.rst:65
#: ../../language/coq-library.rst:66 ../../language/coq-library.rst:67
#: ../../language/coq-library.rst:87 ../../language/coq-library.rst:88
#: ../../language/coq-library.rst:89 ../../language/coq-library.rst:986
#: ../../language/coq-library.rst:987
msgid "right"
msgstr ""

#: ../../language/coq-library.rst:64
msgid "``_ <-> _``"
msgstr ""

#: ../../language/coq-library.rst:64
msgid "95"
msgstr ""

#: ../../language/coq-library.rst:64 ../../language/coq-library.rst:68
#: ../../language/coq-library.rst:69 ../../language/coq-library.rst:70
#: ../../language/coq-library.rst:71 ../../language/coq-library.rst:72
#: ../../language/coq-library.rst:73 ../../language/coq-library.rst:74
#: ../../language/coq-library.rst:75 ../../language/coq-library.rst:76
#: ../../language/coq-library.rst:77 ../../language/coq-library.rst:78
#: ../../language/coq-library.rst:79 ../../language/coq-library.rst:80
#: ../../language/coq-library.rst:837 ../../language/coq-library.rst:842
msgid "no"
msgstr ""

#: ../../language/coq-library.rst:65
msgid "``_ \\/ _``"
msgstr ""

#: ../../language/coq-library.rst:65
msgid "85"
msgstr ""

#: ../../language/coq-library.rst:66
msgid "``_ /\\ _``"
msgstr ""

#: ../../language/coq-library.rst:66
msgid "80"
msgstr ""

#: ../../language/coq-library.rst:67
msgid "``~ _``"
msgstr ""

#: ../../language/coq-library.rst:67
msgid "75"
msgstr ""

#: ../../language/coq-library.rst:68
msgid "``_ = _``"
msgstr ""

#: ../../language/coq-library.rst:68 ../../language/coq-library.rst:69
#: ../../language/coq-library.rst:70 ../../language/coq-library.rst:71
#: ../../language/coq-library.rst:72 ../../language/coq-library.rst:73
#: ../../language/coq-library.rst:74 ../../language/coq-library.rst:75
#: ../../language/coq-library.rst:76 ../../language/coq-library.rst:77
#: ../../language/coq-library.rst:78 ../../language/coq-library.rst:79
#: ../../language/coq-library.rst:80 ../../language/coq-library.rst:837
msgid "70"
msgstr ""

#: ../../language/coq-library.rst:69
msgid "``_ = _ = _``"
msgstr ""

#: ../../language/coq-library.rst:70
msgid "``_ = _ :> _``"
msgstr ""

#: ../../language/coq-library.rst:71
msgid "``_ <> _``"
msgstr ""

#: ../../language/coq-library.rst:72
msgid "``_ <> _ :> _``"
msgstr ""

#: ../../language/coq-library.rst:73 ../../language/coq-library.rst:790
#: ../../language/coq-library.rst:829 ../../language/coq-library.rst:871
msgid "``_ < _``"
msgstr ""

#: ../../language/coq-library.rst:74 ../../language/coq-library.rst:792
#: ../../language/coq-library.rst:831 ../../language/coq-library.rst:873
msgid "``_ > _``"
msgstr ""

#: ../../language/coq-library.rst:75 ../../language/coq-library.rst:791
#: ../../language/coq-library.rst:830 ../../language/coq-library.rst:872
msgid "``_ <= _``"
msgstr ""

#: ../../language/coq-library.rst:76 ../../language/coq-library.rst:793
#: ../../language/coq-library.rst:832 ../../language/coq-library.rst:874
msgid "``_ >= _``"
msgstr ""

#: ../../language/coq-library.rst:77
msgid "``_ < _ < _``"
msgstr ""

#: ../../language/coq-library.rst:78
msgid "``_ < _ <= _``"
msgstr ""

#: ../../language/coq-library.rst:79
msgid "``_ <= _ < _``"
msgstr ""

#: ../../language/coq-library.rst:80
msgid "``_ <= _ <= _``"
msgstr ""

#: ../../language/coq-library.rst:81 ../../language/coq-library.rst:798
#: ../../language/coq-library.rst:838 ../../language/coq-library.rst:879
msgid "``_ + _``"
msgstr ""

#: ../../language/coq-library.rst:81 ../../language/coq-library.rst:82
#: ../../language/coq-library.rst:83
msgid "50"
msgstr ""

#: ../../language/coq-library.rst:81 ../../language/coq-library.rst:82
#: ../../language/coq-library.rst:83 ../../language/coq-library.rst:84
#: ../../language/coq-library.rst:85 ../../language/coq-library.rst:86
msgid "left"
msgstr ""

#: ../../language/coq-library.rst:82
msgid "``_ || _``"
msgstr ""

#: ../../language/coq-library.rst:83 ../../language/coq-library.rst:799
#: ../../language/coq-library.rst:839 ../../language/coq-library.rst:880
msgid "``_ - _``"
msgstr ""

#: ../../language/coq-library.rst:84 ../../language/coq-library.rst:800
#: ../../language/coq-library.rst:840 ../../language/coq-library.rst:881
msgid "``_ * _``"
msgstr ""

#: ../../language/coq-library.rst:84 ../../language/coq-library.rst:85
#: ../../language/coq-library.rst:86 ../../language/coq-library.rst:842
msgid "40"
msgstr ""

#: ../../language/coq-library.rst:85
msgid "``_      _``"
msgstr ""

#: ../../language/coq-library.rst:86 ../../language/coq-library.rst:841
#: ../../language/coq-library.rst:882
msgid "``_ / _``"
msgstr ""

#: ../../language/coq-library.rst:87 ../../language/coq-library.rst:843
#: ../../language/coq-library.rst:883
msgid "``- _``"
msgstr ""

#: ../../language/coq-library.rst:87 ../../language/coq-library.rst:88
msgid "35"
msgstr ""

#: ../../language/coq-library.rst:88 ../../language/coq-library.rst:884
msgid "``/ _``"
msgstr ""

#: ../../language/coq-library.rst:89 ../../language/coq-library.rst:844
#: ../../language/coq-library.rst:885
msgid "``_ ^ _``"
msgstr ""

#: ../../language/coq-library.rst:89
msgid "30"
msgstr ""

#: ../../language/coq-library.rst:95
msgid "Logic"
msgstr ""

#: ../../language/coq-library.rst:97
msgid ""
"The basic library of |Coq| comes with the definitions of standard "
"(intuitionistic) logical connectives (they are defined as inductive "
"constructions). They are equipped with an appealing syntax enriching the "
"subclass `form` of the syntactic class `term`. The syntax of `form` is shown "
"below:"
msgstr ""

#: ../../language/coq-library.rst:122
msgid ""
"Implication is not defined but primitive (it is a non-dependent product of a "
"proposition over another proposition). There is also a primitive universal "
"quantification (it is a dependent product over a proposition). The primitive "
"universal quantification allows both first-order and higher-order "
"quantification."
msgstr ""

#: ../../language/coq-library.rst:129
msgid "Propositional Connectives"
msgstr ""

#: ../../language/coq-library.rst:147
msgid "First, we find propositional calculus connectives:"
msgstr ""

#: ../../language/coq-library.rst:167
msgid "Quantifiers"
msgstr ""

#: ../../language/coq-library.rst:179
msgid "Then we find first-order quantifiers:"
msgstr ""

#: ../../language/coq-library.rst:189
msgid "The following abbreviations are allowed:"
msgstr ""

#: ../../language/coq-library.rst:192
msgid "``exists x:A, P``"
msgstr ""

#: ../../language/coq-library.rst:192
msgid "``ex A (fun x:A => P)``"
msgstr ""

#: ../../language/coq-library.rst:193
msgid "``exists x, P``"
msgstr ""

#: ../../language/coq-library.rst:193
msgid "``ex _ (fun x => P)``"
msgstr ""

#: ../../language/coq-library.rst:194
msgid "``exists2 x:A, P & Q``"
msgstr ""

#: ../../language/coq-library.rst:194
msgid "``ex2 A (fun x:A => P) (fun x:A => Q)``"
msgstr ""

#: ../../language/coq-library.rst:195
msgid "``exists2 x, P & Q``"
msgstr ""

#: ../../language/coq-library.rst:195
msgid "``ex2 _ (fun x => P) (fun x => Q)``"
msgstr ""

#: ../../language/coq-library.rst:198
msgid ""
"The type annotation ``:A`` can be omitted when ``A`` can be synthesized by "
"the system."
msgstr ""

#: ../../language/coq-library.rst:204
msgid "Equality"
msgstr ""

#: ../../language/coq-library.rst:211
msgid ""
"Then, we find equality, defined as an inductive relation. That is, given a "
"type ``A`` and an ``x`` of type ``A``, the predicate :g:`(eq A x)` is the "
"smallest one which contains ``x``. This definition, due to Christine Paulin-"
"Mohring, is equivalent to define ``eq`` as the smallest reflexive relation, "
"and it is also equivalent to Leibniz' equality."
msgstr ""

#: ../../language/coq-library.rst:224
msgid "Lemmas"
msgstr ""

#: ../../language/coq-library.rst:226
msgid "Finally, a few easy lemmas are provided."
msgstr ""

#: ../../language/coq-library.rst:262
msgid ""
"The theorem ``f_equal`` is extended to functions with two to five arguments. "
"The theorem are names ``f_equal2``, ``f_equal3``, ``f_equal4`` and "
"``f_equal5``. For instance ``f_equal3`` is defined the following way."
msgstr ""

#: ../../language/coq-library.rst:277
msgid "Datatypes"
msgstr ""

#: ../../language/coq-library.rst:282
msgid ""
"In the basic library, we find in ``Datatypes.v`` the definition of the basic "
"data-types of programming, defined as inductive constructions over the sort "
"``Set``. Some of them come with a special syntax shown below (this syntax "
"table is common with the next section :ref:`specification`):"
msgstr ""

#: ../../language/coq-library.rst:301
msgid "Programming"
msgstr ""

#: ../../language/coq-library.rst:328
msgid "Note that zero is the letter ``O``, and *not* the numeral ``0``."
msgstr ""

#: ../../language/coq-library.rst:330
msgid ""
"The predicate ``identity`` is logically equivalent to equality but it lives "
"in sort ``Type``. It is mainly maintained for compatibility."
msgstr ""

#: ../../language/coq-library.rst:334
msgid ""
"We then define the disjoint sum of ``A+B`` of two sets ``A`` and ``B``, and "
"their product ``A*B``."
msgstr ""

#: ../../language/coq-library.rst:364
msgid ""
"Some operations on ``bool`` are also provided: ``andb`` (with infix notation "
"``&&``), ``orb`` (with infix notation ``||``), ``xorb``, ``implb`` and "
"``negb``."
msgstr ""

#: ../../language/coq-library.rst:371
msgid "Specification"
msgstr ""

#: ../../language/coq-library.rst:373
msgid ""
"The following notions defined in module ``Specif.v`` allow to build new data-"
"types and specifications. They are available with the syntax shown in the "
"previous section :ref:`datatypes`."
msgstr ""

#: ../../language/coq-library.rst:376
msgid ""
"For instance, given :g:`A:Type` and :g:`P:A->Prop`, the construct :g:`{x:A | "
"P x}` (in abstract syntax :g:`(sig A P)`) is a ``Type``. We may build "
"elements of this set as :g:`(exist x p)` whenever we have a witness :g:`x:A` "
"with its justification :g:`p:P x`."
msgstr ""

#: ../../language/coq-library.rst:382
msgid ""
"From such a :g:`(exist x p)` we may in turn extract its witness :g:`x:A` "
"(using an elimination construct such as ``match``) but *not* its "
"justification, which stays hidden, like in an abstract data-type. In "
"technical terms, one says that ``sig`` is a *weak (dependent) sum*.  A "
"variant ``sig2`` with two predicates is also provided."
msgstr ""

#: ../../language/coq-library.rst:402
msgid ""
"A *strong (dependent) sum* :g:`{x:A & P x}` may be also defined, when the "
"predicate ``P`` is now defined as a constructor of types in ``Type``."
msgstr ""

#: ../../language/coq-library.rst:430
msgid ""
"A related non-dependent construct is the constructive sum :g:`{A}+{B}` of "
"two propositions ``A`` and ``B``."
msgstr ""

#: ../../language/coq-library.rst:443
msgid ""
"This ``sumbool`` construct may be used as a kind of indexed boolean data-"
"type. An intermediate between ``sumbool`` and ``sum`` is the mixed ``sumor`` "
"which combines :g:`A:Set` and :g:`B:Prop` in the construction :g:`A+{B}` in "
"``Set``."
msgstr ""

#: ../../language/coq-library.rst:460
msgid ""
"We may define variants of the axiom of choice, like in Martin-Löf's "
"Intuitionistic Type Theory."
msgstr ""

#: ../../language/coq-library.rst:484
msgid ""
"The next construct builds a sum between a data-type :g:`A:Type` and an "
"exceptional value encoding errors:"
msgstr ""

#: ../../language/coq-library.rst:498
msgid ""
"This module ends with theorems, relating the sorts ``Set`` or ``Type`` and "
"``Prop`` in a way which is consistent with the realizability interpretation."
msgstr ""

#: ../../language/coq-library.rst:518
msgid "Basic Arithmetics"
msgstr ""

#: ../../language/coq-library.rst:520
msgid ""
"The basic library includes a few elementary properties of natural numbers, "
"together with the definitions of predecessor, addition and multiplication, "
"in module ``Peano.v``. It also provides a scope ``nat_scope`` gathering "
"standard notations for common operations (``+``, ``*``) and a decimal "
"notation for numbers, allowing for instance to write ``3`` for :g:`S (S (S "
"O)))`. This also works on the left hand side of a ``match`` expression (see "
"for example section :tacn:`refine`). This scope is opened by default."
msgstr ""

#: ../../language/coq-library.rst:531
msgid ""
"The following example is not part of the standard library, but it shows the "
"usage of the notations:"
msgstr ""

#: ../../language/coq-library.rst:559
msgid "Now comes the content of module ``Peano``:"
msgstr ""

#: ../../language/coq-library.rst:598
msgid ""
"Finally, it gives the definition of the usual orderings ``le``, ``lt``, "
"``ge`` and ``gt``."
msgstr ""

#: ../../language/coq-library.rst:619
msgid ""
"Properties of these relations are not initially known, but may be required "
"by the user from modules ``Le`` and ``Lt``.  Finally, ``Peano`` gives some "
"lemmas allowing pattern matching, and a double induction principle."
msgstr ""

#: ../../language/coq-library.rst:641
msgid "Well-founded recursion"
msgstr ""

#: ../../language/coq-library.rst:643
msgid ""
"The basic library contains the basics of well-founded recursion and well-"
"founded induction, in module ``Wf.v``."
msgstr ""

#: ../../language/coq-library.rst:672
msgid ""
"The automatically generated scheme ``Acc_rect`` can be used to define "
"functions by fixpoints using well-founded relations to justify termination. "
"Assuming extensionality of the functional used for the recursive call, the "
"fixpoint equation can be proved."
msgstr ""

#: ../../language/coq-library.rst:704
msgid "Accessing the Type level"
msgstr ""

#: ../../language/coq-library.rst:706
msgid ""
"The standard library includes ``Type`` level definitions of counterparts of "
"some logic concepts and basic lemmas about them."
msgstr ""

#: ../../language/coq-library.rst:709
msgid ""
"The module ``Datatypes`` defines ``identity``, which is the ``Type`` level "
"counterpart of equality:"
msgstr ""

#: ../../language/coq-library.rst:720
msgid ""
"Some properties of ``identity`` are proved in the module ``Logic_Type``, "
"which also provides the definition of ``Type`` level negation:"
msgstr ""

#: ../../language/coq-library.rst:731
msgid "Tactics"
msgstr ""

#: ../../language/coq-library.rst:733
msgid ""
"A few tactics defined at the user level are provided in the initial state, "
"in module ``Tactics.v``. They are listed at http://coq.inria.fr/stdlib, in "
"paragraph ``Init``, link ``Tactics``."
msgstr ""

#: ../../language/coq-library.rst:739
msgid "The standard library"
msgstr ""

#: ../../language/coq-library.rst:742
msgid "Survey"
msgstr ""

#: ../../language/coq-library.rst:744
msgid ""
"The rest of the standard library is structured into the following "
"subdirectories:"
msgstr ""

#: ../../language/coq-library.rst:747
msgid "**Logic** : Classical logic and dependent equality"
msgstr ""

#: ../../language/coq-library.rst:748
msgid "**Arith** : Basic Peano arithmetic"
msgstr ""

#: ../../language/coq-library.rst:749
msgid "**PArith** : Basic positive integer arithmetic"
msgstr ""

#: ../../language/coq-library.rst:750
msgid "**NArith** : Basic binary natural number arithmetic"
msgstr ""

#: ../../language/coq-library.rst:751
msgid "**ZArith** : Basic relative integer arithmetic"
msgstr ""

#: ../../language/coq-library.rst:752
msgid ""
"**Numbers** : Various approaches to natural, integer and cyclic numbers "
"(currently axiomatically and on top of 2^31 binary words)"
msgstr ""

#: ../../language/coq-library.rst:753
msgid "**Bool** : Booleans (basic functions and results)"
msgstr ""

#: ../../language/coq-library.rst:754
msgid ""
"**Lists** : Monomorphic and polymorphic lists (basic functions and results), "
"Streams (infinite sequences defined with co-inductive types)"
msgstr ""

#: ../../language/coq-library.rst:755
msgid ""
"**Sets** : Sets (classical, constructive, finite, infinite, power set, etc.)"
msgstr ""

#: ../../language/coq-library.rst:756
msgid ""
"**FSets** : Specification and implementations of finite sets and finite maps "
"(by lists and by AVL trees)"
msgstr ""

#: ../../language/coq-library.rst:757
msgid ""
"**Reals** : Axiomatization of real numbers (classical, basic functions, "
"integer part, fractional part, limit, derivative, Cauchy series, power "
"series and results,...)"
msgstr ""

#: ../../language/coq-library.rst:758
msgid "**Relations** : Relations (definitions and basic results)"
msgstr ""

#: ../../language/coq-library.rst:759
msgid "**Sorting** : Sorted list (basic definitions and heapsort correctness)"
msgstr ""

#: ../../language/coq-library.rst:760
msgid "**Strings** : 8-bits characters and strings"
msgstr ""

#: ../../language/coq-library.rst:761
msgid "**Wellfounded** : Well-founded relations (basic results)"
msgstr ""

#: ../../language/coq-library.rst:764
msgid ""
"These directories belong to the initial load path of the system, and the "
"modules they provide are compiled at installation time. So they are directly "
"accessible with the command ``Require`` (see Section :ref:`compiled-files`)."
msgstr ""

#: ../../language/coq-library.rst:769
msgid ""
"The different modules of the |Coq| standard library are documented online at "
"http://coq.inria.fr/stdlib."
msgstr ""

#: ../../language/coq-library.rst:773
msgid "Peano’s arithmetic (nat)"
msgstr ""

#: ../../language/coq-library.rst:779
msgid ""
"While in the initial state, many operations and predicates of Peano's "
"arithmetic are defined, further operations and results belong to other "
"modules. For instance, the decidability of the basic predicates are defined "
"here. This is provided by requiring the module ``Arith``."
msgstr ""

#: ../../language/coq-library.rst:784
msgid ""
"The following table describes the notations available in scope "
"``nat_scope`` :"
msgstr ""

#: ../../language/coq-library.rst:788 ../../language/coq-library.rst:827
#: ../../language/coq-library.rst:869 ../../language/coq-library.rst:984
msgid "Interpretation"
msgstr ""

#: ../../language/coq-library.rst:790
msgid "``lt``"
msgstr ""

#: ../../language/coq-library.rst:791
msgid "``le``"
msgstr ""

#: ../../language/coq-library.rst:792
msgid "``gt``"
msgstr ""

#: ../../language/coq-library.rst:793
msgid "``ge``"
msgstr ""

#: ../../language/coq-library.rst:794 ../../language/coq-library.rst:833
#: ../../language/coq-library.rst:875
msgid "``x < y < z``"
msgstr ""

#: ../../language/coq-library.rst:794 ../../language/coq-library.rst:833
#: ../../language/coq-library.rst:875
msgid "``x < y /\\ y < z``"
msgstr ""

#: ../../language/coq-library.rst:795 ../../language/coq-library.rst:834
#: ../../language/coq-library.rst:876
msgid "``x < y <= z``"
msgstr ""

#: ../../language/coq-library.rst:795 ../../language/coq-library.rst:834
#: ../../language/coq-library.rst:876
msgid "``x < y /\\ y <= z``"
msgstr ""

#: ../../language/coq-library.rst:796 ../../language/coq-library.rst:835
#: ../../language/coq-library.rst:877
msgid "``x <= y < z``"
msgstr ""

#: ../../language/coq-library.rst:796 ../../language/coq-library.rst:835
#: ../../language/coq-library.rst:877
msgid "``x <= y /\\ y < z``"
msgstr ""

#: ../../language/coq-library.rst:797 ../../language/coq-library.rst:836
#: ../../language/coq-library.rst:878
msgid "``x <= y <= z``"
msgstr ""

#: ../../language/coq-library.rst:797 ../../language/coq-library.rst:836
#: ../../language/coq-library.rst:878
msgid "``x <= y /\\ y <= z``"
msgstr ""

#: ../../language/coq-library.rst:798
msgid "``plus``"
msgstr ""

#: ../../language/coq-library.rst:799
msgid "``minus``"
msgstr ""

#: ../../language/coq-library.rst:800
msgid "``mult``"
msgstr ""

#: ../../language/coq-library.rst:805
msgid "Notations for integer arithmetics"
msgstr ""

#: ../../language/coq-library.rst:821
msgid ""
"The following table describes the syntax of expressions for integer "
"arithmetics. It is provided by requiring and opening the module ``ZArith`` "
"and opening scope ``Z_scope``. It specifies how notations are interpreted "
"and, when not already reserved, the precedence and associativity."
msgstr ""

#: ../../language/coq-library.rst:829
msgid "``Z.lt``"
msgstr ""

#: ../../language/coq-library.rst:830
msgid "``Z.le``"
msgstr ""

#: ../../language/coq-library.rst:831
msgid "``Z.gt``"
msgstr ""

#: ../../language/coq-library.rst:832
msgid "``Z.ge``"
msgstr ""

#: ../../language/coq-library.rst:837
msgid "``_ ?= _``"
msgstr ""

#: ../../language/coq-library.rst:837
msgid "``Z.compare``"
msgstr ""

#: ../../language/coq-library.rst:838
msgid "``Z.add``"
msgstr ""

#: ../../language/coq-library.rst:839
msgid "``Z.sub``"
msgstr ""

#: ../../language/coq-library.rst:840
msgid "``Z.mul``"
msgstr ""

#: ../../language/coq-library.rst:841
msgid "``Z.div``"
msgstr ""

#: ../../language/coq-library.rst:842
msgid "``_ mod _``"
msgstr ""

#: ../../language/coq-library.rst:842
msgid "``Z.modulo``"
msgstr ""

#: ../../language/coq-library.rst:843
msgid "``Z.opp``"
msgstr ""

#: ../../language/coq-library.rst:844
msgid "``Z.pow``"
msgstr ""

#: ../../language/coq-library.rst:859
msgid "Real numbers library"
msgstr ""

#: ../../language/coq-library.rst:862
msgid "Notations for real numbers"
msgstr ""

#: ../../language/coq-library.rst:864
msgid ""
"This is provided by requiring and opening the module ``Reals`` and opening "
"scope ``R_scope``. This set of notations is very similar to the notation for "
"integer arithmetics. The inverse function was added."
msgstr ""

#: ../../language/coq-library.rst:871
msgid "``Rlt``"
msgstr ""

#: ../../language/coq-library.rst:872
msgid "``Rle``"
msgstr ""

#: ../../language/coq-library.rst:873
msgid "``Rgt``"
msgstr ""

#: ../../language/coq-library.rst:874
msgid "``Rge``"
msgstr ""

#: ../../language/coq-library.rst:879
msgid "``Rplus``"
msgstr ""

#: ../../language/coq-library.rst:880
msgid "``Rminus``"
msgstr ""

#: ../../language/coq-library.rst:881
msgid "``Rmult``"
msgstr ""

#: ../../language/coq-library.rst:882
msgid "``Rdiv``"
msgstr ""

#: ../../language/coq-library.rst:883
msgid "``Ropp``"
msgstr ""

#: ../../language/coq-library.rst:884
msgid "``Rinv``"
msgstr ""

#: ../../language/coq-library.rst:885
msgid "``pow``"
msgstr ""

#: ../../language/coq-library.rst:898
msgid "Some tactics for real numbers"
msgstr ""

#: ../../language/coq-library.rst:900
msgid ""
"In addition to the powerful ``ring``, ``field`` and ``fourier`` tactics (see "
"Chapter :ref:`tactics`), there are also:"
msgstr ""

#: ../../language/coq-library.rst:906
msgid "Proves that two real integer constants are different."
msgstr ""

#: ../../language/coq-library.rst:920
msgid ""
"Allows unfolding the ``Rabs`` constant and splits corresponding conjunctions."
msgstr ""

#: ../../language/coq-library.rst:934
msgid ""
"Splits a condition that a product is non null into subgoals corresponding to "
"the condition on each operand of the product."
msgstr ""

#: ../../language/coq-library.rst:946
msgid ""
"These tactics has been written with the tactic language |Ltac| described in "
"Chapter :ref:`ltac`."
msgstr ""

#: ../../language/coq-library.rst:950
msgid "List library"
msgstr ""

#: ../../language/coq-library.rst:965
msgid ""
"Some elementary operations on polymorphic lists are defined here. They can "
"be accessed by requiring module ``List``."
msgstr ""

#: ../../language/coq-library.rst:968
msgid "It defines the following notions:"
msgstr ""

#: ../../language/coq-library.rst:970
msgid "``length``"
msgstr ""

#: ../../language/coq-library.rst:971
msgid "``head`` : first element (with default)"
msgstr ""

#: ../../language/coq-library.rst:972
msgid "``tail`` : all but first element"
msgstr ""

#: ../../language/coq-library.rst:973
msgid "``app`` : concatenation"
msgstr ""

#: ../../language/coq-library.rst:974
msgid "``rev`` : reverse"
msgstr ""

#: ../../language/coq-library.rst:975
msgid "``nth`` : accessing n-th element (with default)"
msgstr ""

#: ../../language/coq-library.rst:976
msgid "``map`` : applying a function"
msgstr ""

#: ../../language/coq-library.rst:977
msgid "``flat_map`` : applying a function returning lists"
msgstr ""

#: ../../language/coq-library.rst:978
msgid "``fold_left`` : iterator (from head to tail)"
msgstr ""

#: ../../language/coq-library.rst:979
msgid "``fold_right`` : iterator (from tail to head)"
msgstr ""

#: ../../language/coq-library.rst:981
msgid ""
"The following table shows notations available when opening scope "
"``list_scope``."
msgstr ""

#: ../../language/coq-library.rst:986
msgid "``_ ++ _``"
msgstr ""

#: ../../language/coq-library.rst:986
msgid "``app``"
msgstr ""

#: ../../language/coq-library.rst:986 ../../language/coq-library.rst:987
msgid "60"
msgstr ""

#: ../../language/coq-library.rst:987
msgid "``_ :: _``"
msgstr ""

#: ../../language/coq-library.rst:987
msgid "``cons``"
msgstr ""

#: ../../language/coq-library.rst:993
msgid "Users’ contributions"
msgstr ""

#: ../../language/coq-library.rst:995
msgid ""
"Numerous users' contributions have been collected and are available at URL "
"http://coq.inria.fr/opam/www/.  On this web page, you have a list of all "
"contributions with informations (author, institution, quick description, "
"etc.) and the possibility to download them one by one. You will also find "
"informations on how to submit a new contribution."
msgstr ""

#: ../../language/gallina-extensions.rst:4
msgid "Extensions of |Gallina|"
msgstr ""

#: ../../language/gallina-extensions.rst:6
msgid ""
"|Gallina| is the kernel language of |Coq|. We describe here extensions of |"
"Gallina|’s syntax."
msgstr ""

#: ../../language/gallina-extensions.rst:12
msgid "Record types"
msgstr ""

#: ../../language/gallina-extensions.rst:14
msgid ""
"The :cmd:`Record` construction is a macro allowing the definition of records "
"as is done in many programming languages. Its syntax is described in the "
"grammar below. In fact, the :cmd:`Record` macro is more general than the "
"usual record types, since it allows also for “manifest” expressions. In this "
"sense, the :cmd:`Record` construction allows defining “signatures”."
msgstr ""

#: ../../language/gallina-extensions.rst:29
msgid "In the expression:"
msgstr ""

#: ../../language/gallina-extensions.rst:33
msgid ""
"the first identifier :token:`ident` is the name of the defined record and :"
"token:`sort` is its type. The optional identifier following ``:=`` is the "
"name of its constructor. If it is omitted, the default name ``Build_``\\ :"
"token:`ident`, where :token:`ident` is the record name, is used. If :token:"
"`sort` is omitted, the default sort is `\\Type`. The identifiers inside the "
"brackets are the names of fields. For a given field :token:`ident`, its type "
"is :g:`forall binders, type`. Remark that the type of a particular "
"identifier may depend on a previously-given identifier. Thus the order of "
"the fields is important. Finally, :token:`binders` are parameters of the "
"record."
msgstr ""

#: ../../language/gallina-extensions.rst:41
msgid ""
"More generally, a record may have explicitly defined (a.k.a. manifest) "
"fields. For instance, we might have: :n:`Record @ident @binders : @sort := "
"{ @ident₁ : @type₁ ; @ident₂ := @term₂ ; @ident₃ : @type₃ }`. in which case "
"the correctness of :n:`@type₃` may rely on the instance :n:`@term₂` of :n:"
"`@ident₂` and :n:`@term₂` may in turn depend on :n:`@ident₁`."
msgstr ""

#: ../../language/gallina-extensions.rst:48
msgid "The set of rational numbers may be defined as:"
msgstr ""

#: ../../language/gallina-extensions.rst:60
msgid ""
"Remark here that the fields ``Rat_bottom_cond`` depends on the field "
"``bottom`` and ``Rat_irred_cond`` depends on both ``top`` and ``bottom``."
msgstr ""

#: ../../language/gallina-extensions.rst:63
msgid ""
"Let us now see the work done by the ``Record`` macro. First the macro "
"generates a variant type definition with just one constructor: :n:`Variant "
"@ident {? @binders } : @sort := @ident₀ {? @binders }`."
msgstr ""

#: ../../language/gallina-extensions.rst:67
msgid ""
"To build an object of type :n:`@ident`, one should provide the constructor :"
"n:`@ident₀` with the appropriate number of terms filling the fields of the "
"record."
msgstr ""

#: ../../language/gallina-extensions.rst:72
msgid "Let us define the rational :math:`1/2`:"
msgstr ""

#: ../../language/gallina-extensions.rst:90
msgid ""
"Alternatively, the following syntax allows creating objects by using named "
"fields, as shown in this grammar. The fields do not have to be in any "
"particular order, nor do they have to be all present if the missing ones can "
"be inferred or prompted for (see :ref:`programs`)."
msgstr ""

#: ../../language/gallina-extensions.rst:102
msgid "The following settings let you control the display format for types:"
msgstr ""

#: ../../language/gallina-extensions.rst:106
msgid ""
"If set, use the record syntax (shown above) as the default display format."
msgstr ""

#: ../../language/gallina-extensions.rst:108
msgid ""
"You can override the display format for specified types by adding entries to "
"these tables:"
msgstr ""

#: ../../language/gallina-extensions.rst:113
msgid ""
"Specifies a set of qualids which are displayed as records.  Use the :cmd:"
"`Add @table` and :cmd:`Remove @table` commands to update the set of qualids."
msgstr ""

#: ../../language/gallina-extensions.rst:119
msgid ""
"Specifies a set of qualids which are displayed as constructors.  Use the :"
"cmd:`Add @table` and :cmd:`Remove @table` commands to update the set of "
"qualids."
msgstr ""

#: ../../language/gallina-extensions.rst:122
msgid "This syntax can also be used for pattern matching."
msgstr ""

#: ../../language/gallina-extensions.rst:132
msgid ""
"The macro generates also, when it is possible, the projection functions for "
"destructuring an object of type `\\ident`.  These projection functions are "
"given the names of the corresponding fields. If a field is named `_` then no "
"projection is built for it. In our example:"
msgstr ""

#: ../../language/gallina-extensions.rst:144
msgid ""
"An alternative syntax for projections based on a dot notation is available:"
msgstr ""

#: ../../language/gallina-extensions.rst:151
msgid "It can be activated for printing with"
msgstr ""

#: ../../language/gallina-extensions.rst:171
msgid "Syntax of Record projections"
msgstr ""

#: ../../language/gallina-extensions.rst:173
msgid ""
"The corresponding grammar rules are given in the preceding grammar. When "
"`qualid` denotes a projection, the syntax `term.(qualid)` is equivalent to "
"`qualid term`, the syntax `term.(qualid` |arg_1| |arg_n| `)` to `qualid` |"
"arg_1| `…` |arg_n| `term`, and the syntax `term.(@qualid` |term_1| |term_n| "
"`)` to `@qualid` |term_1| `…` |term_n| `term`. In each case, `term` is the "
"object projected and the other arguments are the parameters of the inductive "
"type."
msgstr ""

#: ../../language/gallina-extensions.rst:180
msgid ""
"Records defined with the ``Record`` keyword are not allowed to be recursive "
"(references to the record's name in the type of its field raises an  error). "
"To define recursive records, one can use the ``Inductive`` and "
"``CoInductive`` keywords, resulting in an inductive or co-inductive record. "
"A *caveat*, however, is that records cannot appear in mutually inductive (or "
"co-inductive) definitions."
msgstr ""

#: ../../language/gallina-extensions.rst:187
msgid ""
"Induction schemes are automatically generated for inductive records. "
"Automatic generation of induction schemes for non-recursive records defined "
"with the ``Record`` keyword can be activated with the ``Nonrecursive "
"Elimination Schemes`` option (see :ref:`proofschemes-induction-principles`)."
msgstr ""

#: ../../language/gallina-extensions.rst:192
msgid "``Structure`` is a synonym of the keyword ``Record``."
msgstr ""

#: ../../language/gallina-extensions.rst:196
msgid ""
"It can happen that the definition of a projection is impossible. This "
"message is followed by an explanation of this impossibility. There may be "
"three reasons:"
msgstr ""

#: ../../language/gallina-extensions.rst:200
msgid "The name `ident` already exists in the environment (see :cmd:`Axiom`)."
msgstr ""

#: ../../language/gallina-extensions.rst:201
msgid ""
"The body of `ident` uses an incorrect elimination for `ident` (see :cmd:"
"`Fixpoint` and :ref:`Destructors`)."
msgstr ""

#: ../../language/gallina-extensions.rst:203
msgid ""
"The type of the projections `ident` depends on previous projections which "
"themselves could not be defined."
msgstr ""

#: ../../language/gallina-extensions.rst:208
msgid ""
"The record name `ident` appears in the type of its fields, but uses the "
"keyword ``Record``. Use  the keyword ``Inductive`` or ``CoInductive`` "
"instead."
msgstr ""

#: ../../language/gallina-extensions.rst:213
msgid ""
"Records  cannot  be  defined  as  part  of  mutually  inductive  (or co-"
"inductive) definitions,  whether with records only  or mixed with standard "
"definitions."
msgstr ""

#: ../../language/gallina-extensions.rst:217
msgid ""
"During the definition of the one-constructor inductive definition, all the "
"errors of inductive definitions, as described in Section :ref:`gallina-"
"inductive-definitions`, may also occur."
msgstr ""

#: ../../language/gallina-extensions.rst:221
msgid ""
"Coercions and records in section :ref:`coercions-classes-as-records` of the "
"chapter devoted to coercions."
msgstr ""

#: ../../language/gallina-extensions.rst:226
msgid "Primitive Projections"
msgstr ""

#: ../../language/gallina-extensions.rst:230
msgid ""
"Turns on the use of primitive projections when defining subsequent records "
"(even through the ``Inductive`` and ``CoInductive`` commands). Primitive "
"projections extended the Calculus of Inductive Constructions with a new "
"binary term constructor `r.(p)` representing a primitive projection `p` "
"applied to a record object `r` (i.e., primitive projections are always "
"applied). Even if the record type has parameters, these do not appear at "
"applications of the projection, considerably reducing the sizes of terms "
"when manipulating parameterized records and type checking time. On the user "
"level, primitive projections can be used as a replacement for the usual "
"defined ones, although there are a few notable differences."
msgstr ""

#: ../../language/gallina-extensions.rst:244
msgid ""
"This compatibility option reconstructs internally omitted parameters at "
"printing time (even though they are absent in the actual AST manipulated by "
"the kernel)."
msgstr ""

#: ../../language/gallina-extensions.rst:250
msgid ""
"This compatibility option (on by default) governs the printing of pattern "
"matching over primitive records."
msgstr ""

#: ../../language/gallina-extensions.rst:254
msgid "Primitive Record Types"
msgstr ""

#: ../../language/gallina-extensions.rst:256
msgid ""
"When the :flag:`Primitive Projections` option is on, definitions of record "
"types change meaning. When a type is declared with primitive projections, "
"its :g:`match` construct is disabled (see :ref:`primitive_projections` "
"though). To eliminate the (co-)inductive type, one must use its defined "
"primitive projections."
msgstr ""

#: ../../language/gallina-extensions.rst:263
msgid ""
"For compatibility, the parameters still appear to the user when printing "
"terms even though they are absent in the actual AST manipulated by the "
"kernel. This can be changed by unsetting the :flag:`Printing Primitive "
"Projection Parameters` flag. Further compatibility printing can be "
"deactivated thanks to the ``Printing Primitive Projection Compatibility`` "
"option which governs the printing of pattern matching over primitive records."
msgstr ""

#: ../../language/gallina-extensions.rst:271
msgid "There are currently two ways to introduce primitive records types:"
msgstr ""

#: ../../language/gallina-extensions.rst:273
msgid ""
"Through the ``Record`` command, in which case the type has to be non-"
"recursive. The defined type enjoys eta-conversion definitionally, that is "
"the generalized form of surjective pairing for records: `r` ``= Build_``\\ "
"`R` ``(``\\ `r`\\ ``.(``\\ |p_1|\\ ``) …`` `r`\\ ``.(``\\ |p_n|\\ ``))``. "
"Eta-conversion allows to define dependent elimination for these types as "
"well."
msgstr ""

#: ../../language/gallina-extensions.rst:278
msgid ""
"Through the ``Inductive`` and ``CoInductive`` commands, when the body of the "
"definition is a record declaration of the form ``Build_``\\ `R` ``{`` |p_1| "
"``:`` |t_1|\\ ``; … ;`` |p_n| ``:`` |t_n| ``}``. In this case the types can "
"be recursive and eta-conversion is disallowed. These kind of record types "
"differ from their traditional versions in the sense that dependent "
"elimination is not available for them and only non-dependent case analysis "
"can be defined."
msgstr ""

#: ../../language/gallina-extensions.rst:287
msgid "Reduction"
msgstr ""

#: ../../language/gallina-extensions.rst:289
msgid ""
"The basic reduction rule of a primitive projection is |p_i| ``(Build_``\\ "
"`R` |t_1| … |t_n|\\ ``)`` :math:`{\\rightarrow_{\\iota}}` |t_i|. However, to "
"take the :math:`{\\delta}` flag into account, projections can be in two "
"states: folded or unfolded. An unfolded primitive projection application "
"obeys the rule above, while the folded version delta-reduces to the unfolded "
"version. This allows to precisely mimic the usual unfolding rules of "
"constants. Projections obey the usual ``simpl`` flags of the ``Arguments`` "
"command in particular. There is currently no way to input unfolded primitive "
"projections at the user-level, and one must use the :flag:`Printing "
"Primitive Projection Compatibility` to display unfolded primitive "
"projections as matches and distinguish them from folded ones."
msgstr ""

#: ../../language/gallina-extensions.rst:303
msgid "Compatibility Projections and :g:`match`"
msgstr ""

#: ../../language/gallina-extensions.rst:305
msgid ""
"To ease compatibility with ordinary record types, each primitive projection "
"is also defined as a ordinary constant taking parameters and an object of "
"the record type as arguments, and whose body is an application of the "
"unfolded primitive projection of the same name. These constants are used "
"when elaborating partial applications of the projection. One can distinguish "
"them from applications of the primitive projection if the :flag`Printing "
"Primitive Projection Parameters` option is off: For a primitive projection "
"application, parameters are printed as underscores while for the "
"compatibility projections they are printed as usual."
msgstr ""

#: ../../language/gallina-extensions.rst:316
msgid ""
"Additionally, user-written :g:`match` constructs on primitive records are "
"desugared into substitution of the projections, they cannot be printed back "
"as :g:`match` constructs."
msgstr ""

#: ../../language/gallina-extensions.rst:321
msgid "Variants and extensions of :g:`match`"
msgstr ""

#: ../../language/gallina-extensions.rst:326
msgid "Multiple and nested pattern matching"
msgstr ""

#: ../../language/gallina-extensions.rst:328
msgid ""
"The basic version of :g:`match` allows pattern matching on simple patterns. "
"As an extension, multiple nested patterns or disjunction of patterns are "
"allowed, as in ML-like languages."
msgstr ""

#: ../../language/gallina-extensions.rst:332
msgid ""
"The extension just acts as a macro that is expanded during parsing into a "
"sequence of match on simple patterns. Especially, a construction defined "
"using the extended match is generally printed under its expanded form (see :"
"flag:`Printing Matching`)."
msgstr ""

#: ../../language/gallina-extensions.rst:337
msgid ":ref:`extendedpatternmatching`."
msgstr ""

#: ../../language/gallina-extensions.rst:342
msgid "Pattern-matching on boolean values: the if expression"
msgstr ""

#: ../../language/gallina-extensions.rst:344
msgid ""
"For inductive types with exactly two constructors and for pattern matching "
"expressions that do not depend on the arguments of the constructors, it is "
"possible to use a ``if … then … else`` notation. For instance, the definition"
msgstr ""

#: ../../language/gallina-extensions.rst:356
#: ../../language/gallina-extensions.rst:411
msgid "can be alternatively written"
msgstr ""

#: ../../language/gallina-extensions.rst:362
msgid ""
"More generally, for an inductive type with constructors |C_1| and |C_2|, we "
"have the following equivalence"
msgstr ""

#: ../../language/gallina-extensions.rst:383
msgid ""
"Notice that the printing uses the :g:`if` syntax because `sumbool` is "
"declared as such (see :ref:`controlling-match-pp`)."
msgstr ""

#: ../../language/gallina-extensions.rst:389
msgid "Irrefutable patterns: the destructuring let variants"
msgstr ""

#: ../../language/gallina-extensions.rst:391
msgid ""
"Pattern-matching on terms inhabiting inductive type having only one "
"constructor can be alternatively written using :g:`let … in …` "
"constructions. There are two variants of them."
msgstr ""

#: ../../language/gallina-extensions.rst:397
msgid "First destructuring let syntax"
msgstr ""

#: ../../language/gallina-extensions.rst:399
msgid ""
"The expression :g:`let (`\\ |ident_1|:g:`, … ,` |ident_n|\\ :g:`) :=` |"
"term_0|\\ :g:`in` |term_1| performs case analysis on |term_0| which must be "
"in an inductive type with one constructor having itself :math:`n` arguments. "
"Variables |ident_1| … |ident_n| are bound to the :math:`n` arguments of the "
"constructor in expression |term_1|. For instance, the definition"
msgstr ""

#: ../../language/gallina-extensions.rst:417
msgid ""
"Notice that reduction is different from regular :g:`let … in …` construction "
"since it happens only if |term_0| is in constructor form. Otherwise, the "
"reduction is blocked."
msgstr ""

#: ../../language/gallina-extensions.rst:421
msgid ""
"The pretty-printing of a definition by matching on a irrefutable pattern can "
"either be done using :g:`match` or the :g:`let` construction (see Section :"
"ref:`controlling-match-pp`)."
msgstr ""

#: ../../language/gallina-extensions.rst:425
msgid ""
"If term inhabits an inductive type with one constructor `C`, we have an "
"equivalence between"
msgstr ""

#: ../../language/gallina-extensions.rst:442
msgid "Second destructuring let syntax"
msgstr ""

#: ../../language/gallina-extensions.rst:444
msgid ""
"Another destructuring let syntax is available for inductive types with one "
"constructor by giving an arbitrary pattern instead of just a tuple for all "
"the arguments. For example, the preceding example can be written:"
msgstr ""

#: ../../language/gallina-extensions.rst:453
msgid ""
"This is useful to match deeper inside tuples and also to use notations for "
"the pattern, as the syntax :g:`let ’p := t in b` allows arbitrary patterns "
"to do the deconstruction. For example:"
msgstr ""

#: ../../language/gallina-extensions.rst:467
msgid ""
"When printing definitions which are written using this construct it takes "
"precedence over let printing directives for the datatype under consideration "
"(see Section :ref:`controlling-match-pp`)."
msgstr ""

#: ../../language/gallina-extensions.rst:475
msgid "Controlling pretty-printing of match expressions"
msgstr ""

#: ../../language/gallina-extensions.rst:477
msgid ""
"The following commands give some control over the pretty-printing of :g:"
"`match` expressions."
msgstr ""

#: ../../language/gallina-extensions.rst:481
msgid "Printing nested patterns"
msgstr ""

#: ../../language/gallina-extensions.rst:485
msgid ""
"The Calculus of Inductive Constructions knows pattern matching only over "
"simple patterns. It is however convenient to re-factorize nested pattern "
"matching into a single pattern matching over a nested pattern."
msgstr ""

#: ../../language/gallina-extensions.rst:490
msgid ""
"When this option is on (default), |Coq|’s printer tries to do such limited "
"re-factorization. Turning it off tells |Coq| to print only simple pattern "
"matching problems in the same way as the |Coq| kernel handles them."
msgstr ""

#: ../../language/gallina-extensions.rst:497
msgid "Factorization of clauses with same right-hand side"
msgstr ""

#: ../../language/gallina-extensions.rst:501
msgid ""
"When several patterns share the same right-hand side, it is additionally "
"possible to share the clauses using disjunctive patterns. Assuming that the "
"printing matching mode is on, this option (on by default) tells |Coq|'s "
"printer to try to do this kind of factorization."
msgstr ""

#: ../../language/gallina-extensions.rst:507
msgid "Use of a default clause"
msgstr ""

#: ../../language/gallina-extensions.rst:511
msgid ""
"When several patterns share the same right-hand side which do not depend on "
"the arguments of the patterns, yet an extra factorization is possible: the "
"disjunction of patterns can be replaced with a `_` default clause. Assuming "
"that the printing matching mode and the factorization mode are on, this "
"option (on by default) tells |Coq|'s printer to use a default clause when "
"relevant."
msgstr ""

#: ../../language/gallina-extensions.rst:518
msgid "Printing of wildcard patterns"
msgstr ""

#: ../../language/gallina-extensions.rst:522
msgid ""
"Some variables in a pattern may not occur in the right-hand side of the "
"pattern matching clause. When this option is on (default), the variables "
"having no occurrences in the right-hand side of the pattern matching clause "
"are just printed using the wildcard symbol “_”."
msgstr ""

#: ../../language/gallina-extensions.rst:530
msgid "Printing of the elimination predicate"
msgstr ""

#: ../../language/gallina-extensions.rst:534
msgid ""
"In most of the cases, the type of the result of a matched term is "
"mechanically synthesizable. Especially, if the result type does not depend "
"of the matched term. When this option is on (default), the result type is "
"not printed when |Coq| knows that it can re- synthesize it."
msgstr ""

#: ../../language/gallina-extensions.rst:542
msgid "Printing matching on irrefutable patterns"
msgstr ""

#: ../../language/gallina-extensions.rst:544
msgid ""
"If an inductive type has just one constructor, pattern matching can be "
"written using the first destructuring let syntax."
msgstr ""

#: ../../language/gallina-extensions.rst:550
msgid ""
"Specifies a set of qualids for which pattern matching is displayed using a "
"let expression. Note that this only applies to pattern matching instances "
"entered with :g:`match`. It doesn't affect pattern matching explicitly "
"entered with a destructuring :g:`let`. Use the :cmd:`Add @table` and :cmd:"
"`Remove @table` commands to update this set."
msgstr ""

#: ../../language/gallina-extensions.rst:558
msgid "Printing matching on booleans"
msgstr ""

#: ../../language/gallina-extensions.rst:560
msgid ""
"If an inductive type is isomorphic to the boolean type, pattern matching can "
"be written using ``if`` … ``then`` … ``else`` ….  This table controls which "
"types are written this way:"
msgstr ""

#: ../../language/gallina-extensions.rst:567
msgid ""
"Specifies a set of qualids for which pattern matching is displayed using "
"``if`` … ``then`` … ``else`` ….  Use the :cmd:`Add @table` and :cmd:`Remove "
"@table` commands to update this set."
msgstr ""

#: ../../language/gallina-extensions.rst:571
msgid "This example emphasizes what the printing options offer."
msgstr ""

#: ../../language/gallina-extensions.rst:596
msgid "Advanced recursive functions"
msgstr ""

#: ../../language/gallina-extensions.rst:598
msgid ""
"The following experimental command is available when the ``FunInd`` library "
"has been loaded via ``Require Import FunInd``:"
msgstr ""

#: ../../language/gallina-extensions.rst:602
msgid ""
"This command can be seen as a generalization of ``Fixpoint``. It is actually "
"a wrapper for several ways of defining a function *and other useful related "
"objects*, namely: an induction principle that reflects the recursive "
"structure of the function (see :tacn:`function induction`) and its fixpoint "
"equality. The meaning of this declaration is to define a function ident, "
"similarly to ``Fixpoint`. Like in ``Fixpoint``, the decreasing argument must "
"be given (unless the function is not recursive), but it might not "
"necessarily be *structurally* decreasing. The point of the {} annotation is "
"to name the decreasing argument *and* to describe which kind of decreasing "
"criteria must be used to ensure termination of recursive calls."
msgstr ""

#: ../../language/gallina-extensions.rst:614
msgid ""
"The ``Function`` construction also enjoys the ``with`` extension to define "
"mutually recursive definitions. However, this feature does not work for non "
"structurally recursive functions."
msgstr ""

#: ../../language/gallina-extensions.rst:618
msgid ""
"See the documentation of functional induction (:tacn:`function induction`) "
"and ``Functional Scheme`` (:ref:`functional-scheme`) for how to use the "
"induction principle to easily reason about the function."
msgstr ""

#: ../../language/gallina-extensions.rst:622
msgid ""
"Remark: To obtain the right principle, it is better to put rigid parameters "
"of the function as first arguments. For example it is better to define plus "
"like this:"
msgstr ""

#: ../../language/gallina-extensions.rst:638
msgid "than like this:"
msgstr ""

#: ../../language/gallina-extensions.rst:649
msgid "*Limitations*"
msgstr ""

#: ../../language/gallina-extensions.rst:651
msgid ""
"|term_0| must be built as a *pure pattern matching tree* (:g:`match … with`) "
"with applications only *at the end* of each branch."
msgstr ""

#: ../../language/gallina-extensions.rst:654
msgid ""
"Function does not support partial application of the function being defined. "
"Thus, the following example cannot be accepted due to the presence of "
"partial application of `wrong` in the body of `wrong` :"
msgstr ""

#: ../../language/gallina-extensions.rst:664
msgid ""
"For now, dependent cases are not treated for non structurally terminating "
"functions."
msgstr ""

#: ../../language/gallina-extensions.rst:673
msgid ""
"The generation of the graph relation (`R_ident`) used to compute the "
"induction scheme of ident raised a typing error. Only `ident` is defined; "
"the induction scheme will not be generated. This error happens generally "
"when:"
msgstr ""

#: ../../language/gallina-extensions.rst:677
msgid ""
"the definition uses pattern matching on dependent types, which ``Function`` "
"cannot deal with yet."
msgstr ""

#: ../../language/gallina-extensions.rst:679
msgid "the definition is not a *pattern matching tree* as explained above."
msgstr ""

#: ../../language/gallina-extensions.rst:683
msgid ""
"The generation of the graph relation (`R_ident`) succeeded but the induction "
"principle could not be built. Only `ident` is defined. Please report."
msgstr ""

#: ../../language/gallina-extensions.rst:688
msgid "`functional inversion` will not be available for the function."
msgstr ""

#: ../../language/gallina-extensions.rst:690
msgid ":ref:`functional-scheme` and :tacn:`function induction`"
msgstr ""

#: ../../language/gallina-extensions.rst:692
msgid ""
"Depending on the ``{…}`` annotation, different definition mechanisms are "
"used by ``Function``. A more precise description is given below."
msgstr ""

#: ../../language/gallina-extensions.rst:697
msgid ""
"Defines the not recursive function `ident` as if declared with `Definition`. "
"Moreover the following are defined:"
msgstr ""

#: ../../language/gallina-extensions.rst:700
msgid ""
"`ident_rect`, `ident_rec` and `ident_ind`, which reflect the pattern "
"matching structure of `term` (see :cmd:`Inductive`);"
msgstr ""

#: ../../language/gallina-extensions.rst:702
msgid ""
"The inductive `R_ident` corresponding to the graph of `ident` (silently);"
msgstr ""

#: ../../language/gallina-extensions.rst:703
msgid ""
"`ident_complete` and `ident_correct` which are inversion information linking "
"the function and its graph."
msgstr ""

#: ../../language/gallina-extensions.rst:708
msgid ""
"Defines the structural recursive function `ident` as if declared with "
"``Fixpoint``. Moreover the following are defined:"
msgstr ""

#: ../../language/gallina-extensions.rst:710
msgid "The same objects as above;"
msgstr ""

#: ../../language/gallina-extensions.rst:711
msgid "The fixpoint equation of `ident`: `ident_equation`."
msgstr ""

#: ../../language/gallina-extensions.rst:716
msgid ""
"Defines a recursive function by well-founded recursion. The module "
"``Recdef`` of the standard library must be loaded for this feature. The ``{}"
"`` annotation is mandatory and must be one of the following:"
msgstr ""

#: ../../language/gallina-extensions.rst:720
msgid ""
"``{measure`` `term` `ident` ``}`` with `ident` being the decreasing argument "
"and `term` being a function from type of `ident` to ``nat`` for which value "
"on the decreasing argument decreases (for the ``lt`` order on ``nat``) at "
"each recursive call of `term`. Parameters of the function are bound in `term`"
"\\ ;"
msgstr ""

#: ../../language/gallina-extensions.rst:725
msgid ""
"``{wf`` `term` `ident` ``}`` with `ident` being the decreasing argument and "
"`term` an ordering relation on the type of `ident` (i.e. of type `T`\\ :math:"
"`_{\\sf ident}` → `T`\\ :math:`_{\\sf ident}` → ``Prop``) for which the "
"decreasing argument decreases at each recursive call of `term`. The order "
"must be well-founded. Parameters of the function are bound in `term`."
msgstr ""

#: ../../language/gallina-extensions.rst:731
msgid ""
"Depending on the annotation, the user is left with some proof obligations "
"that will be used to define the function. These proofs are: proofs that each "
"recursive call is actually decreasing with respect to the given criteria, "
"and (if the criteria is `wf`) a proof that the ordering relation is well-"
"founded. Once proof obligations are discharged, the following objects are "
"defined:"
msgstr ""

#: ../../language/gallina-extensions.rst:738
msgid "The same objects as with the struct;"
msgstr ""

#: ../../language/gallina-extensions.rst:739
msgid ""
"The lemma `ident`\\ :math:`_{\\sf tcc}` which collects all proof obligations "
"in one property;"
msgstr ""

#: ../../language/gallina-extensions.rst:741
msgid ""
"The lemmas `ident`\\ :math:`_{\\sf terminate}` and `ident`\\ :math:`_{\\sf F}"
"` which is needed to be inlined during extraction of ident."
msgstr ""

#: ../../language/gallina-extensions.rst:744
msgid ""
"The way this recursive function is defined is the subject of several papers "
"by Yves Bertot and Antonia Balaa on the one hand, and Gilles Barthe, Julien "
"Forest, David Pichardie, and Vlad Rusu on the other hand. Remark: Proof "
"obligations are presented as several subgoals belonging to a Lemma `ident`"
"\\ :math:`_{\\sf tcc}`."
msgstr ""

#: ../../language/gallina-extensions.rst:753
msgid "Section mechanism"
msgstr ""

#: ../../language/gallina-extensions.rst:755
msgid ""
"The sectioning mechanism can be used to to organize a proof in structured "
"sections. Then local declarations become available (see Section :ref:"
"`gallina-definitions`)."
msgstr ""

#: ../../language/gallina-extensions.rst:762
msgid "This command is used to open a section named `ident`."
msgstr ""

#: ../../language/gallina-extensions.rst:767
msgid ""
"This command closes the section named `ident`. After closing of the section, "
"the local declarations (variables and local definitions) get *discharged*, "
"meaning that they stop being visible and that all global objects defined in "
"the section are generalized with respect to the variables and local "
"definitions they each depended on in the section."
msgstr ""

#: ../../language/gallina-extensions.rst:795
msgid ""
"Notice the difference between the value of `x’` and `x’’` inside section "
"`s1` and outside."
msgstr ""

#: ../../language/gallina-extensions.rst:800
msgid "**Remarks:**"
msgstr ""

#: ../../language/gallina-extensions.rst:802
msgid ""
"Most commands, like ``Hint``, ``Notation``, option management, … which "
"appear inside a section are canceled when the section is closed."
msgstr ""

#: ../../language/gallina-extensions.rst:807
msgid "Module system"
msgstr ""

#: ../../language/gallina-extensions.rst:809
msgid ""
"The module system provides a way of packaging related elements together, as "
"well as a means of massive abstraction."
msgstr ""

#: ../../language/gallina-extensions.rst:823
msgid "Syntax of modules"
msgstr ""

#: ../../language/gallina-extensions.rst:825
msgid ""
"In the syntax of module application, the ! prefix indicates that any "
"`Inline` directive in the type of the functor arguments will be ignored (see "
"the ``Module Type`` command below)."
msgstr ""

#: ../../language/gallina-extensions.rst:832
msgid "This command is used to start an interactive module named `ident`."
msgstr ""

#: ../../language/gallina-extensions.rst:836
msgid "Starts an interactive functor with parameters given by module_bindings."
msgstr ""

#: ../../language/gallina-extensions.rst:841
msgid "Starts an interactive module specifying its module type."
msgstr ""

#: ../../language/gallina-extensions.rst:845
msgid ""
"Starts an interactive functor with parameters given by the list of `module "
"binding`, and output module type `module_type`."
msgstr ""

#: ../../language/gallina-extensions.rst:850
msgid "Starts an interactive module satisfying each `module_type`."
msgstr ""

#: ../../language/gallina-extensions.rst:854
msgid ""
"Starts an interactive functor with parameters given by the list of "
"`module_binding`. The output module type is verified against each "
"`module_type`."
msgstr ""

#: ../../language/gallina-extensions.rst:859
msgid ""
"Behaves like ``Module``, but automatically imports or exports the module."
msgstr ""

#: ../../language/gallina-extensions.rst:862
msgid "Reserved commands inside an interactive module"
msgstr ""

#: ../../language/gallina-extensions.rst:866
msgid ""
"Includes the content of module in the current interactive module. Here "
"module can be a module expression or a module type expression. If module is "
"a high-order module or module type expression then the system tries to "
"instantiate module by the current interactive module."
msgstr ""

#: ../../language/gallina-extensions.rst:874
msgid "is a shortcut for the commands ``Include`` `module` for each `module`."
msgstr ""

#: ../../language/gallina-extensions.rst:878
msgid ""
"This command closes the interactive module `ident`. If the module type was "
"given the content of the module is matched against it and an error is "
"signaled if the matching fails. If the module is basic (is not a functor) "
"its components (constants, inductive types, submodules etc.) are now "
"available through the dot notation."
msgstr ""

#: ../../language/gallina-extensions.rst:892
msgid ""
"This command defines the module identifier `ident` to be equal to "
"`module_expression`."
msgstr ""

#: ../../language/gallina-extensions.rst:897
msgid ""
"Defines a functor with parameters given by the list of `module_binding` and "
"body `module_expression`."
msgstr ""

#: ../../language/gallina-extensions.rst:901
msgid ""
"Defines a functor with parameters given by the list of `module_binding` "
"(possibly none), and output module type `module_type`, with body "
"`module_expression`."
msgstr ""

#: ../../language/gallina-extensions.rst:906
msgid ""
"Defines a functor with parameters given by module_bindings (possibly none) "
"with body `module_expression`. The body is checked against each |"
"module_type_i|."
msgstr ""

#: ../../language/gallina-extensions.rst:911
msgid ""
"is equivalent to an interactive module where each `module_expression` is "
"included."
msgstr ""

#: ../../language/gallina-extensions.rst:915
msgid "This command is used to start an interactive module type `ident`."
msgstr ""

#: ../../language/gallina-extensions.rst:919
msgid ""
"Starts an interactive functor type with parameters given by "
"`module_bindings`."
msgstr ""

#: ../../language/gallina-extensions.rst:923
msgid "Reserved commands inside an interactive module type:"
msgstr ""

#: ../../language/gallina-extensions.rst:927
msgid "Same as ``Include`` inside a module."
msgstr ""

#: ../../language/gallina-extensions.rst:931
msgid "is a shortcut for the command ``Include`` `module` for each `module`."
msgstr ""

#: ../../language/gallina-extensions.rst:936
msgid ""
"The instance of this assumption will be automatically expanded at functor "
"application, except when this functor application is prefixed by a ``!`` "
"annotation."
msgstr ""

#: ../../language/gallina-extensions.rst:941
msgid "This command closes the interactive module type `ident`."
msgstr ""

#: ../../language/gallina-extensions.rst:947
msgid "Defines a module type `ident` equal to `module_type`."
msgstr ""

#: ../../language/gallina-extensions.rst:951
msgid ""
"Defines a functor type `ident` specifying functors taking arguments "
"`module_bindings` and returning `module_type`."
msgstr ""

#: ../../language/gallina-extensions.rst:956
msgid ""
"is equivalent to an interactive module type were each `module_type` is "
"included."
msgstr ""

#: ../../language/gallina-extensions.rst:960
msgid "Declares a module `ident` of type `module_type`."
msgstr ""

#: ../../language/gallina-extensions.rst:964
msgid ""
"Declares a functor with parameters given by the list of `module_binding` and "
"output module type `module_type`."
msgstr ""

#: ../../language/gallina-extensions.rst:969
msgid "Let us define a simple module."
msgstr ""

#: ../../language/gallina-extensions.rst:987
msgid ""
"Inside a module one can define constants, prove theorems and do any other "
"things that can be done in the toplevel. Components of a closed module can "
"be accessed using the dot notation:"
msgstr ""

#: ../../language/gallina-extensions.rst:995
msgid "A simple module type:"
msgstr ""

#: ../../language/gallina-extensions.rst:1007
msgid ""
"Now we can create a new module from M, giving it a less precise "
"specification: the y component is dropped as well as the body of x."
msgstr ""

#: ../../language/gallina-extensions.rst:1045
msgid ""
"The definition of ``N`` using the module type expression ``SIG`` with "
"``Definition T := nat`` is equivalent to the following one:"
msgstr ""

#: ../../language/gallina-extensions.rst:1060
msgid ""
"If we just want to be sure that our implementation satisfies a given module "
"type without restricting the interface, we can use a transparent constraint"
msgstr ""

#: ../../language/gallina-extensions.rst:1070
msgid "Now let us create a functor, i.e. a parametric module"
msgstr ""

#: ../../language/gallina-extensions.rst:1082
msgid "and apply it to our modules and do some computations:"
msgstr ""

#: ../../language/gallina-extensions.rst:1090
msgid ""
"In the end, let us define a module type with two sub-modules, sharing some "
"of the fields and give one of its possible implementations:"
msgstr ""

#: ../../language/gallina-extensions.rst:1123
msgid ""
"Notice that ``M`` is a correct body for the component ``M2`` since its ``T`` "
"component is equal ``nat`` and hence ``M1.T`` as specified."
msgstr ""

#: ../../language/gallina-extensions.rst:1128
msgid "Modules and module types can be nested components of each other."
msgstr ""

#: ../../language/gallina-extensions.rst:1129
msgid ""
"One can have sections inside a module or a module type, but not a module or "
"a module type inside a section."
msgstr ""

#: ../../language/gallina-extensions.rst:1131
msgid ""
"Commands like ``Hint`` or ``Notation`` can also appear inside modules and "
"module types. Note that in case of a module definition like:"
msgstr ""

#: ../../language/gallina-extensions.rst:1138
msgid "or::"
msgstr ""

#: ../../language/gallina-extensions.rst:1142
msgid ""
"hints and the like valid for ``N`` are not those defined in ``M`` (or the "
"module body) but the ones defined in ``SIG``."
msgstr ""

#: ../../language/gallina-extensions.rst:1150
msgid ""
"If `qualid` denotes a valid basic module (i.e. its module type is a "
"signature), makes its components available by their short names."
msgstr ""

#: ../../language/gallina-extensions.rst:1173
msgid ""
"Some features defined in modules are activated only when a module is "
"imported. This is for instance the case of notations (see :ref:`Notations`)."
msgstr ""

#: ../../language/gallina-extensions.rst:1176
msgid ""
"Declarations made with the ``Local`` flag are never imported by the :cmd:"
"`Import` command. Such declarations are only accessible through their fully "
"qualified name."
msgstr ""

#: ../../language/gallina-extensions.rst:1201
msgid ""
"When the module containing the command Export qualid is imported, qualid is "
"imported as well."
msgstr ""

#: ../../language/gallina-extensions.rst:1210
msgid ""
"Prints the module type and (optionally) the body of the module :n:`@ident`."
msgstr ""

#: ../../language/gallina-extensions.rst:1214
msgid "Prints the module type corresponding to :n:`@ident`."
msgstr ""

#: ../../language/gallina-extensions.rst:1218
msgid ""
"This option (off by default) disables the printing of the types of fields, "
"leaving only their names, for the commands :cmd:`Print Module` and :cmd:"
"`Print Module Type`."
msgstr ""

#: ../../language/gallina-extensions.rst:1223
msgid "Libraries and qualified names"
msgstr ""

#: ../../language/gallina-extensions.rst:1228
msgid "Names of libraries"
msgstr ""

#: ../../language/gallina-extensions.rst:1230
msgid ""
"The theories developed in |Coq| are stored in *library files* which are "
"hierarchically classified into *libraries* and *sublibraries*. To express "
"this hierarchy, library names are represented by qualified identifiers "
"qualid, i.e. as list of identifiers separated by dots (see :ref:`gallina-"
"identifiers`). For instance, the library file ``Mult`` of the standard |Coq| "
"library ``Arith`` is named ``Coq.Arith.Mult``. The identifier that starts "
"the name of a library is called a *library root*. All library files of the "
"standard library of |Coq| have the reserved root |Coq| but library filenames "
"based on other roots can be obtained by using |Coq| commands (coqc, coqtop, "
"coqdep, …) options ``-Q`` or ``-R`` (see :ref:`command-line-options`). Also, "
"when an interactive |Coq| session starts, a library of root ``Top`` is "
"started, unless option ``-top`` or ``-notop`` is set (see :ref:`command-line-"
"options`)."
msgstr ""

#: ../../language/gallina-extensions.rst:1246
msgid "Qualified names"
msgstr ""

#: ../../language/gallina-extensions.rst:1248
msgid ""
"Library files are modules which possibly contain submodules which eventually "
"contain constructions (axioms, parameters, definitions, lemmas, theorems, "
"remarks or facts). The *absolute name*, or *full name*, of a construction in "
"some library file is a qualified identifier starting with the logical name "
"of the library file, followed by the sequence of submodules names "
"encapsulating the construction and ended by the proper name of the "
"construction. Typically, the absolute name ``Coq.Init.Logic.eq`` denotes "
"Leibniz’ equality defined in the module Logic in the sublibrary ``Init`` of "
"the standard library of |Coq|."
msgstr ""

#: ../../language/gallina-extensions.rst:1259
msgid ""
"The proper name that ends the name of a construction is the short name (or "
"sometimes base name) of the construction (for instance, the short name of "
"``Coq.Init.Logic.eq`` is ``eq``). Any partial suffix of the absolute name is "
"a *partially qualified name* (e.g. ``Logic.eq`` is a partially qualified "
"name for ``Coq.Init.Logic.eq``). Especially, the short name of a "
"construction is its shortest partially qualified name."
msgstr ""

#: ../../language/gallina-extensions.rst:1266
msgid ""
"|Coq| does not accept two constructions (definition, theorem, …) with the "
"same absolute name but different constructions can have the same short name "
"(or even same partially qualified names as soon as the full names are "
"different)."
msgstr ""

#: ../../language/gallina-extensions.rst:1271
msgid ""
"Notice that the notion of absolute, partially qualified and short names also "
"applies to library filenames."
msgstr ""

#: ../../language/gallina-extensions.rst:1274
msgid "**Visibility**"
msgstr ""

#: ../../language/gallina-extensions.rst:1276
msgid ""
"|Coq| maintains a table called the name table which maps partially qualified "
"names of constructions to absolute names. This table is updated by the "
"commands :cmd:`Require`, :cmd:`Import` and :cmd:`Export` and also each time "
"a new declaration is added to the context. An absolute name is called "
"visible from a given short or partially qualified name when this latter name "
"is enough to denote it. This means that the short or partially qualified "
"name is mapped to the absolute name in |Coq| name table. Definitions flagged "
"as Local are only accessible with their fully qualified name (see :ref:"
"`gallina-definitions`)."
msgstr ""

#: ../../language/gallina-extensions.rst:1286
msgid ""
"It may happen that a visible name is hidden by the short name or a qualified "
"name of another construction. In this case, the name that has been hidden "
"must be referred to using one more level of qualification. To ensure that a "
"construction always remains accessible, absolute names can never be hidden."
msgstr ""

#: ../../language/gallina-extensions.rst:1306
msgid "Commands :cmd:`Locate` and :cmd:`Locate Library`."
msgstr ""

#: ../../language/gallina-extensions.rst:1311
msgid "Libraries and filesystem"
msgstr ""

#: ../../language/gallina-extensions.rst:1313
msgid ""
"The questions described here have been subject to redesign in |Coq| 8.5. "
"Former versions of |Coq| use the same terminology to describe slightly "
"different things."
msgstr ""

#: ../../language/gallina-extensions.rst:1316
msgid ""
"Compiled files (``.vo`` and ``.vio``) store sub-libraries. In order to refer "
"to them inside |Coq|, a translation from file-system names to |Coq| names is "
"needed. In this translation, names in the file system are called *physical* "
"paths while |Coq| names are contrastingly called *logical* names."
msgstr ""

#: ../../language/gallina-extensions.rst:1322
msgid ""
"A logical prefix Lib can be associated to a physical pathpath using the "
"command line option ``-Q`` `path` ``Lib``. All subfolders of path are "
"recursively associated to the logical path ``Lib`` extended with the "
"corresponding suffix coming from the physical path. For instance, the folder "
"``path/fOO/Bar`` maps to ``Lib.fOO.Bar``. Subdirectories corresponding to "
"invalid |Coq| identifiers are skipped, and, by convention, subdirectories "
"named ``CVS`` or ``_darcs`` are skipped too."
msgstr ""

#: ../../language/gallina-extensions.rst:1330
msgid ""
"Thanks to this mechanism, ``.vo`` files are made available through the "
"logical name of the folder they are in, extended with their own basename. "
"For example, the name associated to the file ``path/fOO/Bar/File.vo`` is "
"``Lib.fOO.Bar.File``. The same caveat applies for invalid identifiers. When "
"compiling a source file, the ``.vo`` file stores its logical name, so that "
"an error is issued if it is loaded with the wrong loadpath afterwards."
msgstr ""

#: ../../language/gallina-extensions.rst:1338
msgid ""
"Some folders have a special status and are automatically put in the path. |"
"Coq| commands associate automatically a logical path to files in the "
"repository trees rooted at the directory from where the command is launched, "
"``coqlib/user-contrib/``, the directories listed in the ``$COQPATH``, ``"
"${XDG_DATA_HOME}/coq/`` and ``${XDG_DATA_DIRS}/coq/`` environment variables "
"(see `XDG base directory specification <http://standards.freedesktop.org/"
"basedir-spec/basedir-spec-latest.html>`_) with the same physical-to-logical "
"translation and with an empty logical prefix."
msgstr ""

#: ../../language/gallina-extensions.rst:1347
msgid ""
"The command line option ``-R`` is a variant of ``-Q`` which has the strictly "
"same behavior regarding loadpaths, but which also makes the corresponding ``."
"vo`` files available through their short names in a way not unlike the "
"``Import`` command (see :ref:`here <import_qualid>`). For instance, ``-R`` "
"`path` ``Lib`` associates to the file path `path`\\ ``/path/fOO/Bar/File."
"vo`` the logical name ``Lib.fOO.Bar.File``, but allows this file to be "
"accessed through the short names ``fOO.Bar.File,Bar.File`` and ``File``. If "
"several files with identical base name are present in different "
"subdirectories of a recursive loadpath, which of these files is found first "
"may be system- dependent and explicit qualification is recommended. The "
"``From`` argument of the ``Require`` command can be used to bypass the "
"implicit shortening by providing an absolute root to the required file (see :"
"ref:`compiled-files`)."
msgstr ""

#: ../../language/gallina-extensions.rst:1360
msgid ""
"There also exists another independent loadpath mechanism attached to OCaml "
"object files (``.cmo`` or ``.cmxs``) rather than |Coq| object files as "
"described above. The OCaml loadpath is managed using the option ``-I`` "
"`path` (in the OCaml world, there is neither a notion of logical name prefix "
"nor a way to access files in subdirectories of path). See the command "
"``Declare`` ``ML`` ``Module`` in :ref:`compiled-files` to understand the "
"need of the OCaml loadpath."
msgstr ""

#: ../../language/gallina-extensions.rst:1368
msgid ""
"See :ref:`command-line-options` for a more general view over the |Coq| "
"command line options."
msgstr ""

#: ../../language/gallina-extensions.rst:1374
msgid "Implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1376
msgid ""
"An implicit argument of a function is an argument which can be inferred from "
"contextual knowledge. There are different kinds of implicit arguments that "
"can be considered implicit in different ways. There are also various "
"commands to control the setting or the inference of implicit arguments."
msgstr ""

#: ../../language/gallina-extensions.rst:1384
msgid "The different kinds of implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1387
msgid ""
"Implicit arguments inferable from the knowledge of other arguments of a "
"function"
msgstr ""

#: ../../language/gallina-extensions.rst:1389
msgid ""
"The first kind of implicit arguments covers the arguments that are inferable "
"from the knowledge of the type of other arguments of the function, or of the "
"type of the surrounding context of the application. Especially, such "
"implicit arguments correspond to parameters dependent in the type of the "
"function. Typical implicit arguments are the type arguments in polymorphic "
"functions. There are several kinds of such implicit arguments."
msgstr ""

#: ../../language/gallina-extensions.rst:1397
msgid "**Strict Implicit Arguments**"
msgstr ""

#: ../../language/gallina-extensions.rst:1399
msgid ""
"An implicit argument can be either strict or non strict. An implicit "
"argument is said to be *strict* if, whatever the other arguments of the "
"function are, it is still inferable from the type of some other argument. "
"Technically, an implicit argument is strict if it corresponds to a parameter "
"which is not applied to a variable which itself is another parameter of the "
"function (since this parameter may erase its arguments), not in the body of "
"a match, and not itself applied or matched against patterns (since the "
"original form of the argument can be lost by reduction)."
msgstr ""

#: ../../language/gallina-extensions.rst:1409
msgid "For instance, the first argument of ::"
msgstr ""

#: ../../language/gallina-extensions.rst:1414
msgid ""
"in module ``List.v`` is strict because :g:`list` is an inductive type and :g:"
"`A` will always be inferable from the type :g:`list A` of the third argument "
"of :g:`cons`. Also, the first argument of :g:`cons` is strict with respect "
"to the second one, since the first argument is exactly the type of the "
"second argument. On the contrary, the second argument of a term of type ::"
msgstr ""

#: ../../language/gallina-extensions.rst:1423
msgid ""
"is implicit but not strict, since it can only be inferred from the type :g:"
"`P n` of the third argument and if :g:`P` is, e.g., :g:`fun _ => True`, it "
"reduces to an expression where ``n`` does not occur any longer. The first "
"argument :g:`P` is implicit but not strict either because it can only be "
"inferred from :g:`P n` and :g:`P` is not canonically inferable from an "
"arbitrary :g:`n` and the normal form of :g:`P n`. Consider, e.g., that :g:"
"`n` is :math:`0` and the third argument has type :g:`True`, then any :g:`P` "
"of the form ::"
msgstr ""

#: ../../language/gallina-extensions.rst:1434
msgid "would be a solution of the inference problem."
msgstr ""

#: ../../language/gallina-extensions.rst:1436
msgid "**Contextual Implicit Arguments**"
msgstr ""

#: ../../language/gallina-extensions.rst:1438
msgid ""
"An implicit argument can be *contextual* or not. An implicit argument is "
"said *contextual* if it can be inferred only from the knowledge of the type "
"of the context of the current expression. For instance, the only argument "
"of::"
msgstr ""

#: ../../language/gallina-extensions.rst:1445
msgid "is contextual. Similarly, both arguments of a term of type::"
msgstr ""

#: ../../language/gallina-extensions.rst:1449
msgid "are contextual (moreover, :g:`n` is strict and :g:`P` is not)."
msgstr ""

#: ../../language/gallina-extensions.rst:1451
msgid "**Reversible-Pattern Implicit Arguments**"
msgstr ""

#: ../../language/gallina-extensions.rst:1453
msgid ""
"There is another class of implicit arguments that can be reinferred "
"unambiguously if all the types of the remaining arguments are known. This is "
"the class of implicit arguments occurring in the type of another argument in "
"position of reversible pattern, which means it is at the head of an "
"application but applied only to uninstantiated distinct variables. Such an "
"implicit argument is called *reversible- pattern implicit argument*. A "
"typical example is the argument :g:`P` of nat_rec in ::"
msgstr ""

#: ../../language/gallina-extensions.rst:1466
msgid ""
"(:g:`P` is reinferable by abstracting over :g:`n` in the type :g:`P n`)."
msgstr ""

#: ../../language/gallina-extensions.rst:1468
msgid ""
"See :ref:`controlling-rev-pattern-implicit-args` for the automatic "
"declaration of reversible-pattern implicit arguments."
msgstr ""

#: ../../language/gallina-extensions.rst:1472
msgid "Implicit arguments inferable by resolution"
msgstr ""

#: ../../language/gallina-extensions.rst:1474
msgid ""
"This corresponds to a class of non-dependent implicit arguments that are "
"solved based on the structure of their type only."
msgstr ""

#: ../../language/gallina-extensions.rst:1479
msgid "Maximal or non maximal insertion of implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1481
msgid ""
"In case a function is partially applied, and the next argument to be applied "
"is an implicit argument, two disciplines are applicable. In the first case, "
"the function is considered to have no arguments furtherly: one says that the "
"implicit argument is not maximally inserted. In the second case, the "
"function is considered to be implicitly applied to the implicit arguments it "
"is waiting for: one says that the implicit argument is maximally inserted."
msgstr ""

#: ../../language/gallina-extensions.rst:1489
msgid ""
"Each implicit argument can be declared to have to be inserted maximally or "
"non maximally. This can be governed argument per argument by the command :"
"cmd:`Arguments (implicits)` or globally by the :flag:`Maximal Implicit "
"Insertion` option."
msgstr ""

#: ../../language/gallina-extensions.rst:1493
msgid ":ref:`displaying-implicit-args`."
msgstr ""

#: ../../language/gallina-extensions.rst:1497
msgid "Casual use of implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1499
msgid ""
"In a given expression, if it is clear that some argument of a function can "
"be inferred from the type of the other arguments, the user can force the "
"given argument to be guessed by replacing it by “_”. If possible, the "
"correct argument will be automatically generated."
msgstr ""

#: ../../language/gallina-extensions.rst:1507
msgid "|Coq| was not able to deduce an instantiation of a “_”."
msgstr ""

#: ../../language/gallina-extensions.rst:1512
msgid "Declaration of implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1514
msgid ""
"In case one wants that some arguments of a given object (constant, inductive "
"types, constructors, assumptions, local or not) are always inferred by |"
"Coq|, one may declare once and for all which are the expected implicit "
"arguments of this object. There are two ways to do this, *a priori* and *a "
"posteriori*."
msgstr ""

#: ../../language/gallina-extensions.rst:1522
msgid "Implicit Argument Binders"
msgstr ""

#: ../../language/gallina-extensions.rst:1524
msgid ""
"In the first setting, one wants to explicitly give the implicit arguments of "
"a declared object as part of its definition. To do this, one has to surround "
"the bindings of implicit arguments by curly braces:"
msgstr ""

#: ../../language/gallina-extensions.rst:1533
msgid ""
"This automatically declares the argument A of id as a maximally inserted "
"implicit argument. One can then do as-if the argument was absent in every "
"situation but still be able to specify it if needed:"
msgstr ""

#: ../../language/gallina-extensions.rst:1544
msgid ""
"The syntax is supported in all top-level definitions: :cmd:`Definition`, :"
"cmd:`Fixpoint`, :cmd:`Lemma` and so on. For (co-)inductive datatype "
"declarations, the semantics are the following: an inductive parameter "
"declared as an implicit argument need not be repeated in the inductive "
"definition but will become implicit for the constructors of the inductive "
"only, not the inductive type itself. For example:"
msgstr ""

#: ../../language/gallina-extensions.rst:1559
msgid ""
"One can always specify the parameter if it is not uniform using the usual "
"implicit arguments disambiguation syntax."
msgstr ""

#: ../../language/gallina-extensions.rst:1564
msgid "Declaring Implicit Arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1566
msgid "To set implicit arguments *a posteriori*, one can use the command:"
msgstr ""

#: ../../language/gallina-extensions.rst:1571
msgid ""
"where the list of `possibly_bracketed_ident` is a prefix of the list of "
"arguments of `qualid` where the ones to be declared implicit are surrounded "
"by square brackets and the ones to be declared as maximally inserted "
"implicits are surrounded by curly braces."
msgstr ""

#: ../../language/gallina-extensions.rst:1576
msgid ""
"After the above declaration is issued, implicit arguments can just (and have "
"to) be skipped in any expression involving an application of `qualid`."
msgstr ""

#: ../../language/gallina-extensions.rst:1580
msgid "Implicit arguments can be cleared with the following syntax:"
msgstr ""

#: ../../language/gallina-extensions.rst:1586
msgid ""
"Says to recompute the implicit arguments of `qualid` after ending of the "
"current section if any, enforcing the implicit arguments known from inside "
"the section to be the ones declared by the command."
msgstr ""

#: ../../language/gallina-extensions.rst:1593
msgid ""
"When in a module, tell not to activate the implicit arguments ofqualid "
"declared by this command to contexts that require the module."
msgstr ""

#: ../../language/gallina-extensions.rst:1599
msgid ""
"For names of constants, inductive types, constructors, lemmas which can only "
"be applied to a fixed number of arguments (this excludes for instance "
"constants whose type is polymorphic), multiple implicit arguments "
"declarations can be given. Depending on the number of arguments qualid is "
"applied to in practice, the longest applicable list of implicit arguments is "
"used to select which implicit arguments are inserted. For printing, the "
"omitted arguments are the ones of the longest list of implicit arguments of "
"the sequence."
msgstr ""

#: ../../language/gallina-extensions.rst:1639
msgid ""
"Remark: To know which are the implicit arguments of an object, use the "
"command ``Print Implicit`` (see :ref:`displaying-implicit-args`)."
msgstr ""

#: ../../language/gallina-extensions.rst:1644
msgid "Automatic declaration of implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1646
msgid ""
"|Coq| can also automatically detect what are the implicit arguments of a "
"defined object. The command is just"
msgstr ""

#: ../../language/gallina-extensions.rst:1651
msgid ""
"The auto-detection is governed by options telling if strict, contextual, or "
"reversible-pattern implicit arguments must be considered or not (see :ref:"
"`controlling-strict-implicit-args`, :ref:`controlling-strict-implicit-"
"args`, :ref:`controlling-rev-pattern-implicit-args`, and also :ref:"
"`controlling-insertion-implicit-args`)."
msgstr ""

#: ../../language/gallina-extensions.rst:1658
msgid ""
"Tell to recompute the implicit arguments of qualid after ending of the "
"current section if any."
msgstr ""

#: ../../language/gallina-extensions.rst:1664
msgid ""
"When in a module, tell not to activate the implicit arguments of `qualid` "
"computed by this declaration to contexts that requires the module."
msgstr ""

#: ../../language/gallina-extensions.rst:1689
msgid ""
"The computation of implicit arguments takes account of the unfolding of "
"constants. For instance, the variable ``p`` below has type ``(Transitivity "
"R)`` which is reducible to ``forall x,y:U, R x y -> forall z:U, R y z -> R x "
"z``. As the variables ``x``, ``y`` and ``z`` appear strictly in the body of "
"the type, they are implicit."
msgstr ""

#: ../../language/gallina-extensions.rst:1721
msgid "Mode for automatic declaration of implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1725
msgid ""
"This option (off by default) allows to systematically declare implicit the "
"arguments detectable as such. Auto-detection of implicit arguments is "
"governed by options controlling whether strict and contextual implicit "
"arguments have to be considered or not."
msgstr ""

#: ../../language/gallina-extensions.rst:1733
msgid "Controlling strict implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1737
msgid ""
"When the mode for automatic declaration of implicit arguments is on, the "
"default is to automatically set implicit only the strict implicit arguments "
"plus, for historical reasons, a small subset of the non-strict implicit "
"arguments. To relax this constraint and to set implicit all non strict "
"implicit arguments by default, you can turn this option off."
msgstr ""

#: ../../language/gallina-extensions.rst:1746
msgid ""
"Use this option (off by default) to capture exactly the strict implicit "
"arguments and no more than the strict implicit arguments."
msgstr ""

#: ../../language/gallina-extensions.rst:1752
msgid "Controlling contextual implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1756
msgid ""
"By default, |Coq| does not automatically set implicit the contextual "
"implicit arguments. You can turn this option on to tell |Coq| to also infer "
"contextual implicit argument."
msgstr ""

#: ../../language/gallina-extensions.rst:1763
msgid "Controlling reversible-pattern implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1767
msgid ""
"By default, |Coq| does not automatically set implicit the reversible-pattern "
"implicit arguments. You can turn this option on to tell |Coq| to also infer "
"reversible-pattern implicit argument."
msgstr ""

#: ../../language/gallina-extensions.rst:1774
msgid ""
"Controlling the insertion of implicit arguments not followed by explicit "
"arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1778
msgid ""
"Assuming the implicit argument mode is on, this option (off by default) "
"declares implicit arguments to be automatically inserted when a function is "
"partially applied and the next argument of the function is an implicit one."
msgstr ""

#: ../../language/gallina-extensions.rst:1786
msgid "Explicit applications"
msgstr ""

#: ../../language/gallina-extensions.rst:1788
msgid ""
"In presence of non-strict or contextual argument, or in presence of partial "
"applications, the synthesis of implicit arguments may fail, so one may have "
"to give explicitly certain implicit arguments of an application. The syntax "
"for this is ``(`` `ident` ``:=`` `term` ``)`` where `ident` is the name of "
"the implicit argument and term is its corresponding explicit term. "
"Alternatively, one can locally deactivate the hiding of implicit arguments "
"of a function by using the notation `@qualid` |term_1| … |term_n|. This "
"syntax extension is given in the following grammar:"
msgstr ""

#: ../../language/gallina-extensions.rst:1806
msgid "Syntax for explicitly giving implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1808
#: ../../language/gallina-extensions.rst:1828
msgid "Example: (continued)"
msgstr ""

#: ../../language/gallina-extensions.rst:1818
msgid "Renaming implicit arguments"
msgstr ""

#: ../../language/gallina-extensions.rst:1820
msgid "Implicit arguments names can be redefined using the following syntax:"
msgstr ""

#: ../../language/gallina-extensions.rst:1824
msgid ""
"With the assert flag, ``Arguments`` can be used to assert that a given "
"object has the expected number of arguments and that these arguments are "
"named as expected."
msgstr ""

#: ../../language/gallina-extensions.rst:1843
msgid "Displaying what the implicit arguments are"
msgstr ""

#: ../../language/gallina-extensions.rst:1845
msgid ""
"To display the implicit arguments associated to an object, and to know if "
"each of them is to be used maximally or not, use the command"
msgstr ""

#: ../../language/gallina-extensions.rst:1851
msgid "Explicit displaying of implicit arguments for pretty-printing"
msgstr ""

#: ../../language/gallina-extensions.rst:1855
msgid ""
"By default, the basic pretty-printing rules hide the inferable implicit "
"arguments of an application. Turn this option on to force printing all "
"implicit arguments."
msgstr ""

#: ../../language/gallina-extensions.rst:1861
msgid ""
"By default, the basic pretty-printing rules display the implicit arguments "
"that are not detected as strict implicit arguments. This “defensive” mode "
"can quickly make the display cumbersome so this can be deactivated by "
"turning this option off."
msgstr ""

#: ../../language/gallina-extensions.rst:1866
msgid ":flag:`Printing All`."
msgstr ""

#: ../../language/gallina-extensions.rst:1869
msgid "Interaction with subtyping"
msgstr ""

#: ../../language/gallina-extensions.rst:1871
msgid ""
"When an implicit argument can be inferred from the type of more than one of "
"the other arguments, then only the type of the first of these arguments is "
"taken into account, and not an upper type of all of them. As a consequence, "
"the inference of the implicit argument of “=” fails in"
msgstr ""

#: ../../language/gallina-extensions.rst:1881
msgid "but succeeds in"
msgstr ""

#: ../../language/gallina-extensions.rst:1889
msgid "Deactivation of implicit arguments for parsing"
msgstr ""

#: ../../language/gallina-extensions.rst:1893
msgid ""
"Turning this option on (it is off by default) deactivates the use of "
"implicit arguments."
msgstr ""

#: ../../language/gallina-extensions.rst:1895
msgid ""
"In this case, all arguments of constants, inductive types, constructors, "
"etc, including the arguments declared as implicit, have to be given as if no "
"arguments were implicit. By symmetry, this also affects printing."
msgstr ""

#: ../../language/gallina-extensions.rst:1901
msgid "Canonical structures"
msgstr ""

#: ../../language/gallina-extensions.rst:1903
msgid ""
"A canonical structure is an instance of a record/structure type that can be "
"used to solve unification problems involving a projection applied to an "
"unknown structure instance (an implicit argument) and a value. The complete "
"documentation of canonical structures can be found in :ref:"
"`canonicalstructures`; here only a simple example is given."
msgstr ""

#: ../../language/gallina-extensions.rst:1911
msgid "This command declares :token:`qualid` as a canonical structure."
msgstr ""

#: ../../language/gallina-extensions.rst:1913
msgid ""
"Assume that :token:`qualid` denotes an object ``(Build_struct`` |c_1| … |"
"c_n| ``)`` in the structure :g:`struct` of which the fields are |x_1|, …, |"
"x_n|. Then, each time an equation of the form ``(``\\ |x_i| ``_)`` |"
"eq_beta_delta_iota_zeta| |c_i| has to be solved during the type checking "
"process, :token:`qualid` is used as a solution. Otherwise said, :token:"
"`qualid` is canonically used to extend the field |c_i| into a complete "
"structure built on |c_i|."
msgstr ""

#: ../../language/gallina-extensions.rst:1920
msgid ""
"Canonical structures are particularly useful when mixed with coercions and "
"strict implicit arguments."
msgstr ""

#: ../../language/gallina-extensions.rst:1925
msgid "Here is an example."
msgstr ""

#: ../../language/gallina-extensions.rst:1948
msgid ""
"Thanks to :g:`nat_setoid` declared as canonical, the implicit arguments :g:"
"`A` and :g:`B` can be synthesized in the next statement."
msgstr ""

#: ../../language/gallina-extensions.rst:1956
msgid ""
"If a same field occurs in several canonical structures, then only the "
"structure declared first as canonical is considered."
msgstr ""

#: ../../language/gallina-extensions.rst:1961
msgid ""
"This is equivalent to a regular definition of :token:`ident` followed by the "
"declaration :n:`Canonical Structure @ident`."
msgstr ""

#: ../../language/gallina-extensions.rst:1967
msgid ""
"This displays the list of global names that are components of some canonical "
"structure. For each of them, the canonical structure of which it is a "
"projection is indicated."
msgstr ""

#: ../../language/gallina-extensions.rst:1973
msgid "For instance, the above example gives the following output:"
msgstr ""

#: ../../language/gallina-extensions.rst:1981
msgid "Implicit types of variables"
msgstr ""

#: ../../language/gallina-extensions.rst:1983
msgid ""
"It is possible to bind variable names to a given type (e.g. in a development "
"using arithmetic, it may be convenient to bind the names `n` or `m` to the "
"type ``nat`` of natural numbers). The command for that is"
msgstr ""

#: ../../language/gallina-extensions.rst:1989
msgid ""
"The effect of the command is to automatically set the type of bound "
"variables starting with `ident` (either `ident` itself or `ident` followed "
"by one or more single quotes, underscore or digits) to be `type` (unless the "
"bound variable is already declared with an explicit type in which case, this "
"latter type is considered)."
msgstr ""

#: ../../language/gallina-extensions.rst:2011
msgid "This is useful for declaring the implicit type of a single variable."
msgstr ""

#: ../../language/gallina-extensions.rst:2015
msgid "Adds blocks of implicit types with different specifications."
msgstr ""

#: ../../language/gallina-extensions.rst:2020
msgid "Implicit generalization"
msgstr ""

#: ../../language/gallina-extensions.rst:2025
msgid ""
"Implicit generalization is an automatic elaboration of a statement with free "
"variables into a closed statement where these variables are quantified "
"explicitly. Implicit generalization is done inside binders starting with a "
"\\` and terms delimited by \\`{ } and \\`( ), always introducing maximally "
"inserted implicit arguments for the generalized variables. Inside implicit "
"generalization delimiters, free variables in the current context are "
"automatically quantified using a product or a lambda abstraction to generate "
"a closed term. In the following statement for example, the variables n and m "
"are automatically generalized and become explicit arguments of the lemma as "
"we are using \\`( ):"
msgstr ""

#: ../../language/gallina-extensions.rst:2043
msgid ""
"One can control the set of generalizable identifiers with the "
"``Generalizable`` vernacular command to avoid unexpected generalizations "
"when mistyping identifiers. There are several commands that specify which "
"variables should be generalizable."
msgstr ""

#: ../../language/gallina-extensions.rst:2050
msgid ""
"All variables are candidate for generalization if they appear free in the "
"context under a generalization delimiter. This may result in confusing "
"errors in case of typos. In such cases, the context will probably contain "
"some unexpected generalized variable."
msgstr ""

#: ../../language/gallina-extensions.rst:2058
msgid ""
"Disable implicit generalization  entirely. This is the default behavior."
msgstr ""

#: ../../language/gallina-extensions.rst:2062
msgid ""
"Allow generalization of the given identifiers only. Calling this command "
"multiple times adds to the allowed identifiers."
msgstr ""

#: ../../language/gallina-extensions.rst:2067
msgid "Allows exporting the choice of generalizable variables."
msgstr ""

#: ../../language/gallina-extensions.rst:2069
msgid ""
"One can also use implicit generalization for binders, in which case the "
"generalized variables are added as binders and set maximally implicit."
msgstr ""

#: ../../language/gallina-extensions.rst:2079
msgid ""
"The generalizing binders \\`{ } and \\`( ) work similarly to their explicit "
"counterparts, only binding the generalized variables implicitly, as "
"maximally-inserted arguments. In these binders, the binding name for the "
"bound object is optional, whereas the type is mandatory, dually to regular "
"binders."
msgstr ""

#: ../../language/gallina-extensions.rst:2088
msgid "Coercions"
msgstr ""

#: ../../language/gallina-extensions.rst:2090
msgid ""
"Coercions can be used to implicitly inject terms from one *class* in which "
"they reside into another one. A *class* is either a sort (denoted by the "
"keyword ``Sortclass``), a product type (denoted by the keyword "
"``Funclass``), or a type constructor (denoted by its name), e.g. an "
"inductive type or any constant with a type of the form ``forall (`` |x_1| : |"
"A_1| ) … ``(``\\ |x_n| : |A_n|\\ ``)``, `s` where `s` is a sort."
msgstr ""

#: ../../language/gallina-extensions.rst:2097
msgid ""
"Then the user is able to apply an object that is not a function, but can be "
"coerced to a function, and more generally to consider that a term of type "
"``A`` is of type ``B`` provided that there is a declared coercion between "
"``A`` and ``B``."
msgstr ""

#: ../../language/gallina-extensions.rst:2102
msgid ""
"More details and examples, and a description of the commands related to "
"coercions are provided in :ref:`implicitcoercions`."
msgstr ""

#: ../../language/gallina-extensions.rst:2108
msgid "Printing constructions in full"
msgstr ""

#: ../../language/gallina-extensions.rst:2112
msgid ""
"Coercions, implicit arguments, the type of pattern matching, but also "
"notations (see :ref:`syntaxextensionsandinterpretationscopes`) can obfuscate "
"the behavior of some tactics (typically the tactics applying to occurrences "
"of subterms are sensitive to the implicit arguments). Turning this option on "
"deactivates all high-level printing features such as coercions, implicit "
"arguments, returned type of pattern matching, notations and various "
"syntactic sugar for pattern matching or record projections. Otherwise said, :"
"flag:`Printing All` includes the effects of the options :flag:`Printing "
"Implicit`, :flag:`Printing Coercions`, :flag:`Printing Synth`, :flag:"
"`Printing Projections`, and :flag:`Printing Notations`. To reactivate the "
"high-level printing features, use the command ``Unset Printing All``."
msgstr ""

#: ../../language/gallina-extensions.rst:2127
msgid "Printing universes"
msgstr ""

#: ../../language/gallina-extensions.rst:2131
msgid ""
"Turn this option on to activate the display of the actual level of each "
"occurrence of :g:`Type`. See :ref:`Sorts` for details. This wizard option, "
"in combination with :flag:`Printing All` can help to diagnose failures to "
"unify terms apparently identical but internally different in the Calculus of "
"Inductive Constructions."
msgstr ""

#: ../../language/gallina-extensions.rst:2137
msgid ""
"The constraints on the internal level of the occurrences of Type (see :ref:"
"`Sorts`) can be printed using the command"
msgstr ""

#: ../../language/gallina-extensions.rst:2143
msgid ""
"If the optional ``Sorted`` option is given, each universe will be made "
"equivalent to a numbered label reflecting its level (with a linear ordering) "
"in the universe hierarchy."
msgstr ""

#: ../../language/gallina-extensions.rst:2147
msgid "This command also accepts an optional output filename:"
msgstr ""

#: ../../language/gallina-extensions.rst:2151
msgid ""
"If `string` ends in ``.dot`` or ``.gv``, the constraints are printed in the "
"DOT language, and can be processed by Graphviz tools. The format is "
"unspecified if `string` doesn’t end in ``.dot`` or ``.gv``."
msgstr ""

#: ../../language/gallina-extensions.rst:2158
msgid "Existential variables"
msgstr ""

#: ../../language/gallina-extensions.rst:2160
msgid ""
"|Coq| terms can include existential variables which represents unknown "
"subterms to eventually be replaced by actual subterms."
msgstr ""

#: ../../language/gallina-extensions.rst:2163
msgid ""
"Existential variables are generated in place of unsolvable implicit "
"arguments or “_” placeholders when using commands such as ``Check`` (see "
"Section :ref:`requests-to-the-environment`) or when using tactics such as :"
"tacn:`refine`, as well as in place of unsolvable instances when using "
"tactics such that :tacn:`eapply`. An existential variable is defined in a "
"context, which is the context of variables of the placeholder which "
"generated the existential variable, and a type, which is the expected type "
"of the placeholder."
msgstr ""

#: ../../language/gallina-extensions.rst:2172
msgid ""
"As a consequence of typing constraints, existential variables can be "
"duplicated in such a way that they possibly appear in different contexts "
"than their defining context. Thus, any occurrence of a given existential "
"variable comes with an instance of its original context. In the simple case, "
"when an existential variable denotes the placeholder which generated it, or "
"is used in the same context as the one in which it was generated, the "
"context is not displayed and the existential variable is represented by “?” "
"followed by an identifier."
msgstr ""

#: ../../language/gallina-extensions.rst:2189
msgid ""
"In the general case, when an existential variable ``?``\\ `ident` appears "
"outside of its context of definition, its instance, written under the form"
msgstr ""

#: ../../language/gallina-extensions.rst:2193
msgid "``{`` :n:`{*; @ident:=@term}` ``}``"
msgstr ""

#: ../../language/gallina-extensions.rst:2195
msgid ""
"is appending to its name, indicating how the variables of its defining "
"context are instantiated. The variables of the context of the existential "
"variables which are instantiated by themselves are not written, unless the "
"flag :flag:`Printing Existential Instances` is on (see Section :ref:"
"`explicit-display-existentials`), and this is why an existential variable "
"used in the same context as its context of definition is written with no "
"instance."
msgstr ""

#: ../../language/gallina-extensions.rst:2209
msgid ""
"Existential variables can be named by the user upon creation using the "
"syntax :n:`?[@ident]`. This is useful when the existential variable needs to "
"be explicitly handled later in the script (e.g. with a named-goal selector, "
"see :ref:`goal-selectors`)."
msgstr ""

#: ../../language/gallina-extensions.rst:2217
msgid "Explicit displaying of existential instances for pretty-printing"
msgstr ""

#: ../../language/gallina-extensions.rst:2221
msgid ""
"This option (off by default) activates the full display of how the context "
"of an existential variable is instantiated at each of the occurrences of the "
"existential variable."
msgstr ""

#: ../../language/gallina-extensions.rst:2227
msgid "Solving existential variables using tactics"
msgstr ""

#: ../../language/gallina-extensions.rst:2229
msgid ""
"Instead of letting the unification engine try to solve an existential "
"variable by itself, one can also provide an explicit hole together with a "
"tactic to solve it. Using the syntax ``ltac:(``\\ `tacexpr`\\ ``)``, the "
"user can put a tactic anywhere a term is expected. The order of resolution "
"is not specified and is implementation-dependent. The inner tactic may use "
"any variable defined in its scope, including repeated alternations between "
"variables introduced by term binding as well as those introduced by tactic "
"binding. The expression `tacexpr` can be any tactic expression as described "
"in :ref:`ltac`."
msgstr ""

#: ../../language/gallina-extensions.rst:2243
msgid ""
"This construction is useful when one wants to define complicated terms using "
"highly automated tactics without resorting to writing the proof-term by "
"means of the interactive proof engine."
msgstr ""

#: ../../language/gallina-extensions.rst:2247
msgid ""
"This mechanism is comparable to the ``Declare Implicit Tactic`` command "
"defined at :ref:`tactics-implicit-automation`, except that the used tactic "
"is local to each hole instead of being declared globally."
msgstr ""

#: ../../language/gallina-specification-language.rst:5
msgid "The Gallina specification language"
msgstr ""

#: ../../language/gallina-specification-language.rst:7
msgid ""
"This chapter describes Gallina, the specification language of Coq. It allows "
"developing mathematical theories and to prove specifications of programs. "
"The theories are built from axioms, hypotheses, parameters, lemmas, theorems "
"and definitions of constants, functions, predicates and sets. The syntax of "
"logical objects involved in theories is described in Section :ref:`term`. "
"The language of commands, called *The Vernacular* is described in Section :"
"ref:`vernacular`."
msgstr ""

#: ../../language/gallina-specification-language.rst:15
msgid ""
"In Coq, logical objects are typed to ensure their logical correctness.  The "
"rules implemented by the typing algorithm are described in Chapter :ref:"
"`calculusofinductiveconstructions`."
msgstr ""

#: ../../language/gallina-specification-language.rst:20
msgid "About the grammars in the manual"
msgstr ""

#: ../../language/gallina-specification-language.rst:22
msgid ""
"Grammars are presented in Backus-Naur form (BNF). Terminal symbols are set "
"in black ``typewriter font``. In addition, there are special notations for "
"regular expressions."
msgstr ""

#: ../../language/gallina-specification-language.rst:26
msgid ""
"An expression enclosed in square brackets ``[…]`` means at most one "
"occurrence of this expression (this corresponds to an optional component)."
msgstr ""

#: ../../language/gallina-specification-language.rst:30
msgid ""
"The notation “``entry sep … sep entry``” stands for a non empty sequence of "
"expressions parsed by entry and separated by the literal “``sep``” [1]_."
msgstr ""

#: ../../language/gallina-specification-language.rst:33
msgid ""
"Similarly, the notation “``entry … entry``” stands for a non empty sequence "
"of expressions parsed by the “``entry``” entry, without any separator "
"between."
msgstr ""

#: ../../language/gallina-specification-language.rst:37
msgid ""
"At the end, the notation “``[entry sep … sep entry]``” stands for a possibly "
"empty sequence of expressions parsed by the “``entry``” entry, separated by "
"the literal “``sep``”."
msgstr ""

#: ../../language/gallina-specification-language.rst:44
msgid "Lexical conventions"
msgstr ""

#: ../../language/gallina-specification-language.rst:48
msgid "Blanks"
msgstr ""

#: ../../language/gallina-specification-language.rst:47
msgid ""
"Space, newline and horizontal tabulation are considered as blanks. Blanks "
"are ignored but they separate tokens."
msgstr ""

#: ../../language/gallina-specification-language.rst:53
msgid "Comments"
msgstr ""

#: ../../language/gallina-specification-language.rst:51
msgid ""
"Comments in Coq are enclosed between ``(*`` and ``*)``, and can be nested. "
"They can contain any character. However, :token:`string` literals must be "
"correctly closed. Comments are treated as blanks."
msgstr ""

#: ../../language/gallina-specification-language.rst:75
msgid "Identifiers and access identifiers"
msgstr ""

#: ../../language/gallina-specification-language.rst:56
msgid ""
"Identifiers, written :token:`ident`, are sequences of letters, digits, ``_`` "
"and ``'``, that do not start with a digit or ``'``. That is, they are "
"recognized by the following lexical class:"
msgstr ""

#: ../../language/gallina-specification-language.rst:66
msgid ""
"All characters are meaningful. In particular, identifiers are case-"
"sensitive. The entry ``unicode-letter`` non-exhaustively includes Latin, "
"Greek, Gothic, Cyrillic, Arabic, Hebrew, Georgian, Hangul, Hiragana and "
"Katakana characters, CJK ideographs, mathematical letter-like symbols, "
"hyphens, non-breaking space, … The entry ``unicode-id-part`` non-"
"exhaustively includes symbols for prime letters and subscripts."
msgstr ""

#: ../../language/gallina-specification-language.rst:73
msgid ""
"Access identifiers, written :token:`access_ident`, are identifiers prefixed "
"by `.` (dot) without blank. They are used in the syntax of qualified "
"identifiers."
msgstr ""

#: ../../language/gallina-specification-language.rst:84
msgid "Natural numbers and integers"
msgstr ""

#: ../../language/gallina-specification-language.rst:78
msgid ""
"Numerals are sequences of digits. Integers are numerals optionally preceded "
"by a minus sign."
msgstr ""

#: ../../language/gallina-specification-language.rst:90
msgid "Strings"
msgstr ""

#: ../../language/gallina-specification-language.rst:87
msgid ""
"Strings are delimited by ``\"`` (double quote), and enclose a sequence of "
"any characters different from ``\"`` or the sequence ``\"\"`` to denote the "
"double quote character. In grammars, the entry for quoted strings is :"
"production:`string`."
msgstr ""

#: ../../language/gallina-specification-language.rst:98
msgid "Keywords"
msgstr ""

#: ../../language/gallina-specification-language.rst:93
msgid ""
"The following identifiers are reserved keywords, and cannot be employed "
"otherwise::"
msgstr ""

#: ../../language/gallina-specification-language.rst:112
msgid "Special tokens"
msgstr ""

#: ../../language/gallina-specification-language.rst:101
msgid "The following sequences of characters are special tokens::"
msgstr ""

#: ../../language/gallina-specification-language.rst:108
msgid ""
"Lexical ambiguities are resolved according to the “longest match” rule: when "
"a sequence of non alphanumerical characters can be decomposed into several "
"different ways, then the first token is the longest possible one (among all "
"tokens defined at this moment), and so on."
msgstr ""

#: ../../language/gallina-specification-language.rst:120
msgid "Syntax of terms"
msgstr ""

#: ../../language/gallina-specification-language.rst:122
msgid ""
"The following grammars describe the basic syntax of the terms of the "
"*Calculus of Inductive Constructions* (also called Cic). The formal "
"presentation of Cic is given in Chapter :ref:"
"`calculusofinductiveconstructions`. Extensions of this syntax are given in "
"Chapter :ref:`extensionsofgallina`. How to customize the syntax is described "
"in Chapter :ref:`syntaxextensionsandinterpretationscopes`."
msgstr ""

#: ../../language/gallina-specification-language.rst:187
msgid "Types"
msgstr ""

#: ../../language/gallina-specification-language.rst:189
msgid ""
"Coq terms are typed. Coq types are recognized by the same syntactic class "
"as :token:`term`. We denote by :production:`type` the semantic subclass of "
"types inside the syntactic class :token:`term`."
msgstr ""

#: ../../language/gallina-specification-language.rst:196
msgid "Qualified identifiers and simple identifiers"
msgstr ""

#: ../../language/gallina-specification-language.rst:198
msgid ""
"*Qualified identifiers* (:token:`qualid`) denote *global constants* "
"(definitions, lemmas, theorems, remarks or facts), *global variables* "
"(parameters or axioms), *inductive types* or *constructors of inductive "
"types*. *Simple identifiers* (or shortly :token:`ident`) are a syntactic "
"subset of qualified identifiers. Identifiers may also denote *local "
"variables*, while qualified identifiers do not."
msgstr ""

#: ../../language/gallina-specification-language.rst:206
msgid "Numerals"
msgstr ""

#: ../../language/gallina-specification-language.rst:208
msgid ""
"Numerals have no definite semantics in the calculus. They are mere notations "
"that can be bound to objects through the notation mechanism (see Chapter :"
"ref:`syntaxextensionsandinterpretationscopes` for details). Initially, "
"numerals are bound to Peano’s representation of natural numbers (see :ref:"
"`datatypes`)."
msgstr ""

#: ../../language/gallina-specification-language.rst:216
msgid ""
"Negative integers are not at the same level as :token:`num`, for this would "
"make precedence unnatural."
msgstr ""

#: ../../language/gallina-specification-language.rst:227
msgid "There are three sorts :g:`Set`, :g:`Prop` and :g:`Type`."
msgstr ""

#: ../../language/gallina-specification-language.rst:229
msgid ""
":g:`Prop` is the universe of *logical propositions*. The logical "
"propositions themselves are typing the proofs. We denote propositions by :"
"production:`form`. This constitutes a semantic subclass of the syntactic "
"class :token:`term`."
msgstr ""

#: ../../language/gallina-specification-language.rst:233
msgid ""
":g:`Set` is is the universe of *program types* or *specifications*. The "
"specifications themselves are typing the programs. We denote specifications "
"by :production:`specif`. This constitutes a semantic subclass of the "
"syntactic class :token:`term`."
msgstr ""

#: ../../language/gallina-specification-language.rst:238
msgid ":g:`Type` is the type of :g:`Prop` and :g:`Set`"
msgstr ""

#: ../../language/gallina-specification-language.rst:240
msgid "More on sorts can be found in Section :ref:`sorts`."
msgstr ""

#: ../../language/gallina-specification-language.rst:245
msgid "Binders"
msgstr ""

#: ../../language/gallina-specification-language.rst:247
msgid ""
"Various constructions such as :g:`fun`, :g:`forall`, :g:`fix` and :g:`cofix` "
"*bind* variables. A binding is represented by an identifier. If the binding "
"variable is not used in the expression, the identifier can be replaced by "
"the symbol :g:`_`. When the type of a bound variable cannot be synthesized "
"by the system, it can be specified with the notation :n:`(@ident : @type)`. "
"There is also a notation for a sequence of binding variables sharing the "
"same type: :n:`({+ @ident} : @type)`. A binder can also be any pattern "
"prefixed by a quote, e.g. :g:`'(x,y)`."
msgstr ""

#: ../../language/gallina-specification-language.rst:256
msgid ""
"Some constructions allow the binding of a variable to value. This is called "
"a “let-binder”. The entry :token:`binder` of the grammar accepts either an "
"assumption binder as defined above or a let-binder. The notation in the "
"latter case is :n:`(@ident := @term)`. In a let-binder, only one variable "
"can be introduced at the same time. It is also possible to give the type of "
"the variable as follows: :n:`(@ident : @type := @term)`."
msgstr ""

#: ../../language/gallina-specification-language.rst:264
msgid ""
"Lists of :token:`binder` are allowed. In the case of :g:`fun` and :g:"
"`forall`, it is intended that at least one binder of the list is an "
"assumption otherwise fun and forall gets identical. Moreover, parentheses "
"can be omitted in the case of a single sequence of bindings sharing the same "
"type (e.g.: :g:`fun (x y z : A) => t` can be shortened in :g:"
"`fun x y z : A => t`)."
msgstr ""

#: ../../language/gallina-specification-language.rst:273
msgid "Abstractions"
msgstr ""

#: ../../language/gallina-specification-language.rst:275
msgid ""
"The expression :n:`fun @ident : @type => @term` defines the *abstraction* of "
"the variable :token:`ident`, of type :token:`type`, over the term :token:"
"`term`. It denotes a function of the variable :token:`ident` that evaluates "
"to the expression :token:`term` (e.g. :g:`fun x : A => x` denotes the "
"identity function on type :g:`A`). The keyword :g:`fun` can be followed by "
"several binders as given in Section :ref:`binders`. Functions over several "
"variables are equivalent to an iteration of one-variable functions. For "
"instance the expression “fun :token:`ident`\\ :math:`_{1}` … :token:`ident`"
"\\ :math:`_{n}` : :token:`type` => :token:`term`” denotes the same function "
"as “ fun :token:`ident`\\ :math:`_{1}` : :token:`type` => … fun :token:"
"`ident`\\ :math:`_{n}` : :token:`type` => :token:`term`”. If a let-binder "
"occurs in the list of binders, it is expanded to a let-in definition (see "
"Section :ref:`let-in`)."
msgstr ""

#: ../../language/gallina-specification-language.rst:295
msgid "Products"
msgstr ""

#: ../../language/gallina-specification-language.rst:297
msgid ""
"The expression :n:`forall @ident : @type, @term` denotes the *product* of "
"the variable :token:`ident` of type :token:`type`, over the term :token:"
"`term`. As for abstractions, :g:`forall` is followed by a binder list, and "
"products over several variables are equivalent to an iteration of one-"
"variable products. Note that :token:`term` is intended to be a type."
msgstr ""

#: ../../language/gallina-specification-language.rst:303
msgid ""
"If the variable :token:`ident` occurs in :token:`term`, the product is "
"called *dependent product*. The intention behind a dependent product :g:"
"`forall x : A, B` is twofold. It denotes either the universal quantification "
"of the variable :g:`x` of type :g:`A` in the proposition :g:`B` or the "
"functional dependent product from :g:`A` to :g:`B` (a construction usually "
"written :math:`\\Pi_{x:A}.B` in set theory)."
msgstr ""

#: ../../language/gallina-specification-language.rst:311
msgid ""
"Non dependent product types have a special notation: :g:`A -> B` stands for :"
"g:`forall _ : A, B`. The *non dependent product* is used both to denote the "
"propositional implication and function types."
msgstr ""

#: ../../language/gallina-specification-language.rst:316
msgid "Applications"
msgstr ""

#: ../../language/gallina-specification-language.rst:318
msgid ""
"The expression :token:`term`\\ :math:`_0` :token:`term`\\ :math:`_1` denotes "
"the application of :token:`term`\\ :math:`_0` to :token:`term`\\ :math:`_1`."
msgstr ""

#: ../../language/gallina-specification-language.rst:321
msgid ""
"The expression :token:`term`\\ :math:`_0` :token:`term`\\ :math:`_1` ... :"
"token:`term`\\ :math:`_n` denotes the application of the term :token:`term`"
"\\ :math:`_0` to the arguments :token:`term`\\ :math:`_1` ... then :token:"
"`term`\\ :math:`_n`. It is equivalent to ( … ( :token:`term`\\ :math:`_0` :"
"token:`term`\\ :math:`_1` ) … ) :token:`term`\\ :math:`_n` : associativity "
"is to the left."
msgstr ""

#: ../../language/gallina-specification-language.rst:328
msgid ""
"The notation :n:`(@ident := @term)` for arguments is used for making "
"explicit the value of implicit arguments (see Section :ref:`explicit-"
"applications`)."
msgstr ""

#: ../../language/gallina-specification-language.rst:338
msgid "Type cast"
msgstr ""

#: ../../language/gallina-specification-language.rst:340
msgid ""
"The expression :n:`@term : @type` is a type cast expression. It enforces the "
"type of :token:`term` to be :token:`type`."
msgstr ""

#: ../../language/gallina-specification-language.rst:343
msgid ""
":n:`@term <: @type` locally sets up the virtual machine for checking that :"
"token:`term` has type :token:`type`."
msgstr ""

#: ../../language/gallina-specification-language.rst:346
msgid ""
":n:`@term <<: @type` uses native compilation for checking that :token:`term` "
"has type :token:`type`."
msgstr ""

#: ../../language/gallina-specification-language.rst:352
msgid "Inferable subterms"
msgstr ""

#: ../../language/gallina-specification-language.rst:354
msgid ""
"Expressions often contain redundant pieces of information. Subterms that can "
"be automatically inferred by Coq can be replaced by the symbol ``_`` and Coq "
"will guess the missing piece of information."
msgstr ""

#: ../../language/gallina-specification-language.rst:363
msgid "Let-in definitions"
msgstr ""

#: ../../language/gallina-specification-language.rst:365
msgid ""
":n:`let @ident := @term in @term’` denotes the local binding of :token:"
"`term` to the variable :token:`ident` in :token:`term`’. There is a "
"syntactic sugar for let-in definition of functions: :n:`let @ident {+ "
"@binder} := @term in @term’` stands for :n:`let @ident := fun {+ @binder} => "
"@term in @term’`."
msgstr ""

#: ../../language/gallina-specification-language.rst:374
msgid "Definition by case analysis"
msgstr ""

#: ../../language/gallina-specification-language.rst:376
msgid ""
"Objects of inductive types can be destructurated by a case-analysis "
"construction called *pattern matching* expression. A pattern matching "
"expression is used to analyze the structure of an inductive object and to "
"apply specific treatments accordingly."
msgstr ""

#: ../../language/gallina-specification-language.rst:381
msgid ""
"This paragraph describes the basic form of pattern matching. See Section :"
"ref:`Mult-match` and Chapter :ref:`extendedpatternmatching` for the "
"description of the general form. The basic form of pattern matching is "
"characterized by a single :token:`match_item` expression, a :token:"
"`mult_pattern` restricted to a single :token:`pattern` and :token:`pattern` "
"restricted to the form :n:`@qualid {* @ident}`."
msgstr ""

#: ../../language/gallina-specification-language.rst:388
msgid ""
"The expression match \":token:`term`:math:`_0` :token:`return_type` with :"
"token:`pattern`:math:`_1` => :token:`term`:math:`_1` :math:`|` … :math:`|` :"
"token:`pattern`:math:`_n` => :token:`term`:math:`_n` end\" denotes a "
"*pattern matching* over the term :token:`term`:math:`_0` (expected to be of "
"an inductive type :math:`I`). The terms :token:`term`:math:`_1`\\ …\\ :token:"
"`term`:math:`_n` are the *branches* of the pattern matching expression. Each "
"of :token:`pattern`:math:`_i` has a form :token:`qualid` :token:`ident` "
"where :token:`qualid` must denote a constructor. There should be exactly one "
"branch for every constructor of :math:`I`."
msgstr ""

#: ../../language/gallina-specification-language.rst:398
msgid ""
"The :token:`return_type` expresses the type returned by the whole match "
"expression. There are several cases. In the *non dependent* case, all "
"branches have the same type, and the :token:`return_type` is the common type "
"of branches. In this case, :token:`return_type` can usually be omitted as it "
"can be inferred from the type of the branches [2]_."
msgstr ""

#: ../../language/gallina-specification-language.rst:404
msgid ""
"In the *dependent* case, there are three subcases. In the first subcase, the "
"type in each branch may depend on the exact value being matched in the "
"branch. In this case, the whole pattern matching itself depends on the term "
"being matched. This dependency of the term being matched in the return type "
"is expressed with an “as :token:`ident`” clause where :token:`ident` is "
"dependent in the return type. For instance, in the following example:"
msgstr ""

#: ../../language/gallina-specification-language.rst:425
msgid ""
"the branches have respective types \":g:`or (eq bool true true) (eq bool "
"true false)`\" and \":g:`or (eq bool false true) (eq bool false false)`\" "
"while the whole pattern matching expression has type \":g:`or (eq bool b "
"true) (eq bool b false)`\", the identifier :g:`b` being used to represent "
"the dependency."
msgstr ""

#: ../../language/gallina-specification-language.rst:432
msgid ""
"When the term being matched is a variable, the ``as`` clause can be omitted "
"and the term being matched can serve itself as binding name in the return "
"type. For instance, the following alternative definition is accepted and has "
"the same meaning as the previous one."
msgstr ""

#: ../../language/gallina-specification-language.rst:445
msgid ""
"The second subcase is only relevant for annotated inductive types such as "
"the equality predicate (see Section :ref:`coq-equality`), the order "
"predicate on natural numbers or the type of lists of a given length (see "
"Section :ref:`matching-dependent`). In this configuration, the type of each "
"branch can depend on the type dependencies specific to the branch and the "
"whole pattern matching expression has a type determined by the specific "
"dependencies in the type of the term being matched. This dependency of the "
"return type in the annotations of the inductive type is expressed using a “:"
"g:`in` :math:`I` :g:`_ … _` :token:`pattern`:math:`_1` … :token:`pattern`:"
"math:`_n`” clause, where"
msgstr ""

#: ../../language/gallina-specification-language.rst:456
msgid ":math:`I` is the inductive type of the term being matched;"
msgstr ""

#: ../../language/gallina-specification-language.rst:458
msgid ""
"the :g:`_` are matching the parameters of the inductive type: the return "
"type is not dependent on them."
msgstr ""

#: ../../language/gallina-specification-language.rst:461
msgid ""
"the :token:`pattern`:math:`_i` are matching the annotations of the inductive "
"type: the return type is dependent on them"
msgstr ""

#: ../../language/gallina-specification-language.rst:464
msgid ""
"in the basic case which we describe below, each :token:`pattern`:math:`_i` "
"is a name :token:`ident`:math:`_i`; see :ref:`match-in-patterns` for the "
"general case"
msgstr ""

#: ../../language/gallina-specification-language.rst:468
msgid "For instance, in the following example:"
msgstr ""

#: ../../language/gallina-specification-language.rst:477
msgid ""
"the type of the branch is :g:`eq A x x` because the third argument of :g:"
"`eq` is :g:`x` in the type of the pattern :g:`eq_refl`. On the contrary, the "
"type of the whole pattern matching expression has type :g:`eq A y x` because "
"the third argument of eq is y in the type of H. This dependency of the case "
"analysis in the third argument of :g:`eq` is expressed by the identifier :g:"
"`z` in the return type."
msgstr ""

#: ../../language/gallina-specification-language.rst:484
msgid ""
"Finally, the third subcase is a combination of the first and second subcase. "
"In particular, it only applies to pattern matching on terms in a type with "
"annotations. For this third subcase, both the clauses ``as`` and ``in`` are "
"available."
msgstr ""

#: ../../language/gallina-specification-language.rst:489
msgid ""
"There are specific notations for case analysis on types with one or two "
"constructors: ``if … then … else …`` and ``let (…,…) := … in …`` (see "
"Sections :ref:`if-then-else` and :ref:`irrefutable-patterns`)."
msgstr ""

#: ../../language/gallina-specification-language.rst:498
msgid "Recursive functions"
msgstr ""

#: ../../language/gallina-specification-language.rst:500
msgid ""
"The expression “``fix`` :token:`ident`:math:`_1` :token:`binder`:math:`_1` "
"``:`` :token:`type`:math:`_1` ``:=`` :token:`term`:math:`_1` ``with … "
"with`` :token:`ident`:math:`_n` :token:`binder`:math:`_n` : :token:`type`:"
"math:`_n` ``:=`` :token:`term`:math:`_n` ``for`` :token:`ident`:math:`_i`” "
"denotes the :math:`i`-th component of a block of functions defined by mutual "
"structural recursion. It is the local counterpart of the :cmd:`Fixpoint` "
"command. When :math:`n=1`, the “``for`` :token:`ident`:math:`_i`” clause is "
"omitted."
msgstr ""

#: ../../language/gallina-specification-language.rst:508
msgid ""
"The expression “``cofix`` :token:`ident`:math:`_1` :token:`binder`:math:`_1` "
"``:`` :token:`type`:math:`_1` ``with … with`` :token:`ident`:math:`_n` :"
"token:`binder`:math:`_n` : :token:`type`:math:`_n` ``for`` :token:`ident`:"
"math:`_i`” denotes the :math:`i`-th component of a block of terms defined by "
"a mutual guarded co-recursion. It is the local counterpart of the :cmd:"
"`CoFixpoint` command. When :math:`n=1`, the “``for`` :token:`ident`:math:"
"`_i`” clause is omitted."
msgstr ""

#: ../../language/gallina-specification-language.rst:515
msgid ""
"The association of a single fixpoint and a local definition have a special "
"syntax: :n:`let fix @ident @binders := @term in` stands for :n:`let @ident :"
"= fix @ident @binders := @term in`. The same applies for co-fixpoints."
msgstr ""

#: ../../language/gallina-specification-language.rst:522
msgid "The Vernacular"
msgstr ""

#: ../../language/gallina-specification-language.rst:559
msgid ""
"This grammar describes *The Vernacular* which is the language of commands of "
"Gallina. A sentence of the vernacular language, like in many natural "
"languages, begins with a capital letter and ends with a dot."
msgstr ""

#: ../../language/gallina-specification-language.rst:564
msgid ""
"The different kinds of command are described hereafter. They all suppose "
"that the terms occurring in the sentences are well-typed."
msgstr ""

#: ../../language/gallina-specification-language.rst:570
msgid "Assumptions"
msgstr ""

#: ../../language/gallina-specification-language.rst:572
msgid ""
"Assumptions extend the environment with axioms, parameters, hypotheses or "
"variables. An assumption binds an :token:`ident` to a :token:`type`. It is "
"accepted by Coq if and only if this :token:`type` is a correct type in the "
"environment preexisting the declaration and if :token:`ident` was not "
"previously defined in the same module. This :token:`type` is considered to "
"be the type (or specification, or statement) assumed by :token:`ident` and "
"we say that :token:`ident` has type :token:`type`."
msgstr ""

#: ../../language/gallina-specification-language.rst:584
msgid ""
"This command links :token:`type` to the name :token:`ident` as its "
"specification in the global context. The fact asserted by :token:`type` is "
"thus assumed as a postulate."
msgstr ""

#: ../../language/gallina-specification-language.rst:594
msgid "Adds several parameters with specification :token:`type`."
msgstr ""

#: ../../language/gallina-specification-language.rst:598
msgid "Adds blocks of parameters with different specifications."
msgstr ""

#: ../../language/gallina-specification-language.rst:603
msgid ""
"Such parameters are never made accessible through their unqualified name by :"
"cmd:`Import` and its variants. You have to explicitly give their fully "
"qualified name to refer to them."
msgstr ""

#: ../../language/gallina-specification-language.rst:614
msgid ""
"These variants are synonyms of :n:`{? Local } Parameter {+ ( {+ @ident } : "
"@type ) }`."
msgstr ""

#: ../../language/gallina-specification-language.rst:618
msgid ""
"This command links :token:`type` to the name :token:`ident` in the context "
"of the current section (see Section :ref:`section-mechanism` for a "
"description of the section mechanism). When the current section is closed, "
"name :token:`ident` will be unknown and every object using this variable "
"will be explicitly parametrized (the variable is *discharged*). Using the :"
"cmd:`Variable` command out of any section is equivalent to using :cmd:`Local "
"Parameter`."
msgstr ""

#: ../../language/gallina-specification-language.rst:631
msgid "Links :token:`type` to each :token:`ident`."
msgstr ""

#: ../../language/gallina-specification-language.rst:635
msgid "Adds blocks of variables with different specifications."
msgstr ""

#: ../../language/gallina-specification-language.rst:642
msgid ""
"These variants are synonyms of :n:`Variable {+ ( {+ @ident } : @term) }`."
msgstr ""

#: ../../language/gallina-specification-language.rst:645
msgid ""
"It is advised to use the commands :cmd:`Axiom`, :cmd:`Conjecture` and :cmd:"
"`Hypothesis` (and their plural forms) for logical postulates (i.e. when the "
"assertion :token:`type` is of sort :g:`Prop`), and to use the commands :cmd:"
"`Parameter` and :cmd:`Variable` (and their plural forms) in other cases "
"(corresponding to the declaration of an abstract mathematical entity)."
msgstr ""

#: ../../language/gallina-specification-language.rst:654
msgid "Definitions"
msgstr ""

#: ../../language/gallina-specification-language.rst:656
msgid ""
"Definitions extend the environment with associations of names to terms. A "
"definition can be seen as a way to give a meaning to a name or as a way to "
"abbreviate a term. In any case, the name can later be replaced at any time "
"by its definition."
msgstr ""

#: ../../language/gallina-specification-language.rst:661
msgid ""
"The operation of unfolding a name into its definition is called :math:`"
"\\delta`-conversion (see Section :ref:`delta-reduction`). A definition is "
"accepted by the system if and only if the defined term is well-typed in the "
"current context of the definition and if the name is not already used. The "
"name defined by the definition is called a *constant* and the term it refers "
"to is its *body*. A definition has a type which is the type of its body."
msgstr ""

#: ../../language/gallina-specification-language.rst:669
msgid ""
"A formal presentation of constants and environments is given in Section :ref:"
"`typing-rules`."
msgstr ""

#: ../../language/gallina-specification-language.rst:674
msgid ""
"This command binds :token:`term` to the name :token:`ident` in the "
"environment, provided that :token:`term` is well-typed."
msgstr ""

#: ../../language/gallina-specification-language.rst:683
msgid ""
"This variant checks that the type of :token:`term` is definitionally equal "
"to :token:`type`, and registers :token:`ident` as being of type :token:"
"`type`, and bound to value :token:`term`."
msgstr ""

#: ../../language/gallina-specification-language.rst:692
msgid ""
"This is equivalent to :n:`Definition @ident : forall @binders, @term := fun "
"@binders => @term`."
msgstr ""

#: ../../language/gallina-specification-language.rst:698
msgid ""
"Such definitions are never made accessible through their unqualified name "
"by :cmd:`Import` and its variants. You have to explicitly give their fully "
"qualified name to refer to them."
msgstr ""

#: ../../language/gallina-specification-language.rst:705
msgid "This is equivalent to :cmd:`Definition`."
msgstr ""

#: ../../language/gallina-specification-language.rst:707
#: ../../language/gallina-specification-language.rst:1333
msgid ":cmd:`Opaque`, :cmd:`Transparent`, :tacn:`unfold`."
msgstr ""

#: ../../language/gallina-specification-language.rst:711
msgid ""
"This command binds the value :token:`term` to the name :token:`ident` in the "
"environment of the current section. The name :token:`ident` disappears when "
"the current section is eventually closed, and all persistent objects (such "
"as theorems) defined within the section and depending on :token:`ident` are "
"prefixed by the let-in definition :n:`let @ident := @term in`. Using the :"
"cmd:`Let` command out of any section is equivalent to using :cmd:`Local "
"Definition`."
msgstr ""

#: ../../language/gallina-specification-language.rst:734
msgid ""
"Section :ref:`section-mechanism`, commands :cmd:`Opaque`, :cmd:"
"`Transparent`, and tactic :tacn:`unfold`."
msgstr ""

#: ../../language/gallina-specification-language.rst:740
msgid "Inductive definitions"
msgstr ""

#: ../../language/gallina-specification-language.rst:742
msgid ""
"We gradually explain simple inductive types, simple annotated inductive "
"types, simple parametric inductive types, mutually inductive types. We "
"explain also co-inductive types."
msgstr ""

#: ../../language/gallina-specification-language.rst:747
msgid "Simple inductive types"
msgstr ""

#: ../../language/gallina-specification-language.rst:751
msgid ""
"This command defines a simple inductive type and its constructors. The "
"first :token:`ident` is the name of the inductively defined type and :token:"
"`sort` is the universe where it lives. The next :token:`ident`\\s are the "
"names of its constructors and :token:`type` their respective types. "
"Depending on the universe where the inductive type :token:`ident` lives (e."
"g. its type :token:`sort`), Coq provides a number of destructors. "
"Destructors are named :token:`ident`\\ ``_ind``, :token:`ident`\\ ``_rec`` "
"or :token:`ident`\\ ``_rect`` which respectively correspond to elimination "
"principles on :g:`Prop`, :g:`Set` and :g:`Type`. The type of the destructors "
"expresses structural induction/recursion principles over objects of type :"
"token:`ident`. The constant :token:`ident`\\ ``_ind`` is always provided, "
"whereas :token:`ident`\\ ``_rec`` and :token:`ident`\\ ``_rect`` can be "
"impossible to derive (for example, when :token:`ident` is a proposition)."
msgstr ""

#: ../../language/gallina-specification-language.rst:768
msgid ""
"The types of the constructors have to satisfy a *positivity condition* (see "
"Section :ref:`positivity`). This condition ensures the soundness of the "
"inductive definition."
msgstr ""

#: ../../language/gallina-specification-language.rst:774
msgid ""
"The conclusion of the type of the constructors must be the inductive type :"
"token:`ident` being defined (or :token:`ident` applied to arguments in the "
"case of annotated inductive types — cf. next section)."
msgstr ""

#: ../../language/gallina-specification-language.rst:780
msgid "The set of natural numbers is defined as:"
msgstr ""

#: ../../language/gallina-specification-language.rst:788
msgid ""
"The type nat is defined as the least :g:`Set` containing :g:`O` and closed "
"by the :g:`S` constructor. The names :g:`nat`, :g:`O` and :g:`S` are added "
"to the environment."
msgstr ""

#: ../../language/gallina-specification-language.rst:792
msgid ""
"Now let us have a look at the elimination principles. They are three of "
"them: :g:`nat_ind`, :g:`nat_rec` and :g:`nat_rect`. The type of :g:`nat_ind` "
"is:"
msgstr ""

#: ../../language/gallina-specification-language.rst:799
msgid ""
"This is the well known structural induction principle over natural numbers, "
"i.e. the second-order form of Peano’s induction principle. It allows proving "
"some universal property of natural numbers (:g:`forall n:nat, P n`) by "
"induction on :g:`n`."
msgstr ""

#: ../../language/gallina-specification-language.rst:804
msgid ""
"The types of :g:`nat_rec` and :g:`nat_rect` are similar, except that they "
"pertain to :g:`(P:nat->Set)` and :g:`(P:nat->Type)` respectively. They "
"correspond to primitive induction principles (allowing dependent types) "
"respectively over sorts ``Set`` and ``Type``."
msgstr ""

#: ../../language/gallina-specification-language.rst:811
msgid ""
"Constructors :token:`ident`\\s can come with :token:`binders` in which case, "
"the actual type of the constructor is :n:`forall @binders, @type`."
msgstr ""

#: ../../language/gallina-specification-language.rst:814
msgid ""
"In the case where inductive types have no annotations (next section gives an "
"example of such annotations), a constructor can be defined by only giving "
"the type of its arguments."
msgstr ""

#: ../../language/gallina-specification-language.rst:826
msgid "Simple annotated inductive types"
msgstr ""

#: ../../language/gallina-specification-language.rst:828
msgid ""
"In an annotated inductive types, the universe where the inductive type is "
"defined is no longer a simple sort, but what is called an arity, which is a "
"type whose conclusion is a sort."
msgstr ""

#: ../../language/gallina-specification-language.rst:834
msgid ""
"As an example of annotated inductive types, let us define the :g:`even` "
"predicate:"
msgstr ""

#: ../../language/gallina-specification-language.rst:843
msgid ""
"The type :g:`nat->Prop` means that even is a unary predicate (inductively "
"defined) over natural numbers. The type of its two constructors are the "
"defining clauses of the predicate even. The type of :g:`even_ind` is:"
msgstr ""

#: ../../language/gallina-specification-language.rst:851
msgid ""
"From a mathematical point of view it asserts that the natural numbers "
"satisfying the predicate even are exactly in the smallest set of naturals "
"satisfying the clauses :g:`even_0` or :g:`even_SS`. This is why, when we "
"want to prove any predicate :g:`P` over elements of :g:`even`, it is enough "
"to prove it for :g:`O` and to prove that if any natural number :g:`n` "
"satisfies :g:`P` its double successor :g:`(S (S n))` satisfies also :g:`P`. "
"This is indeed analogous to the structural induction principle we got for :g:"
"`nat`."
msgstr ""

#: ../../language/gallina-specification-language.rst:860
msgid "Parametrized inductive types"
msgstr ""

#: ../../language/gallina-specification-language.rst:864
msgid ""
"In the previous example, each constructor introduces a different instance of "
"the predicate :g:`even`. In some cases, all the constructors introduce the "
"same generic instance of the inductive definition, in which case, instead of "
"an annotation, we use a context of parameters which are :token:`binders` "
"shared by all the constructors of the definition."
msgstr ""

#: ../../language/gallina-specification-language.rst:870
msgid ""
"Parameters differ from inductive type annotations in the fact that the "
"conclusion of each type of constructor invoke the inductive type with the "
"same values of parameters as its specification."
msgstr ""

#: ../../language/gallina-specification-language.rst:876
msgid "A typical example is the definition of polymorphic lists:"
msgstr ""

#: ../../language/gallina-specification-language.rst:884
msgid ""
"In the type of :g:`nil` and :g:`cons`, we write :g:`(list A)` and not just :"
"g:`list`. The constructors :g:`nil` and :g:`cons` will have respectively "
"types:"
msgstr ""

#: ../../language/gallina-specification-language.rst:893
msgid "Types of destructors are also quantified with :g:`(A:Set)`."
msgstr ""

#: ../../language/gallina-specification-language.rst:895
msgid ""
"Once again, it is possible to specify only the type of the arguments of the "
"constructors, and to omit the type of the conclusion:"
msgstr ""

#: ../../language/gallina-specification-language.rst:903
msgid ""
"It is possible in the type of a constructor, to invoke recursively the "
"inductive definition on an argument which is not the parameter itself."
msgstr ""

#: ../../language/gallina-specification-language.rst:907
msgid "One can define :"
msgstr ""

#: ../../language/gallina-specification-language.rst:915
msgid "that can also be written by specifying only the type of the arguments:"
msgstr ""

#: ../../language/gallina-specification-language.rst:921
msgid "But the following definition will give an error:"
msgstr ""

#: ../../language/gallina-specification-language.rst:929
msgid ""
"because the conclusion of the type of constructors should be :g:`listw A` in "
"both cases."
msgstr ""

#: ../../language/gallina-specification-language.rst:932
msgid ""
"A parametrized inductive definition can be defined using annotations instead "
"of parameters but it will sometimes give a different (bigger) sort for the "
"inductive definition and will produce a less convenient rule for case "
"elimination."
msgstr ""

#: ../../language/gallina-specification-language.rst:938
msgid "Section :ref:`inductive-definitions` and the :tacn:`induction` tactic."
msgstr ""

#: ../../language/gallina-specification-language.rst:941
msgid "Variants"
msgstr ""

#: ../../language/gallina-specification-language.rst:945
msgid ""
"The :cmd:`Variant` command is identical to the :cmd:`Inductive` command, "
"except that it disallows recursive definition of types (for instance, lists "
"cannot be defined using :cmd:`Variant`). No induction scheme is generated "
"for this variant, unless option :flag:`Nonrecursive Elimination Schemes` is "
"on."
msgstr ""

#: ../../language/gallina-specification-language.rst:954
msgid "Mutually defined inductive types"
msgstr ""

#: ../../language/gallina-specification-language.rst:958
msgid ""
"This variant allows defining a block of mutually inductive types. It has the "
"same semantics as the above :cmd:`Inductive` definition for each :token:"
"`ident`. All :token:`ident` are simultaneously added to the environment. "
"Then well-typing of constructors can be checked. Each one of the :token:"
"`ident` can be used on its own."
msgstr ""

#: ../../language/gallina-specification-language.rst:966
msgid ""
"In this variant, the inductive definitions are parametrized with :token:"
"`binders`. However, parameters correspond to a local context in which the "
"whole set of inductive declarations is done. For this reason, the parameters "
"must be strictly the same for each inductive types."
msgstr ""

#: ../../language/gallina-specification-language.rst:973
msgid ""
"The typical example of a mutual inductive data type is the one for trees and "
"forests. We assume given two types :g:`A` and :g:`B` as variables. It can be "
"declared the following way."
msgstr ""

#: ../../language/gallina-specification-language.rst:987
msgid ""
"This declaration generates automatically six induction principles. They are "
"respectively called :g:`tree_rec`, :g:`tree_ind`, :g:`tree_rect`, :g:"
"`forest_rec`, :g:`forest_ind`, :g:`forest_rect`. These ones are not the most "
"general ones but are just the induction principles corresponding to each "
"inductive part seen as a single inductive definition."
msgstr ""

#: ../../language/gallina-specification-language.rst:993
msgid ""
"To illustrate this point on our example, we give the types of :g:`tree_rec` "
"and :g:`forest_rec`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1002
msgid ""
"Assume we want to parametrize our mutual inductive definitions with the two "
"type variables :g:`A` and :g:`B`, the declaration should be done the "
"following way:"
msgstr ""

#: ../../language/gallina-specification-language.rst:1014
msgid ""
"Assume we define an inductive definition inside a section (cf. :ref:`section-"
"mechanism`). When the section is closed, the variables declared in the "
"section and occurring free in the declaration are added as parameters to the "
"inductive definition."
msgstr ""

#: ../../language/gallina-specification-language.rst:1020
msgid ""
"A generic command :cmd:`Scheme` is useful to build automatically various "
"mutual induction principles."
msgstr ""

#: ../../language/gallina-specification-language.rst:1028
msgid ""
"The objects of an inductive type are well-founded with respect to the "
"constructors of the type. In other words, such objects contain only a "
"*finite* number of constructors. Co-inductive types arise from relaxing this "
"condition, and admitting types whose objects contain an infinity of "
"constructors. Infinite objects are introduced by a non-ending (but "
"effective) process of construction, defined in terms of the constructors of "
"the type."
msgstr ""

#: ../../language/gallina-specification-language.rst:1038
msgid ""
"This command introduces a co-inductive type. The syntax of the command is "
"the same as the command :cmd:`Inductive`. No principle of induction is "
"derived from the definition of a co-inductive type, since such principles "
"only make sense for inductive types. For co-inductive types, the only "
"elimination principle is case analysis."
msgstr ""

#: ../../language/gallina-specification-language.rst:1046
msgid ""
"An example of a co-inductive type is the type of infinite sequences of "
"natural numbers, usually called streams."
msgstr ""

#: ../../language/gallina-specification-language.rst:1053
msgid ""
"The usual destructors on streams :g:`hd:Stream->nat` and :g:`tl:Str->Str` "
"can be defined as follows:"
msgstr ""

#: ../../language/gallina-specification-language.rst:1061
msgid ""
"Definition of co-inductive predicates and blocks of mutually co-inductive "
"definitions are also allowed."
msgstr ""

#: ../../language/gallina-specification-language.rst:1066
msgid ""
"An example of a co-inductive predicate is the extensional equality on "
"streams:"
msgstr ""

#: ../../language/gallina-specification-language.rst:1075
msgid ""
"In order to prove the extensional equality of two streams :g:`s1` and :g:"
"`s2` we have to construct an infinite proof of equality, that is, an "
"infinite object of type :g:`(EqSt s1 s2)`. We will see how to introduce "
"infinite objects in Section :ref:`cofixpoint`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1081
msgid "Definition of recursive functions"
msgstr ""

#: ../../language/gallina-specification-language.rst:1084
msgid "Definition of functions by recursion over inductive objects"
msgstr ""

#: ../../language/gallina-specification-language.rst:1086
msgid ""
"This section describes the primitive form of definition by recursion over "
"inductive objects. See the :cmd:`Function` command for more advanced "
"constructions."
msgstr ""

#: ../../language/gallina-specification-language.rst:1094
msgid ""
"This command allows defining functions by pattern matching over inductive "
"objects using a fixed point construction. The meaning of this declaration is "
"to define :token:`ident` a recursive function with arguments specified by "
"the :token:`binders` such that :token:`ident` applied to arguments "
"corresponding to these :token:`binders` has type :token:`type`, and is "
"equivalent to the expression :token:`term`. The type of :token:`ident` is "
"consequently :n:`forall @binders, @type` and its value is equivalent to :n:"
"`fun @binders => @term`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1103
msgid ""
"To be accepted, a :cmd:`Fixpoint` definition has to satisfy some syntactical "
"constraints on a special argument called the decreasing argument. They are "
"needed to ensure that the :cmd:`Fixpoint` definition always terminates. The "
"point of the :n:`{struct @ident}` annotation is to let the user tell the "
"system which argument decreases along the recursive calls."
msgstr ""

#: ../../language/gallina-specification-language.rst:1109
msgid ""
"The :n:`{struct @ident}` annotation may be left implicit, in this case the "
"system tries successively arguments from left to right until it finds one "
"that satisfies the decreasing condition."
msgstr ""

#: ../../language/gallina-specification-language.rst:1115
msgid ""
"Some fixpoints may have several arguments that fit as decreasing arguments, "
"and this choice influences the reduction of the fixpoint. Hence an explicit "
"annotation must be used if the leftmost decreasing argument is not the "
"desired one. Writing explicit annotations can also speed up type checking of "
"large mutual fixpoints."
msgstr ""

#: ../../language/gallina-specification-language.rst:1121
msgid ""
"In order to keep the strong normalization property, the fixed point "
"reduction will only be performed when the argument in position of the "
"decreasing argument (which type should be in an inductive definition) starts "
"with a constructor."
msgstr ""

#: ../../language/gallina-specification-language.rst:1129
msgid "One can define the addition function as :"
msgstr ""

#: ../../language/gallina-specification-language.rst:1139
msgid ""
"The match operator matches a value (here :g:`n`) with the various "
"constructors of its (inductive) type. The remaining arguments give the "
"respective values to be returned, as functions of the parameters of the "
"corresponding constructor. Thus here when :g:`n` equals :g:`O` we return :g:"
"`m`, and when :g:`n` equals :g:`(S p)` we return :g:`(S (add p m))`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1145
msgid ""
"The match operator is formally described in Section :ref:`match-"
"construction`. The system recognizes that in the inductive call :g:`(add p "
"m)` the first argument actually decreases because it is a *pattern variable* "
"coming from :g:`match n with`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1153
msgid "The following definition is not correct and generates an error message:"
msgstr ""

#: ../../language/gallina-specification-language.rst:1163
msgid ""
"because the declared decreasing argument :g:`n` does not actually decrease "
"in the recursive call. The function computing the addition over the second "
"argument should rather be written:"
msgstr ""

#: ../../language/gallina-specification-language.rst:1177
msgid ""
"The recursive call may not only be on direct subterms of the recursive "
"variable :g:`n` but also on a deeper subterm and we can directly write the "
"function :g:`mod2` which gives the remainder modulo 2 of a natural number."
msgstr ""

#: ../../language/gallina-specification-language.rst:1196
msgid ""
"This variant allows defining simultaneously several mutual fixpoints. It is "
"especially useful when defining functions over mutually defined inductive "
"types."
msgstr ""

#: ../../language/gallina-specification-language.rst:1202
msgid "The size of trees and forests can be defined the following way:"
msgstr ""

#: ../../language/gallina-specification-language.rst:1219
msgid "Definitions of recursive objects in co-inductive types"
msgstr ""

#: ../../language/gallina-specification-language.rst:1223
msgid ""
"This command introduces a method for constructing an infinite object of a "
"coinductive type. For example, the stream containing all natural numbers can "
"be introduced applying the following method to the number :g:`O` (see "
"Section :ref:`coinductive-types` for the definition of :g:`Stream`, :g:`hd` "
"and :g:`tl`):"
msgstr ""

#: ../../language/gallina-specification-language.rst:1233
msgid ""
"Oppositely to recursive ones, there is no decreasing argument in a co-"
"recursive definition. To be admissible, a method of construction must "
"provide at least one extra constructor of the infinite object for each "
"iteration. A syntactical guard condition is imposed on co-recursive "
"definitions in order to ensure this: each recursive call in the definition "
"must be protected by at least one constructor, and only by constructors. "
"That is the case in the former definition, where the single recursive call "
"of :g:`from` is guarded by an application of :g:`Seq`. On the contrary, the "
"following recursive function does not satisfy the guard condition:"
msgstr ""

#: ../../language/gallina-specification-language.rst:1249
msgid ""
"The elimination of co-recursive definition is done lazily, i.e. the "
"definition is expanded only when it occurs at the head of an application "
"which is the argument of a case analysis expression. In any other context, "
"it is considered as a canonical expression which is completely evaluated. We "
"can test this using the command :cmd:`Eval`, which computes the normal forms "
"of a term:"
msgstr ""

#: ../../language/gallina-specification-language.rst:1264
msgid ""
"As in the :cmd:`Fixpoint` command, it is possible to introduce a block of "
"mutually dependent methods."
msgstr ""

#: ../../language/gallina-specification-language.rst:1270
msgid "Assertions and proofs"
msgstr ""

#: ../../language/gallina-specification-language.rst:1272
msgid ""
"An assertion states a proposition (or a type) of which the proof (or an "
"inhabitant of the type) is interactively built using tactics. The "
"interactive proof mode is described in Chapter :ref:`proofhandling` and the "
"tactics in Chapter :ref:`Tactics`. The basic assertion command is:"
msgstr ""

#: ../../language/gallina-specification-language.rst:1279
msgid ""
"After the statement is asserted, Coq needs a proof. Once a proof of :token:"
"`type` under the assumptions represented by :token:`binders` is given and "
"validated, the proof is generalized into a proof of :n:`forall @binders, "
"@type` and the theorem is bound to the name :token:`ident` in the "
"environment."
msgstr ""

#: ../../language/gallina-specification-language.rst:1290
msgid ""
"The name you provided is already defined. You have then to choose another "
"name."
msgstr ""

#: ../../language/gallina-specification-language.rst:1300
msgid ""
"These commands are all synonyms of :n:`Theorem @ident {? @binders } : type`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1304
msgid ""
"This command is useful for theorems that are proved by simultaneous "
"induction over a mutually inductive assumption, or that assert mutually "
"dependent statements in some mutual co-inductive type. It is equivalent to :"
"cmd:`Fixpoint` or :cmd:`CoFixpoint` but using tactics to build the proof of "
"the statements (or the body of the specification, depending on the point of "
"view). The inductive or co-inductive types on which the induction or "
"coinduction has to be done is assumed to be non ambiguous and is guessed by "
"the system."
msgstr ""

#: ../../language/gallina-specification-language.rst:1313
msgid ""
"Like in a :cmd:`Fixpoint` or :cmd:`CoFixpoint` definition, the induction "
"hypotheses have to be used on *structurally smaller* arguments (for a :cmd:"
"`Fixpoint`) or be *guarded by a constructor* (for a :cmd:`CoFixpoint`). The "
"verification that recursive proof arguments are correct is done only at the "
"time of registering the lemma in the environment. To know if the use of "
"induction hypotheses is correct at some time of the interactive development "
"of a proof, use the command :cmd:`Guarded`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1321
msgid ""
"The command can be used also with :cmd:`Lemma`, :cmd:`Remark`, etc. instead "
"of :cmd:`Theorem`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1326
msgid ""
"This allows defining a term of type :token:`type` using the proof editing "
"mode. It behaves as :cmd:`Theorem` but is intended to be used in conjunction "
"with :cmd:`Defined` in order to define a constant of which the computational "
"behavior is relevant."
msgstr ""

#: ../../language/gallina-specification-language.rst:1331
msgid ""
"The command can be used also with :cmd:`Example` instead of :cmd:"
"`Definition`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1337
msgid ""
"Like :n:`Definition @ident {? @binders } : @type` except that the definition "
"is turned into a let-in definition generalized over the declarations "
"depending on it after closing the current section."
msgstr ""

#: ../../language/gallina-specification-language.rst:1343
msgid ""
"This generalizes the syntax of :cmd:`Fixpoint` so that one or more bodies "
"can be defined interactively using the proof editing mode (when a body is "
"omitted, its type is mandatory in the syntax). When the block of proofs is "
"completed, it is intended to be ended by :cmd:`Defined`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1350
msgid ""
"This generalizes the syntax of :cmd:`CoFixpoint` so that one or more bodies "
"can be defined interactively using the proof editing mode."
msgstr ""

#: ../../language/gallina-specification-language.rst:1353
msgid ""
"A proof starts by the keyword :cmd:`Proof`. Then Coq enters the proof "
"editing mode until the proof is completed. The proof editing mode "
"essentially contains tactics that are described in chapter :ref:`Tactics`. "
"Besides tactics, there are commands to manage the proof editing mode. They "
"are described in Chapter :ref:`proofhandling`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1359
msgid ""
"When the proof is completed it should be validated and put in the "
"environment using the keyword :cmd:`Qed`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1364
msgid "Several statements can be simultaneously asserted."
msgstr ""

#: ../../language/gallina-specification-language.rst:1366
msgid ""
"Not only other assertions but any vernacular command can be given while in "
"the process of proving a given assertion. In this case, the command is "
"understood as if it would have been given before the statements still to be "
"proved. Nonetheless, this practice is discouraged and may stop working in "
"future versions."
msgstr ""

#: ../../language/gallina-specification-language.rst:1372
msgid ""
"Proofs ended by :cmd:`Qed` are declared opaque. Their content cannot be "
"unfolded (see :ref:`performingcomputations`), thus realizing some form of "
"*proof-irrelevance*. To be able to unfold a proof, the proof should be ended "
"by :cmd:`Defined`."
msgstr ""

#: ../../language/gallina-specification-language.rst:1377
msgid ""
":cmd:`Proof` is recommended but can currently be omitted. On the opposite "
"side, :cmd:`Qed` (or :cmd:`Defined`) is mandatory to validate a proof."
msgstr ""

#: ../../language/gallina-specification-language.rst:1380
msgid ""
"One can also use :cmd:`Admitted` in place of :cmd:`Qed` to turn the current "
"asserted statement into an axiom and exit the proof editing mode."
msgstr ""

#: ../../language/gallina-specification-language.rst:1384
msgid ""
"This is similar to the expression “*entry* :math:`\\{` sep *entry* :math:`\\}"
"`” in standard BNF, or “*entry* :math:`(` sep *entry* :math:`)`\\ \\*” in "
"the syntax of regular expressions."
msgstr ""

#: ../../language/gallina-specification-language.rst:1389
msgid ""
"Except if the inductive type is empty in which case there is no equation "
"that can be used to infer the return type."
msgstr ""

#: ../../language/module-system.rst:4
msgid "The Module System"
msgstr ""

#: ../../language/module-system.rst:6
msgid ""
"The module system extends the Calculus of Inductive Constructions providing "
"a convenient way to structure large developments as well as a means of "
"massive abstraction."
msgstr ""

#: ../../language/module-system.rst:12
msgid "Modules and module types"
msgstr ""

#: ../../language/module-system.rst:14
msgid ""
"**Access path.** An access path is denoted by :math:`p` and can be either a "
"module variable :math:`X` or, if :math:`p′` is an access path and :math:`id` "
"an identifier, then :math:`p′.id` is an access path."
msgstr ""

#: ../../language/module-system.rst:19
msgid ""
"**Structure element.** A structure element is denoted by :math:`e` and is "
"either a definition of a constant, an assumption, a definition of an "
"inductive, a definition of a module, an alias of a module or a module type "
"abbreviation."
msgstr ""

#: ../../language/module-system.rst:25
msgid ""
"**Structure expression.** A structure expression is denoted by :math:`S` and "
"can be:"
msgstr ""

#: ../../language/module-system.rst:27
msgid "an access path :math:`p`"
msgstr ""

#: ../../language/module-system.rst:28
msgid "a plain structure :math:`\\Struct~e ; … ; e~\\End`"
msgstr ""

#: ../../language/module-system.rst:29
msgid ""
"a functor :math:`\\Functor(X:S)~S′`, where :math:`X` is a module variable, :"
"math:`S` and :math:`S′` are structure expressions"
msgstr ""

#: ../../language/module-system.rst:31
msgid ""
"an application :math:`S~p`, where :math:`S` is a structure expression and :"
"math:`p` an access path"
msgstr ""

#: ../../language/module-system.rst:33
msgid ""
"a refined structure :math:`S~\\with~p := p`′ or :math:`S~\\with~p := t:T` "
"where :math:`S` is a structure expression, :math:`p` and :math:`p′` are "
"access paths, :math:`t` is a term and :math:`T` is the type of :math:`t`."
msgstr ""

#: ../../language/module-system.rst:37
msgid ""
"**Module definition.** A module definition is written :math:`\\Mod{X}{S}{S'}"
"` and consists of a module variable :math:`X`, a module type :math:`S` which "
"can be any structure expression and optionally a module implementation :math:"
"`S′` which can be any structure expression except a refined structure."
msgstr ""

#: ../../language/module-system.rst:44
msgid ""
"**Module alias.** A module alias is written :math:`\\ModA{X}{p}` and "
"consists of a module variable :math:`X` and a module path :math:`p`."
msgstr ""

#: ../../language/module-system.rst:48
msgid ""
"**Module type abbreviation.** A module type abbreviation is written :math:`"
"\\ModType{Y}{S}`, where :math:`Y` is an identifier and :math:`S` is any "
"structure expression ."
msgstr ""

#: ../../language/module-system.rst:55
msgid "Typing Modules"
msgstr ""

#: ../../language/module-system.rst:57
msgid ""
"In order to introduce the typing system we first slightly extend the "
"syntactic class of terms and environments given in section :ref:`The-terms`. "
"The environments, apart from definitions of constants and inductive types "
"now also hold any other structure elements. Terms, apart from variables, "
"constants and complex terms, include also access paths."
msgstr ""

#: ../../language/module-system.rst:63
msgid "We also need additional typing judgments:"
msgstr ""

#: ../../language/module-system.rst:66
msgid ""
":math:`\\WFT{E}{S}`, denoting that a structure :math:`S` is well-formed,"
msgstr ""

#: ../../language/module-system.rst:67
msgid ""
":math:`\\WTM{E}{p}{S}`, denoting that the module pointed by :math:`p` has "
"type :math:`S` in environment :math:`E`."
msgstr ""

#: ../../language/module-system.rst:69
msgid ""
":math:`\\WEV{E}{S}{\\ovl{S}}`, denoting that a structure :math:`S` is "
"evaluated to a structure :math:`S` in weak head normal form."
msgstr ""

#: ../../language/module-system.rst:71
msgid ""
":math:`\\WS{E}{S_1}{S_2}` , denoting that a structure :math:`S_1` is a "
"subtype of a structure :math:`S_2`."
msgstr ""

#: ../../language/module-system.rst:73
msgid ""
":math:`\\WS{E}{e_1}{e_2}` , denoting that a structure element e_1 is more "
"precise than a structure element e_2."
msgstr ""

#: ../../language/module-system.rst:76
msgid "The rules for forming structures are the following:"
msgstr ""

#: ../../language/module-system.rst:91
msgid "Evaluation of structures to weak head normal form:"
msgstr ""

#: ../../language/module-system.rst:103
msgid ""
"In the last rule, :math:`\\{t_1 /p_1 .c_1 ,…,t_n /p_n .c_n \\}` is the "
"resulting substitution from the inlining mechanism. We substitute in :math:"
"`S` the inlined fields :math:`p_i .c_i` from :math:`\\ModS{X}{S_1 }` by the "
"corresponding delta- reduced term :math:`t_i` in :math:`p`."
msgstr ""

#: ../../language/module-system.rst:210
msgid "Rules for typing module:"
msgstr ""

#: ../../language/module-system.rst:225
msgid ""
"The last rule, called strengthening is used to make all module fields "
"manifestly equal to themselves. The notation :math:`S/p` has the following "
"meaning:"
msgstr ""

#: ../../language/module-system.rst:230
msgid ""
"if :math:`S\\lra~\\Struct~e_1 ;…;e_n ~\\End` then :math:`S/p=~\\Struct~e_1 /"
"p;…;e_n /p ~\\End` where :math:`e/p` is defined as follows (note that opaque "
"definitions are processed as assumptions):"
msgstr ""

#: ../../language/module-system.rst:234
msgid ":math:`\\Def{}{c}{t}{T}/p = \\Def{}{c}{t}{T}`"
msgstr ""

#: ../../language/module-system.rst:235
msgid ":math:`\\Assum{}{c}{U}/p = \\Def{}{c}{p.c}{U}`"
msgstr ""

#: ../../language/module-system.rst:236
msgid ":math:`\\ModS{X}{S}/p = \\ModA{X}{p.X}`"
msgstr ""

#: ../../language/module-system.rst:237
msgid ":math:`\\ModA{X}{p′}/p = \\ModA{X}{p′}`"
msgstr ""

#: ../../language/module-system.rst:238
msgid ":math:`\\Ind{}{Γ_P}{Γ_C}{Γ_I}/p = \\Indp{}{Γ_P}{Γ_C}{Γ_I}{p}`"
msgstr ""

#: ../../language/module-system.rst:239
msgid ":math:`\\Indpstr{}{Γ_P}{Γ_C}{Γ_I}{p'}{p} = \\Indp{}{Γ_P}{Γ_C}{Γ_I}{p'}`"
msgstr ""

#: ../../language/module-system.rst:241
msgid "if :math:`S \\lra \\Functor(X:S′)~S″` then :math:`S/p=S`"
msgstr ""

#: ../../language/module-system.rst:244
msgid ""
"The notation :math:`\\Indp{}{Γ_P}{Γ_C}{Γ_I}{p}` denotes an inductive "
"definition that is definitionally equal to the inductive definition in the "
"module denoted by the path :math:`p`. All rules which have :math:`\\Ind{}"
"{Γ_P}{Γ_C}{Γ_I}` as premises are also valid for :math:`\\Indp{}{Γ_P}{Γ_C}"
"{Γ_I}{p}`. We give the formation rule for :math:`\\Indp{}{Γ_P}{Γ_C}{Γ_I}{p}` "
"below as well as the equality rules on inductive types and constructors."
msgstr ""

#: ../../language/module-system.rst:253
msgid "The module subtyping rules:"
msgstr ""

#: ../../language/module-system.rst:272
msgid "Structure element subtyping rules:"
msgstr ""

#: ../../language/module-system.rst:362
msgid "New environment formation rules"
msgstr ""

#: ../../language/module-system.rst:406
msgid "Component access rules"
msgstr ""

#: ../../language/module-system.rst:421
msgid ""
"Notice that the following rule extends the delta rule defined in section :"
"ref:`Conversion-rules`"
msgstr ""

#: ../../language/module-system.rst:429
msgid ""
"In the rules below we assume :math:`Γ_P` is :math:`[p_1 :P_1 ;…;p_r :"
"P_r ]`, :math:`Γ_I` is :math:`[I_1 :A_1 ;…;I_k :A_k ]`, and :math:`Γ_C` is :"
"math:`[c_1 :C_1 ;…;c_n :C_n ]`."
msgstr ""
