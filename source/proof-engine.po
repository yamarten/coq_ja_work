# Japanese translations for Coq package
# Coq パッケージに対する英訳.
# Copyright (C) 1999-2018, Inria
# This file is distributed under the same license as the Coq package.
# Automatically generated, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Coq 8.8.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-29 17:08+0900\n"
"PO-Revision-Date: 2019-12-29 17:08+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../proof-engine/detailed-tactic-examples.rst:4
msgid "Detailed examples of tactics"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:6
msgid ""
"This chapter presents detailed examples of certain tactics, to illustrate "
"their behavior."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:12
msgid "dependent induction"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:14
msgid ""
"The tactics ``dependent induction`` and ``dependent destruction`` are "
"another solution for inverting inductive predicate instances and potentially "
"doing induction at the same time. It is based on the ``BasicElim`` tactic of "
"Conor McBride which works by abstracting each argument of an inductive "
"instance by a variable and constraining it by equalities afterwards. This "
"way, the usual induction and destruct tactics can be applied to the "
"abstracted instance and after simplification of the equalities we get the "
"expected goals."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:23
msgid ""
"The abstracting tactic is called generalize_eqs and it takes as argument a "
"hypothesis to generalize. It uses the JMeq datatype defined in Coq.Logic."
"JMeq, hence we need to require it before. For example, revisiting the first "
"example of the inversion documentation:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:46
msgid ""
"The index ``S n`` gets abstracted by a variable here, but a corresponding "
"equality is added under the abstract instance so that no information is "
"actually lost. The goal is now almost amenable to do induction or case "
"analysis. One should indeed first move ``n`` into the goal to strengthen it "
"before doing induction, or ``n`` will be fixed in the inductive hypotheses "
"(this does not matter for case analysis). As a rule of thumb, all the "
"variables that appear inside constructors in the indices of the hypothesis "
"should be generalized. This is exactly what the ``generalize_eqs_vars`` "
"variant does:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:61
msgid ""
"As the hypothesis itself did not appear in the goal, we did not need to use "
"an heterogeneous equality to relate the new hypothesis to the old one (which "
"just disappeared here). However, the tactic works just as well in this case, "
"e.g.:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:80
msgid ""
"One drawback of this approach is that in the branches one will have to "
"substitute the equalities back into the instance to get the right "
"assumptions. Sometimes injection of constructors will also be needed to "
"recover the needed equalities. Also, some subgoals should be directly solved "
"because of inconsistent contexts arising from the constraints on indexes. "
"The nice thing is that we can make a tactic based on discriminate, injection "
"and variants of substitution to automatically do such simplifications (which "
"may involve the axiom K). This is what the ``simplify_dep_elim`` tactic from "
"``Coq.Program.Equality`` does. For example, we might simplify the previous "
"goals considerably:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:99
msgid ""
"The higher-order tactic ``do_depind`` defined in ``Coq.Program.Equality`` "
"takes a tactic and combines the building blocks we have seen with it: "
"generalizing by equalities calling the given tactic with the generalized "
"induction hypothesis as argument and cleaning the subgoals with respect to "
"equalities. Its most important instantiations are ``dependent induction`` "
"and ``dependent destruction`` that do induction or simply case analysis on "
"the generalized hypothesis. For example we can redo what we’ve done manually "
"with dependent destruction:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:124
msgid ""
"This gives essentially the same result as inversion. Now if the destructed "
"hypothesis actually appeared in the goal, the tactic would still be able to "
"invert it, contrary to dependent inversion. Consider the following example "
"on vectors:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:160
msgid ""
"In this case, the ``v`` variable can be replaced in the goal by the "
"generalized hypothesis only when it has a type of the form ``vector (S n)``, "
"that is only in the second case of the destruct. The first one is dismissed "
"because ``S n <> 0``."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:167
msgid "A larger example"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:169
msgid ""
"Let’s see how the technique works with induction on inductive predicates on "
"a real example. We will develop an example application to the theory of "
"simply-typed lambda-calculus formalized in a dependently-typed style:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:217
msgid ""
"We have defined types and contexts which are snoc-lists of types. We also "
"have a ``conc`` operation that concatenates two contexts. The ``term`` "
"datatype represents in fact the possible typing derivations of the calculus, "
"which are isomorphic to the well-typed terms, hence the name. A term is "
"either an application of:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:224
msgid "the axiom rule to type a reference to the first variable in a context"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:226
msgid "the weakening rule to type an object in a larger context"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:227
msgid "the abstraction or lambda rule to type a function"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:228
msgid "the application to type an application of a function to an argument"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:231
msgid "Once we have this datatype we want to do proofs on it, like weakening:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:242
msgid ""
"The problem here is that we can’t just use induction on the typing "
"derivation because it will forget about the ``G ; D`` constraint appearing "
"in the instance. A solution would be to rewrite the goal as:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:256
msgid ""
"With this proper separation of the index from the instance and the right "
"induction loading (putting ``G`` and ``D`` after the inducted-on "
"hypothesis), the proof will go through, but it is a very tedious process. "
"One is also forced to make a wrapper lemma to get back the more natural "
"statement. The ``dependent induction`` tactic alleviates this trouble by "
"doing all of this plumbing of generalizing and substituting back "
"automatically. Indeed we can simply write:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:282
msgid ""
"This call to dependent induction has an additional arguments which is a list "
"of variables appearing in the instance that should be generalized in the "
"goal, so that they can vary in the induction hypotheses. By default, all "
"variables appearing inside constructors (except in a parameter position) of "
"the instantiated hypothesis will be generalized automatically but one can "
"always give the list explicitly."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:294
msgid ""
"The ``simpl_depind`` tactic includes an automatic tactic that tries to "
"simplify equalities appearing at the beginning of induction hypotheses, "
"generally using trivial applications of ``reflexivity``. In cases where the "
"equality is not between constructor forms though, one must help the "
"automation by giving some arguments, using the ``specialize`` tactic for "
"example."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:317
msgid ""
"Once the induction hypothesis has been narrowed to the right equality, it "
"can be used directly."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:324
msgid "Now concluding this subgoal is easy."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:331
msgid "The :tacn:`induction`, :tacn:`case`, and :tacn:`inversion` tactics."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:335
msgid "autorewrite"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:337
msgid ""
"Here are two examples of ``autorewrite`` use. The first one ( *Ackermann "
"function*) shows actually a quite basic use where there is no conditional "
"rewriting. The second one ( *Mac Carthy function*) involves conditional "
"rewritings and shows how to deal with them using the optional tactic of the "
"``Hint Rewrite`` command."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:344
msgid "Example: Ackermann function"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:372
msgid "Example: MacCarthy function"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:423
msgid "quote"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:425
msgid ""
"The tactic ``quote`` allows using Barendregt’s so-called 2-level approach "
"without writing any ML code. Suppose you have a language ``L`` of 'abstract "
"terms' and a type ``A`` of 'concrete terms' and a function ``f : L -> A``. "
"If ``L`` is a simple inductive datatype and ``f`` a simple fixpoint, ``quote "
"f`` will replace the head of current goal by a convertible term of the form "
"``(f t)``. ``L`` must have a constructor of type: ``A -> L``."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:432
msgid "Here is an example:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:470
msgid ""
"The algorithm to perform this inversion is: try to match the term with right-"
"hand sides expression of ``f``. If there is a match, apply the corresponding "
"left-hand side and call yourself recursively on sub- terms. If there is no "
"match, we are at a leaf: return the corresponding constructor (here "
"``f_const``) applied to the term."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:476
msgid ""
"When ``quote`` is not able to perform inversion properly, it will error out "
"with :exn:`quote: not a simple fixpoint`."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:481
msgid "Introducing variables map"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:483
msgid ""
"The normal use of quote is to make proofs by reflection: one defines a "
"function ``simplify : formula -> formula`` and proves a theorem "
"``simplify_ok: (f:formula)(interp_f (simplify f)) -> (interp_f f)``. Then, "
"one can simplify formulas by doing:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:494
msgid ""
"But there is a problem with leafs: in the example above one cannot write a "
"function that implements, for example, the logical simplifications :math:`A "
"\\wedge A \\rightarrow A` or :math:`A \\wedge \\lnot A \\rightarrow "
"\\mathrm{False}`. This is because ``Prop`` is impredicative."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:500
msgid "It is better to use that type of formulas:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:519
msgid ""
"``index`` is defined in module ``Quote``. Equality on that type is decidable "
"so we are able to simplify :math:`A \\wedge A` into :math:`A` at the "
"abstract level."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:523
msgid ""
"When there are variables, there are bindings, and ``quote`` also provides a "
"type ``(varmap A)`` of bindings from index to any set ``A``, and a function "
"``varmap_find`` to search in such maps. The interpretation function also has "
"another argument, a variables map:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:539
msgid "``quote`` handles this second case properly:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:549
msgid ""
"It builds ``vm`` and ``t`` such that ``(f vm t)`` is convertible with the "
"conclusion of current goal."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:554
msgid "Combining variables and constants"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:556
msgid ""
"One can have both variables and constants in abstracts terms; for example, "
"this is the case for the :tacn:`ring` tactic. Then one must provide to "
"``quote`` a list of *constructors of constants*. For example, if the list is "
"``[O S]`` then closed natural numbers will be considered as constants and "
"other terms as variables."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:610
msgid ""
"Since functional inversion is undecidable in the general case, don’t expect "
"miracles from it!"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:615
msgid ""
"``tactic`` must be a functional tactic (starting with ``fun x =>``) and will "
"be called with the quoted version of term according to ``ident``."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:620
msgid ""
"Same as above, but will use the additional ``ident`` list to chose which "
"subterms are constants (see above)."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:624
msgid "Comments from the source file ``plugins/quote/quote.ml``"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:627
msgid "The :tacn:`ring` tactic."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:631
msgid "Using the tactic language"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:635
msgid "About the cardinality of the set of natural numbers"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:637
msgid ""
"The first example which shows how to use pattern matching over the proof "
"context is a proof of the fact that natural numbers have more than two "
"elements. This can be done as follows:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:664
msgid ""
"We can notice that all the (very similar) cases coming from the three "
"eliminations (with three distinct natural numbers) are successfully solved "
"by a match goal structure and, in particular, with only one pattern (use of "
"non-linear matching)."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:671
msgid "Permutations of lists"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:673
msgid ""
"A more complex example is the problem of permutations of lists. The aim is "
"to show that a list is a permutation of another list."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:697
msgid "First, we define the permutation predicate as shown above."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:722
msgid ""
"Next we define an auxiliary tactic ``perm_aux`` which takes an argument used "
"to control the recursion depth. This tactic behaves as follows. If the lists "
"are identical (i.e. convertible), it concludes. Otherwise, if the lists have "
"identical heads, it proceeds to look at their tails. Finally, if the lists "
"have different heads, it rotates the first list by putting its head at the "
"end if the new head hasn't been the head previously. To check this, we keep "
"track of the number of performed rotations using the argument ``n``. We do "
"this by decrementing ``n`` each time we perform a rotation. It works because "
"for a list of length ``n`` we can make exactly ``n - 1`` rotations to "
"generate at most ``n`` distinct lists. Notice that we use the natural "
"numbers of Coq for the rotation counter. From :ref:`ltac-syntax` we know "
"that it is possible to use the usual natural numbers, but they are only used "
"as arguments for primitive tactics and they cannot be handled, so, in "
"particular, we cannot make computations with them. Thus the natural choice "
"is to use Coq data structures so that Coq makes the computations "
"(reductions) by ``eval compute in`` and we can get the terms back by match."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:749
msgid ""
"The main tactic is ``solve_perm``. It computes the lengths of the two lists "
"and uses them as arguments to call ``perm_aux`` if the lengths are equal (if "
"they aren't, the lists cannot be permutations of each other). Using this "
"tactic we can now prove lemmas as follows:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:769
msgid "Deciding intuitionistic propositional logic"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:771
msgid ""
"Pattern matching on goals allows a powerful backtracking when returning "
"tactic values. An interesting application is the problem of deciding "
"intuitionistic propositional logic. Considering the contraction-free sequent "
"calculi LJT* of Roy Dyckhoff :cite:`Dyc92`, it is quite natural to code such "
"a tactic using the tactic language as shown below."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:833
msgid ""
"The tactic ``basic`` tries to reason using simple rules involving truth, "
"falsity and available assumptions. The tactic ``simplify`` applies all the "
"reversible rules of Dyckhoff’s system. Finally, the tactic ``my_tauto`` (the "
"main tactic to be called) simplifies with ``simplify``, tries to conclude "
"with ``basic`` and tries several paths using the backtracking rules (one of "
"the four Dyckhoff’s rules for the left implication to get rid of the "
"contraction and the right ``or``)."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:841
msgid "Having defined ``my_tauto``, we can prove tautologies like these:"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:857
msgid "Deciding type isomorphisms"
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:859
msgid ""
"A more tricky problem is to decide equalities between types modulo "
"isomorphisms. Here, we choose to use the isomorphisms of the simply typed λ-"
"calculus with Cartesian product and unit type (see, for example, :cite:"
"`RC95`). The axioms of this λ-calculus are given below."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:979
msgid ""
"The tactic to judge equalities modulo this axiomatization is shown above. "
"The algorithm is quite simple. First types are simplified using axioms that "
"can be oriented (this is done by ``simplify_type`` and "
"``simplify_type_eq``). The normal forms are sequences of Cartesian products "
"without Cartesian product in the left component. These normal forms are then "
"compared modulo permutation of the components by the tactic "
"``compare_structure``. If they have the same lengths, the tactic "
"``solve_type_eq`` attempts to prove that the types are equal. The main "
"tactic that puts all these components together is called ``solve_iso``."
msgstr ""

#: ../../proof-engine/detailed-tactic-examples.rst:988
msgid "Here are examples of what can be solved by ``solve_iso``."
msgstr ""

#: ../../proof-engine/ltac.rst:4
msgid "The tactic language"
msgstr ""

#: ../../proof-engine/ltac.rst:6
msgid ""
"This chapter gives a compact documentation of |Ltac|, the tactic language "
"available in |Coq|. We start by giving the syntax, and next, we present the "
"informal semantics. If you want to know more regarding this language and "
"especially about its foundations, you can refer to :cite:`Del00`. Chapter :"
"ref:`detailedexamplesoftactics` is devoted to giving small but nontrivial "
"use examples of this language."
msgstr ""

#: ../../proof-engine/ltac.rst:16
#: ../../proof-engine/ssreflect-proof-language.rst:3865
msgid "Syntax"
msgstr ""

#: ../../proof-engine/ltac.rst:18
msgid ""
"The syntax of the tactic language is given below. See Chapter :ref:"
"`gallinaspecificationlanguage` for a description of the BNF metasyntax used "
"in these grammar rules. Various already defined entries will be used in this "
"chapter: entries :token:`natural`, :token:`integer`, :token:`ident`, :token:"
"`qualid`, :token:`term`, :token:`cpattern` and :token:`atomic_tactic` "
"represent respectively the natural and integer numbers, the authorized "
"identificators and qualified names, Coq terms and patterns and all the "
"atomic tactics described in Chapter :ref:`tactics`. The syntax of :token:"
"`cpattern` is the same as that of terms, but it is extended with pattern "
"matching metavariables. In :token:`cpattern`, a pattern matching "
"metavariable is represented with the syntax :g:`?id` where :g:`id` is an :"
"token:`ident`. The notation :g:`_` can also be used to denote metavariable "
"whose instance is irrelevant. In the notation :g:`?id`, the identifier "
"allows us to keep instantiations and to make constraints whereas :g:`_` "
"shows that we are not interested in what will be matched. On the right hand "
"side of pattern matching clauses, the named metavariables are used without "
"the question mark prefix. There is also a special notation for second-order "
"pattern matching problems: in an applicative pattern of the form :g:`@?id "
"id1 … idn`, the variable id matches any complex expression with (possible) "
"dependencies in the variables :g:`id1 … idn` and returns a functional term "
"of the form :g:`fun id1 … idn => term`."
msgstr ""

#: ../../proof-engine/ltac.rst:39
msgid ""
"The main entry of the grammar is :n:`@expr`. This language is used in proof "
"mode but it can also be used in toplevel definitions as shown below."
msgstr ""

#: ../../proof-engine/ltac.rst:44
msgid "The infix tacticals “… \\|\\| …”, “… + …”, and “… ; …” are associative."
msgstr ""

#: ../../proof-engine/ltac.rst:46
msgid ""
"In :token:`tacarg`, there is an overlap between qualid as a direct tactic "
"argument and :token:`qualid` as a particular case of term. The resolution is "
"done by first looking for a reference of the tactic language and if it "
"fails, for a reference to a term. To force the resolution as a reference of "
"the tactic language, use the form :g:`ltac:(@qualid)`. To force the "
"resolution as a reference to a term, use the syntax :g:`(@qualid)`."
msgstr ""

#: ../../proof-engine/ltac.rst:54
msgid ""
"As shown by the figure, tactical ``\\|\\|`` binds more than the prefix "
"tacticals try, repeat, do and abstract which themselves bind more than the "
"postfix tactical “… ;[ … ]” which binds more than “… ; …”."
msgstr ""

#: ../../proof-engine/ltac.rst:58
msgid "For instance"
msgstr ""

#: ../../proof-engine/ltac.rst:64
msgid "is understood as"
msgstr ""

#: ../../proof-engine/ltac.rst:158
msgid "Semantics"
msgstr ""

#: ../../proof-engine/ltac.rst:160
msgid ""
"Tactic expressions can only be applied in the context of a proof. The "
"evaluation yields either a term, an integer or a tactic. Intermediate "
"results can be terms or integers but the final result must be a tactic which "
"is then applied to the focused goals."
msgstr ""

#: ../../proof-engine/ltac.rst:165
msgid ""
"There is a special case for ``match goal`` expressions of which the clauses "
"evaluate to tactics. Such expressions can only be used as end result of a "
"tactic expression (never as argument of a non-recursive local definition or "
"of an application)."
msgstr ""

#: ../../proof-engine/ltac.rst:170
msgid ""
"The rest of this section explains the semantics of every construction of |"
"Ltac|."
msgstr ""

#: ../../proof-engine/ltac.rst:174
msgid "Sequence"
msgstr ""

#: ../../proof-engine/ltac.rst:176
msgid "A sequence is an expression of the following form:"
msgstr ""

#: ../../proof-engine/ltac.rst:181
msgid ""
"The expression :n:`@expr__1` is evaluated to :n:`v__1`, which must be a "
"tactic value. The tactic :n:`v__1` is applied to the current goal, possibly "
"producing more goals. Then :n:`@expr__2` is evaluated to produce :n:`v__2`, "
"which must be a tactic value. The tactic :n:`v__2` is applied to all the "
"goals produced by the prior application. Sequence is associative."
msgstr ""

#: ../../proof-engine/ltac.rst:189
msgid "Local application of tactics"
msgstr ""

#: ../../proof-engine/ltac.rst:191
msgid ""
"Different tactics can be applied to the different goals using the following "
"form:"
msgstr ""

#: ../../proof-engine/ltac.rst:197
msgid ""
"The expressions :n:`@expr__i` are evaluated to :n:`v__i`, for i = 0, ..., n "
"and all have to be tactics. The :n:`v__i` is applied to the i-th goal, for i "
"= 1, ..., n. It fails if the number of focused goals is not exactly n."
msgstr ""

#: ../../proof-engine/ltac.rst:204
msgid ""
"If no tactic is given for the i-th goal, it behaves as if the tactic idtac "
"were given. For instance, ``[> | auto]`` is a shortcut for ``[> idtac | "
"auto ]``."
msgstr ""

#: ../../proof-engine/ltac.rst:210
msgid ""
"In this variant, :n:`@expr` is used for each goal coming after those covered "
"by the list of :n:`@expr__i` but before those covered by the list of :n:"
"`@expr__j`."
msgstr ""

#: ../../proof-engine/ltac.rst:216
msgid ""
"In this variant, idtac is used for the goals not covered by the two lists "
"of :n:`@expr`."
msgstr ""

#: ../../proof-engine/ltac.rst:221
msgid ""
"In this variant, the tactic :n:`@expr` is applied independently to each of "
"the goals, rather than globally. In particular, if there are no goals, the "
"tactic is not run at all. A tactic which expects multiple goals, such as "
"``swap``, would act as if a single goal is focused."
msgstr ""

#: ../../proof-engine/ltac.rst:228
msgid ""
"This variant of local tactic application is paired with a sequence. In this "
"variant, there must be as many :n:`@expr__i` as goals generated by the "
"application of :n:`@expr__0` to each of the individual goals independently. "
"All the above variants work in this form too. Formally, :n:`@expr ; [ ... ]` "
"is equivalent to :n:`[> @expr ; [> ... ] .. ]`."
msgstr ""

#: ../../proof-engine/ltac.rst:237
msgid "Goal selectors"
msgstr ""

#: ../../proof-engine/ltac.rst:239
msgid ""
"We can restrict the application of a tactic to a subset of the currently "
"focused goals with:"
msgstr ""

#: ../../proof-engine/ltac.rst:245
msgid ""
"We can also use selectors as a tactical, which allows to use them nested in "
"a tactic expression, by using the keyword ``only``:"
msgstr ""

#: ../../proof-engine/ltac.rst:251
msgid ""
"When selecting several goals, the tactic :token:`expr` is applied globally "
"to all selected goals."
msgstr ""

#: ../../proof-engine/ltac.rst:256
msgid ""
"In this variant, :token:`expr` is applied locally to a goal previously named "
"by the user (see :ref:`existential-variables`)."
msgstr ""

#: ../../proof-engine/ltac.rst:261
msgid ""
"In this variant, :token:`expr` is applied locally to the :token:`num`-th "
"goal."
msgstr ""

#: ../../proof-engine/ltac.rst:265
msgid ""
"In this variant, :n:`@expr` is applied globally to the subset of goals "
"described by the given ranges. You can write a single ``n`` as a shortcut "
"for ``n-n`` when specifying multiple ranges."
msgstr ""

#: ../../proof-engine/ltac.rst:272
msgid ""
"In this variant, :token:`expr` is applied to all focused goals. ``all:`` can "
"only be used at the toplevel of a tactic expression."
msgstr ""

#: ../../proof-engine/ltac.rst:278
msgid ""
"In this variant, :n:`@expr` is applied to all focused goals in parallel. The "
"number of workers can be controlled via the command line option ``-async-"
"proofs-tac-j`` taking as argument the desired number of workers. "
"Limitations: ``par:`` only works on goals containing no existential "
"variables and :n:`@expr` must either solve the goal completely or do nothing "
"(i.e. it cannot make some progress). ``par:`` can only be used at the "
"toplevel of a tactic expression."
msgstr ""

#: ../../proof-engine/ltac.rst:292
msgid "For loop"
msgstr ""

#: ../../proof-engine/ltac.rst:294
msgid "There is a for loop that repeats a tactic :token:`num` times:"
msgstr ""

#: ../../proof-engine/ltac.rst:299
msgid ""
":n:`@expr` is evaluated to ``v`` which must be a tactic value. This tactic "
"value ``v`` is applied :token:`num` times. Supposing :token:`num` > 1, after "
"the first application of ``v``, ``v`` is applied, at least once, to the "
"generated subgoals and so on. It fails if the application of ``v`` fails "
"before the num applications have been completed."
msgstr ""

#: ../../proof-engine/ltac.rst:306
msgid "Repeat loop"
msgstr ""

#: ../../proof-engine/ltac.rst:308
msgid "We have a repeat loop with:"
msgstr ""

#: ../../proof-engine/ltac.rst:313
msgid ""
":n:`@expr` is evaluated to ``v``. If ``v`` denotes a tactic, this tactic is "
"applied to each focused goal independently. If the application succeeds, the "
"tactic is applied recursively to all the generated subgoals until it "
"eventually fails. The recursion stops in a subgoal when the tactic has "
"failed *to make progress*. The tactic :n:`repeat @expr` itself never fails."
msgstr ""

#: ../../proof-engine/ltac.rst:320
msgid "Error catching"
msgstr ""

#: ../../proof-engine/ltac.rst:322
msgid "We can catch the tactic errors with:"
msgstr ""

#: ../../proof-engine/ltac.rst:327
msgid ""
":n:`@expr` is evaluated to ``v`` which must be a tactic value. The tactic "
"value ``v`` is applied to each focused goal independently. If the "
"application of ``v`` fails in a goal, it catches the error and leaves the "
"goal unchanged. If the level of the exception is positive, then the "
"exception is re-raised with its level decremented."
msgstr ""

#: ../../proof-engine/ltac.rst:334
msgid "Detecting progress"
msgstr ""

#: ../../proof-engine/ltac.rst:336
msgid "We can check if a tactic made progress with:"
msgstr ""

#: ../../proof-engine/ltac.rst:341
msgid ""
":n:`@expr` is evaluated to v which must be a tactic value. The tactic value "
"``v`` is applied to each focued subgoal independently. If the application of "
"``v`` to one of the focused subgoal produced subgoals equal to the initial "
"goals (up to syntactical equality), then an error of level 0 is raised."
msgstr ""

#: ../../proof-engine/ltac.rst:349
msgid "Backtracking branching"
msgstr ""

#: ../../proof-engine/ltac.rst:351
msgid "We can branch with the following structure:"
msgstr ""

#: ../../proof-engine/ltac.rst:356
msgid ""
":n:`@expr__1` and :n:`@expr__2` are evaluated respectively to :n:`v__1` and :"
"n:`v__2` which must be tactic values. The tactic value :n:`v__1` is applied "
"to each focused goal independently and if it fails or a later tactic fails, "
"then the proof backtracks to the current goal and :n:`v__2` is applied."
msgstr ""

#: ../../proof-engine/ltac.rst:361
msgid ""
"Tactics can be seen as having several successes. When a tactic fails it asks "
"for more successes of the prior tactics. :n:`@expr__1 + @expr__2` has all "
"the successes of :n:`v__1` followed by all the successes of :n:`v__2`. "
"Algebraically, :n:`(@expr__1 + @expr__2); @expr__3 = (@expr__1; @expr__3) + "
"(@expr__2; @expr__3)`."
msgstr ""

#: ../../proof-engine/ltac.rst:367
msgid "Branching is left-associative."
msgstr ""

#: ../../proof-engine/ltac.rst:370
msgid "First tactic to work"
msgstr ""

#: ../../proof-engine/ltac.rst:372
msgid ""
"Backtracking branching may be too expensive. In this case we may restrict to "
"a local, left biased, branching and consider the first tactic to work (i.e. "
"which does not fail) among a panel of tactics:"
msgstr ""

#: ../../proof-engine/ltac.rst:379
msgid ""
"The :n:`@expr__i` are evaluated to :n:`v__i` and :n:`v__i` must be tactic "
"values for i = 1, ..., n. Supposing n > 1, :n:`first [@expr__1 | ... | "
"@expr__n]` applies :n:`v__1` in each focused goal independently and stops if "
"it succeeds; otherwise it tries to apply :n:`v__2` and so on. It fails when "
"there is no applicable tactic. In other words, :n:`first [@expr__1 | ... | "
"@expr__n]` behaves, in each goal, as the first :n:`v__i` to have *at least* "
"one success."
msgstr ""

#: ../../proof-engine/ltac.rst:392
msgid ""
"This is an |Ltac| alias that gives a primitive access to the first tactical "
"as an |Ltac| definition without going through a parsing rule. It expects to "
"be given a list of tactics through a ``Tactic Notation``, allowing to write "
"notations of the following form:"
msgstr ""

#: ../../proof-engine/ltac.rst:397 ../../proof-engine/ltac.rst:586
#: ../../proof-engine/ltac.rst:685 ../../proof-engine/ltac.rst:831
#: ../../proof-engine/ltac.rst:999 ../../proof-engine/ltac.rst:1024
#: ../../proof-engine/ltac.rst:1154 ../../proof-engine/proof-handling.rst:224
#: ../../proof-engine/proof-handling.rst:381
#: ../../proof-engine/proof-handling.rst:462
#: ../../proof-engine/proof-handling.rst:528
#: ../../proof-engine/ssreflect-proof-language.rst:206
#: ../../proof-engine/ssreflect-proof-language.rst:266
#: ../../proof-engine/ssreflect-proof-language.rst:310
#: ../../proof-engine/ssreflect-proof-language.rst:367
#: ../../proof-engine/ssreflect-proof-language.rst:392
#: ../../proof-engine/ssreflect-proof-language.rst:456
#: ../../proof-engine/ssreflect-proof-language.rst:510
#: ../../proof-engine/ssreflect-proof-language.rst:633
#: ../../proof-engine/ssreflect-proof-language.rst:688
#: ../../proof-engine/ssreflect-proof-language.rst:709
#: ../../proof-engine/ssreflect-proof-language.rst:730
#: ../../proof-engine/ssreflect-proof-language.rst:750
#: ../../proof-engine/ssreflect-proof-language.rst:783
#: ../../proof-engine/ssreflect-proof-language.rst:804
#: ../../proof-engine/ssreflect-proof-language.rst:825
#: ../../proof-engine/ssreflect-proof-language.rst:856
#: ../../proof-engine/ssreflect-proof-language.rst:873
#: ../../proof-engine/ssreflect-proof-language.rst:912
#: ../../proof-engine/ssreflect-proof-language.rst:928
#: ../../proof-engine/ssreflect-proof-language.rst:1038
#: ../../proof-engine/ssreflect-proof-language.rst:1094
#: ../../proof-engine/ssreflect-proof-language.rst:1250
#: ../../proof-engine/ssreflect-proof-language.rst:1292
#: ../../proof-engine/ssreflect-proof-language.rst:1461
#: ../../proof-engine/ssreflect-proof-language.rst:1667
#: ../../proof-engine/ssreflect-proof-language.rst:1741
#: ../../proof-engine/ssreflect-proof-language.rst:1760
#: ../../proof-engine/ssreflect-proof-language.rst:1828
#: ../../proof-engine/ssreflect-proof-language.rst:1894
#: ../../proof-engine/ssreflect-proof-language.rst:2155
#: ../../proof-engine/ssreflect-proof-language.rst:2279
#: ../../proof-engine/ssreflect-proof-language.rst:2358
#: ../../proof-engine/ssreflect-proof-language.rst:2390
#: ../../proof-engine/ssreflect-proof-language.rst:2441
#: ../../proof-engine/ssreflect-proof-language.rst:2469
#: ../../proof-engine/ssreflect-proof-language.rst:2497
#: ../../proof-engine/ssreflect-proof-language.rst:2518
#: ../../proof-engine/ssreflect-proof-language.rst:2551
#: ../../proof-engine/ssreflect-proof-language.rst:2577
#: ../../proof-engine/ssreflect-proof-language.rst:2598
#: ../../proof-engine/ssreflect-proof-language.rst:2615
#: ../../proof-engine/ssreflect-proof-language.rst:2638
#: ../../proof-engine/ssreflect-proof-language.rst:2735
#: ../../proof-engine/ssreflect-proof-language.rst:2805
#: ../../proof-engine/ssreflect-proof-language.rst:2830
#: ../../proof-engine/ssreflect-proof-language.rst:2879
#: ../../proof-engine/ssreflect-proof-language.rst:3019
#: ../../proof-engine/ssreflect-proof-language.rst:3131
#: ../../proof-engine/ssreflect-proof-language.rst:3167
#: ../../proof-engine/ssreflect-proof-language.rst:3187
#: ../../proof-engine/ssreflect-proof-language.rst:3209
#: ../../proof-engine/ssreflect-proof-language.rst:3240
#: ../../proof-engine/ssreflect-proof-language.rst:3270
#: ../../proof-engine/ssreflect-proof-language.rst:3313
#: ../../proof-engine/ssreflect-proof-language.rst:3330
#: ../../proof-engine/ssreflect-proof-language.rst:3357
#: ../../proof-engine/ssreflect-proof-language.rst:3416
#: ../../proof-engine/ssreflect-proof-language.rst:3470
#: ../../proof-engine/ssreflect-proof-language.rst:3540
#: ../../proof-engine/ssreflect-proof-language.rst:3622
#: ../../proof-engine/ssreflect-proof-language.rst:3645
#: ../../proof-engine/ssreflect-proof-language.rst:3757
#: ../../proof-engine/ssreflect-proof-language.rst:3784
#: ../../proof-engine/ssreflect-proof-language.rst:3807
#: ../../proof-engine/ssreflect-proof-language.rst:3828
#: ../../proof-engine/ssreflect-proof-language.rst:4008
#: ../../proof-engine/ssreflect-proof-language.rst:4047
#: ../../proof-engine/ssreflect-proof-language.rst:4207
#: ../../proof-engine/ssreflect-proof-language.rst:4283
#: ../../proof-engine/ssreflect-proof-language.rst:4365
#: ../../proof-engine/ssreflect-proof-language.rst:4431
#: ../../proof-engine/ssreflect-proof-language.rst:4487
#: ../../proof-engine/ssreflect-proof-language.rst:4520
#: ../../proof-engine/ssreflect-proof-language.rst:4564
#: ../../proof-engine/ssreflect-proof-language.rst:4590
#: ../../proof-engine/ssreflect-proof-language.rst:4649
#: ../../proof-engine/ssreflect-proof-language.rst:4666
#: ../../proof-engine/ssreflect-proof-language.rst:4756
#: ../../proof-engine/ssreflect-proof-language.rst:4793
#: ../../proof-engine/ssreflect-proof-language.rst:4914
#: ../../proof-engine/ssreflect-proof-language.rst:4948
#: ../../proof-engine/ssreflect-proof-language.rst:5008
#: ../../proof-engine/ssreflect-proof-language.rst:5101
#: ../../proof-engine/ssreflect-proof-language.rst:5167
#: ../../proof-engine/tactics.rst:206 ../../proof-engine/tactics.rst:331
#: ../../proof-engine/tactics.rst:364 ../../proof-engine/tactics.rst:668
#: ../../proof-engine/tactics.rst:821 ../../proof-engine/tactics.rst:962
#: ../../proof-engine/tactics.rst:1086 ../../proof-engine/tactics.rst:1262
#: ../../proof-engine/tactics.rst:1585 ../../proof-engine/tactics.rst:1655
#: ../../proof-engine/tactics.rst:1764 ../../proof-engine/tactics.rst:1830
#: ../../proof-engine/tactics.rst:1954 ../../proof-engine/tactics.rst:2106
#: ../../proof-engine/tactics.rst:2230 ../../proof-engine/tactics.rst:2278
#: ../../proof-engine/tactics.rst:2310 ../../proof-engine/tactics.rst:2877
#: ../../proof-engine/tactics.rst:2890 ../../proof-engine/tactics.rst:2903
#: ../../proof-engine/tactics.rst:2914 ../../proof-engine/tactics.rst:2926
#: ../../proof-engine/tactics.rst:3206 ../../proof-engine/tactics.rst:3474
#: ../../proof-engine/tactics.rst:3488 ../../proof-engine/tactics.rst:3734
#: ../../proof-engine/tactics.rst:3765 ../../proof-engine/tactics.rst:3777
#: ../../proof-engine/tactics.rst:3924 ../../proof-engine/tactics.rst:4326
#: ../../proof-engine/tactics.rst:4369 ../../proof-engine/tactics.rst:4387
#: ../../proof-engine/tactics.rst:4402 ../../proof-engine/tactics.rst:4425
#: ../../proof-engine/tactics.rst:4455
#: ../../proof-engine/vernacular-commands.rst:306
#: ../../proof-engine/vernacular-commands.rst:340
#: ../../proof-engine/vernacular-commands.rst:383
#: ../../proof-engine/vernacular-commands.rst:401
#: ../../proof-engine/vernacular-commands.rst:433
#: ../../proof-engine/vernacular-commands.rst:481
msgid "Example"
msgstr ""

#: ../../proof-engine/ltac.rst:404
msgid "Left-biased branching"
msgstr ""

#: ../../proof-engine/ltac.rst:406
msgid ""
"Yet another way of branching without backtracking is the following structure:"
msgstr ""

#: ../../proof-engine/ltac.rst:412
msgid ""
":n:`@expr__1` and :n:`@expr__2` are evaluated respectively to :n:`v__1` and :"
"n:`v__2` which must be tactic values. The tactic value :n:`v__1` is applied "
"in each subgoal independently and if it fails *to progress* then :n:`v__2` "
"is applied. :n:`@expr__1 || @expr__2` is equivalent to :n:`first [ progress "
"@expr__1 | @expr__2 ]` (except that if it fails, it fails like :n:`v__2`). "
"Branching is left-associative."
msgstr ""

#: ../../proof-engine/ltac.rst:420
msgid "Generalized biased branching"
msgstr ""

#: ../../proof-engine/ltac.rst:422
msgid "The tactic"
msgstr ""

#: ../../proof-engine/ltac.rst:427
msgid ""
"is a generalization of the biased-branching tactics above. The expression :n:"
"`@expr__1` is evaluated to :n:`v__1`, which is then applied to each subgoal "
"independently. For each goal where :n:`v__1` succeeds at least once, :n:"
"`@expr__2` is evaluated to :n:`v__2` which is then applied collectively to "
"the generated subgoals. The :n:`v__2` tactic can trigger backtracking points "
"in :n:`v__1`: where :n:`v__1` succeeds at least once, :n:`tryif @expr__1 "
"then @expr__2 else @expr__3` is equivalent to :n:`v__1; v__2`. In each of "
"the goals where :n:`v__1` does not succeed at least once, :n:`@expr__3` is "
"evaluated in :n:`v__3` which is is then applied to the goal."
msgstr ""

#: ../../proof-engine/ltac.rst:440
msgid "Soft cut"
msgstr ""

#: ../../proof-engine/ltac.rst:442
msgid ""
"Another way of restricting backtracking is to restrict a tactic to a single "
"success *a posteriori*:"
msgstr ""

#: ../../proof-engine/ltac.rst:448
msgid ""
":n:`@expr` is evaluated to ``v`` which must be a tactic value. The tactic "
"value ``v`` is applied but only its first success is used. If ``v`` fails, :"
"n:`once @expr` fails like ``v``. If ``v`` has at least one success, :n:`once "
"@expr` succeeds once, but cannot produce more successes."
msgstr ""

#: ../../proof-engine/ltac.rst:454
msgid "Checking the successes"
msgstr ""

#: ../../proof-engine/ltac.rst:456
msgid ""
"Coq provides an experimental way to check that a tactic has *exactly one* "
"success:"
msgstr ""

#: ../../proof-engine/ltac.rst:462
msgid ""
":n:`@expr` is evaluated to ``v`` which must be a tactic value. The tactic "
"value ``v`` is applied if it has at most one success. If ``v`` fails, :n:"
"`exactly_once @expr` fails like ``v``. If ``v`` has a exactly one success, :"
"n:`exactly_once @expr` succeeds like ``v``. If ``v`` has two or more "
"successes, exactly_once expr fails."
msgstr ""

#: ../../proof-engine/ltac.rst:470
msgid ""
"The experimental status of this tactic pertains to the fact if ``v`` "
"performs side effects, they may occur in an unpredictable way. Indeed, "
"normally ``v`` would only be executed up to the first success until "
"backtracking is needed, however exactly_once needs to look ahead to see "
"whether a second success exists, and may run further effects immediately."
msgstr ""

#: ../../proof-engine/ltac.rst:480
msgid "Checking the failure"
msgstr ""

#: ../../proof-engine/ltac.rst:482
msgid "Coq provides a derived tactic to check that a tactic *fails*:"
msgstr ""

#: ../../proof-engine/ltac.rst:487
msgid ""
"This behaves like :n:`tryif @expr then fail 0 tac \"succeeds\" else idtac`."
msgstr ""

#: ../../proof-engine/ltac.rst:490
msgid "Checking the success"
msgstr ""

#: ../../proof-engine/ltac.rst:492
msgid ""
"Coq provides a derived tactic to check that a tactic has *at least one* "
"success:"
msgstr ""

#: ../../proof-engine/ltac.rst:498
msgid ""
"This behaves like :n:`tryif (assert_fails tac) then fail 0 tac \"fails\" "
"else idtac`."
msgstr ""

#: ../../proof-engine/ltac.rst:502
msgid "Solving"
msgstr ""

#: ../../proof-engine/ltac.rst:504
msgid ""
"We may consider the first to solve (i.e. which generates no subgoal) among a "
"panel of tactics:"
msgstr ""

#: ../../proof-engine/ltac.rst:510
msgid ""
"The :n:`@expr__i` are evaluated to :n:`v__i` and :n:`v__i` must be tactic "
"values, for i = 1, ..., n. Supposing n > 1, :n:`solve [@expr__1 | ... | "
"@expr__n]` applies :n:`v__1` to each goal independently and stops if it "
"succeeds; otherwise it tries to apply :n:`v__2` and so on. It fails if there "
"is no solving tactic."
msgstr ""

#: ../../proof-engine/ltac.rst:520
msgid ""
"This is an |Ltac| alias that gives a primitive access to the :n:`solve:` "
"tactical. See the :n:`first` tactical for more information."
msgstr ""

#: ../../proof-engine/ltac.rst:524
msgid "Identity"
msgstr ""

#: ../../proof-engine/ltac.rst:526
msgid ""
"The constant :n:`idtac` is the identity tactic: it leaves any goal unchanged "
"but it appears in the proof script."
msgstr ""

#: ../../proof-engine/ltac.rst:532
msgid ""
"This prints the given tokens. Strings and integers are printed literally. If "
"a (term) variable is given, its contents are printed."
msgstr ""

#: ../../proof-engine/ltac.rst:536
msgid "Failing"
msgstr ""

#: ../../proof-engine/ltac.rst:541
msgid ""
"This is the always-failing tactic: it does not solve any goal. It is useful "
"for defining other tacticals since it can be caught by :tacn:`try`, :tacn:"
"`repeat`, :tacn:`match goal`, or the branching tacticals."
msgstr ""

#: ../../proof-engine/ltac.rst:547
msgid ""
"The number is the failure level. If no level is specified, it defaults to 0. "
"The level is used by :tacn:`try`, :tacn:`repeat`, :tacn:`match goal` and the "
"branching tacticals. If 0, it makes :tacn:`match goal` consider the next "
"clause (backtracking). If nonzero, the current :tacn:`match goal` block, :"
"tacn:`try`, :tacn:`repeat`, or branching command is aborted and the level is "
"decremented. In the case of :n:`+`, a nonzero level skips the first "
"backtrack point, even if the call to :n:`fail @num` is not enclosed in a :n:`"
"+` command, respecting the algebraic identity."
msgstr ""

#: ../../proof-engine/ltac.rst:558
msgid "The given tokens are used for printing the failure message."
msgstr ""

#: ../../proof-engine/ltac.rst:562
msgid "This is a combination of the previous variants."
msgstr ""

#: ../../proof-engine/ltac.rst:567
msgid ""
"This variant fails even when used after :n:`;` and there are no goals left. "
"Similarly, ``gfail`` fails even when used after ``all:`` and there are no "
"goals left. See the example for clarification."
msgstr ""

#: ../../proof-engine/ltac.rst:575
msgid ""
"These variants fail with an error message or an error level even if there "
"are no goals left. Be careful however if Coq terms have to be printed as "
"part of the failure: term construction always forces the tactic into the "
"goals, meaning that if there are no goals when it is evaluated, a tactic "
"call like :n:`let x := H in fail 0 x` will succeed."
msgstr ""

#: ../../proof-engine/ltac.rst:615
msgid "Timeout"
msgstr ""

#: ../../proof-engine/ltac.rst:617
msgid ""
"We can force a tactic to stop if it has not finished after a certain amount "
"of time:"
msgstr ""

#: ../../proof-engine/ltac.rst:623
msgid ""
":n:`@expr` is evaluated to ``v`` which must be a tactic value. The tactic "
"value ``v`` is applied normally, except that it is interrupted after :n:"
"`@num` seconds if it is still running. In this case the outcome is a failure."
msgstr ""

#: ../../proof-engine/ltac.rst:629
msgid ""
"For the moment, timeout is based on elapsed time in seconds, which is very "
"machine-dependent: a script that works on a quick machine may fail on a slow "
"one. The converse is even possible if you combine a timeout with some other "
"tacticals. This tactical is hence proposed only for convenience during "
"debugging or other development phases, we strongly advise you to not leave "
"any timeout in final scripts. Note also that this tactical isn’t available "
"on the native Windows port of Coq."
msgstr ""

#: ../../proof-engine/ltac.rst:638
msgid "Timing a tactic"
msgstr ""

#: ../../proof-engine/ltac.rst:640
msgid "A tactic execution can be timed:"
msgstr ""

#: ../../proof-engine/ltac.rst:645
msgid ""
"evaluates :n:`@expr` and displays the running time of the tactic expression, "
"whether it fails or succeeds. In case of several successes, the time for "
"each successive run is displayed. Time is in seconds and is machine-"
"dependent. The :n:`@string` argument is optional. When provided, it is used "
"to identify this particular occurrence of time."
msgstr ""

#: ../../proof-engine/ltac.rst:652
msgid "Timing a tactic that evaluates to a term"
msgstr ""

#: ../../proof-engine/ltac.rst:654
msgid ""
"Tactic expressions that produce terms can be timed with the experimental "
"tactic"
msgstr ""

#: ../../proof-engine/ltac.rst:660
msgid ""
"which evaluates :n:`@expr ()` and displays the time the tactic expression "
"evaluated, assuming successful evaluation. Time is in seconds and is machine-"
"dependent."
msgstr ""

#: ../../proof-engine/ltac.rst:664
msgid ""
"This tactic currently does not support nesting, and will report times based "
"on the innermost execution. This is due to the fact that it is implemented "
"using the tactics"
msgstr ""

#: ../../proof-engine/ltac.rst:671
msgid "and"
msgstr ""

#: ../../proof-engine/ltac.rst:676
msgid ""
"which (re)set and display an optionally named timer, respectively. The "
"parenthesized string argument to :n:`finish_timing` is also optional, and "
"determines the label associated with the timer for printing."
msgstr ""

#: ../../proof-engine/ltac.rst:680
msgid ""
"By copying the definition of :n:`time_constr` from the standard library, "
"users can achive support for a fixed pattern of nesting by passing "
"different :n:`@string` parameters to :n:`restart_timer` and :n:"
"`finish_timing` at each level of nesting."
msgstr ""

#: ../../proof-engine/ltac.rst:705
msgid "Local definitions"
msgstr ""

#: ../../proof-engine/ltac.rst:707
msgid "Local definitions can be done as follows:"
msgstr ""

#: ../../proof-engine/ltac.rst:712
msgid ""
"each :n:`@expr__i` is evaluated to :n:`v__i`, then, :n:`@expr` is evaluated "
"by substituting :n:`v__i` to each occurrence of :n:`@ident__i`, for i = "
"1, ..., n. There are no dependencies between the :n:`@expr__i` and the :n:"
"`@ident__i`."
msgstr ""

#: ../../proof-engine/ltac.rst:717
msgid ""
"Local definitions can be made recursive by using :n:`let rec` instead of :n:"
"`let`. In this latter case, the definitions are evaluated lazily so that the "
"rec keyword can be used also in non-recursive cases so as to avoid the eager "
"evaluation of local definitions."
msgstr ""

#: ../../proof-engine/ltac.rst:725
msgid "Application"
msgstr ""

#: ../../proof-engine/ltac.rst:727
msgid "An application is an expression of the following form:"
msgstr ""

#: ../../proof-engine/ltac.rst:731
msgid ""
"The reference :n:`@qualid` must be bound to some defined tactic definition "
"expecting at least as many arguments as the provided :n:`tacarg`. The "
"expressions :n:`@expr__i` are evaluated to :n:`v__i`, for i = 1, ..., n."
msgstr ""

#: ../../proof-engine/ltac.rst:738
msgid "Function construction"
msgstr ""

#: ../../proof-engine/ltac.rst:740
msgid ""
"A parameterized tactic can be built anonymously (without resorting to local "
"definitions) with:"
msgstr ""

#: ../../proof-engine/ltac.rst:745
msgid ""
"Indeed, local definitions of functions are a syntactic sugar for binding a :"
"n:`fun` tactic to an identifier."
msgstr ""

#: ../../proof-engine/ltac.rst:749
msgid "Pattern matching on terms"
msgstr ""

#: ../../proof-engine/ltac.rst:751
msgid "We can carry out pattern matching on terms with:"
msgstr ""

#: ../../proof-engine/ltac.rst:755
msgid ""
"The expression :n:`@expr` is evaluated and should yield a term which is "
"matched against :n:`cpattern__1`. The matching is non-linear: if a "
"metavariable occurs more than once, it should match the same expression "
"every time. It is first-order except on the variables of the form :n:`@?id` "
"that occur in head position of an application. For these variables, the "
"matching is second-order and returns a functional term."
msgstr ""

#: ../../proof-engine/ltac.rst:762
msgid ""
"Alternatively, when a metavariable of the form :n:`?id` occurs under "
"binders, say :n:`x__1, …, x__n` and the expression matches, the metavariable "
"is instantiated by a term which can then be used in any context which also "
"binds the variables :n:`x__1, …, x__n` with same types. This provides with a "
"primitive form of matching under context which does not require manipulating "
"a functional term."
msgstr ""

#: ../../proof-engine/ltac.rst:769
msgid ""
"If the matching with :n:`@cpattern__1` succeeds, then :n:`@expr__1` is "
"evaluated into some value by substituting the pattern matching "
"instantiations to the metavariables. If :n:`@expr__1` evaluates to a tactic "
"and the match expression is in position to be applied to a goal (e.g. it is "
"not bound to a variable by a :n:`let in`), then this tactic is applied. If "
"the tactic succeeds, the list of resulting subgoals is the result of the "
"match expression. If :n:`@expr__1` does not evaluate to a tactic or if the "
"match expression is not in position to be applied to a goal, then the result "
"of the evaluation of :n:`@expr__1` is the result of the match expression."
msgstr ""

#: ../../proof-engine/ltac.rst:780
msgid ""
"If the matching with :n:`@cpattern__1` fails, or if it succeeds but the "
"evaluation of :n:`@expr__1` fails, or if the evaluation of :n:`@expr__1` "
"succeeds but returns a tactic in execution position whose execution fails, "
"then :n:`cpattern__2` is used and so on. The pattern :n:`_` matches any term "
"and shadows all remaining patterns if any. If all clauses fail (in "
"particular, there is no pattern :n:`_`) then a no-matching-clause error is "
"raised."
msgstr ""

#: ../../proof-engine/ltac.rst:788
msgid ""
"Failures in subsequent tactics do not cause backtracking to select new "
"branches or inside the right-hand side of the selected branch even if it has "
"backtracking points."
msgstr ""

#: ../../proof-engine/ltac.rst:794
msgid "No pattern can be used and, in particular, there is no :n:`_` pattern."
msgstr ""

#: ../../proof-engine/ltac.rst:798
msgid "This happens when :n:`@expr` does not denote a term."
msgstr ""

#: ../../proof-engine/ltac.rst:802
msgid ""
"Using multimatch instead of match will allow subsequent tactics to backtrack "
"into a right-hand side tactic which has backtracking points left and trigger "
"the selection of a new matching branch when all the backtracking points of "
"the right-hand side have been consumed."
msgstr ""

#: ../../proof-engine/ltac.rst:807
msgid ""
"The syntax :n:`match …` is, in fact, a shorthand for :n:`once multimatch …`."
msgstr ""

#: ../../proof-engine/ltac.rst:811
msgid ""
"Using lazymatch instead of match will perform the same pattern matching "
"procedure but will commit to the first matching branch rather than trying a "
"new matching if the right-hand side fails. If the right-hand side of the "
"selected branch is a tactic with backtracking points, then subsequent "
"failures cause this tactic to backtrack."
msgstr ""

#: ../../proof-engine/ltac.rst:820
msgid ""
"This special form of patterns matches any term with a subterm matching "
"cpattern. If there is a match, the optional :n:`@ident` is assigned the "
"\"matched context\", i.e. the initial term where the matched subterm is "
"replaced by a hole. The example below will show how to use such term "
"contexts."
msgstr ""

#: ../../proof-engine/ltac.rst:825
msgid ""
"If the evaluation of the right-hand-side of a valid match fails, the next "
"matching subterm is tried. If no further subterm matches, the next clause is "
"tried. Matching subterms are considered top-bottom and from left to right "
"(with respect to the raw printing obtained by setting option :flag:`Printing "
"All`)."
msgstr ""

#: ../../proof-engine/ltac.rst:848
msgid "Pattern matching on goals"
msgstr ""

#: ../../proof-engine/ltac.rst:850
msgid ""
"We can perform pattern matching on goals using the following expression:"
msgstr ""

#: ../../proof-engine/ltac.rst:857
msgid ""
"If each hypothesis pattern :n:`hyp`\\ :sub:`1,i`, with i = 1, ..., m\\ :sub:"
"`1` is matched (non-linear first-order unification) by a hypothesis of the "
"goal and if :n:`cpattern_1` is matched by the conclusion of the goal, then :"
"n:`@expr__1` is evaluated to :n:`v__1` by substituting the pattern matching "
"to the metavariables and the real hypothesis names bound to the possible "
"hypothesis names occurring in the hypothesis patterns. If :n:`v__1` is a "
"tactic value, then it is applied to the goal. If this application fails, "
"then another combination of hypotheses is tried with the same proof context "
"pattern. If there is no other combination of hypotheses then the second "
"proof context pattern is tried and so on. If the next to last proof context "
"pattern fails then the last :n:`@expr` is evaluated to :n:`v` and :n:`v` is "
"applied. Note also that matching against subterms (using the :n:`context "
"@ident [ @cpattern ]`) is available and is also subject to yielding several "
"matchings."
msgstr ""

#: ../../proof-engine/ltac.rst:873
msgid ""
"Failures in subsequent tactics do not cause backtracking to select new "
"branches or combinations of hypotheses, or inside the right-hand side of the "
"selected branch even if it has backtracking points."
msgstr ""

#: ../../proof-engine/ltac.rst:879
msgid ""
"No clause succeeds, i.e. all matching patterns, if any, fail at the "
"application of the right-hand-side."
msgstr ""

#: ../../proof-engine/ltac.rst:884
msgid ""
"It is important to know that each hypothesis of the goal can be matched by "
"at most one hypothesis pattern. The order of matching is the following: "
"hypothesis patterns are examined from right to left (i.e. hyp\\ :sub:`i,m`"
"\\ :sub:`i`` before hyp\\ :sub:`i,1`). For each hypothesis pattern, the goal "
"hypotheses are matched in order (newest first), but it possible to reverse "
"this order (oldest first) with the :n:`match reverse goal with` variant."
msgstr ""

#: ../../proof-engine/ltac.rst:894
msgid ""
"Using :n:`multimatch` instead of :n:`match` will allow subsequent tactics to "
"backtrack into a right-hand side tactic which has backtracking points left "
"and trigger the selection of a new matching branch or combination of "
"hypotheses when all the backtracking points of the right-hand side have been "
"consumed."
msgstr ""

#: ../../proof-engine/ltac.rst:900
msgid ""
"The syntax :n:`match [reverse] goal …` is, in fact, a shorthand for :n:`once "
"multimatch [reverse] goal …`."
msgstr ""

#: ../../proof-engine/ltac.rst:905
msgid ""
"Using lazymatch instead of match will perform the same pattern matching "
"procedure but will commit to the first matching branch with the first "
"matching combination of hypotheses rather than trying a new matching if the "
"right-hand side fails. If the right-hand side of the selected branch is a "
"tactic with backtracking points, then subsequent failures cause this tactic "
"to backtrack."
msgstr ""

#: ../../proof-engine/ltac.rst:913
msgid "Filling a term context"
msgstr ""

#: ../../proof-engine/ltac.rst:915
msgid ""
"The following expression is not a tactic in the sense that it does not "
"produce subgoals but generates a term to be used in tactic expressions:"
msgstr ""

#: ../../proof-engine/ltac.rst:920
msgid ""
":n:`@ident` must denote a context variable bound by a context pattern of a "
"match expression. This expression evaluates replaces the hole of the value "
"of :n:`@ident` by the value of :n:`@expr`."
msgstr ""

#: ../../proof-engine/ltac.rst:931
msgid "Generating fresh hypothesis names"
msgstr ""

#: ../../proof-engine/ltac.rst:933
msgid ""
"Tactics sometimes have to generate new names for hypothesis. Letting the "
"system decide a name with the intro tactic is not so good since it is very "
"awkward to retrieve the name the system gave. The following expression "
"returns an identifier:"
msgstr ""

#: ../../proof-engine/ltac.rst:940
msgid ""
"It evaluates to an identifier unbound in the goal. This fresh identifier is "
"obtained by concatenating the value of the :n:`@component`\\ s (each of them "
"is, either a :n:`@qualid` which has to refer to a (unqualified) name, or "
"directly a name denoted by a :n:`@string`)."
msgstr ""

#: ../../proof-engine/ltac.rst:945
msgid ""
"If the resulting name is already used, it is padded with a number so that it "
"becomes fresh. If no component is given, the name is a fresh derivative of "
"the name ``H``."
msgstr ""

#: ../../proof-engine/ltac.rst:950
msgid "Computing in a constr"
msgstr ""

#: ../../proof-engine/ltac.rst:952
msgid "Evaluation of a term can be performed with:"
msgstr ""

#: ../../proof-engine/ltac.rst:956
msgid ""
"where :n:`@redexpr` is a reduction tactic among :tacn:`red`, :tacn:`hnf`, :"
"tacn:`compute`, :tacn:`simpl`, :tacn:`cbv`, :tacn:`lazy`, :tacn:`unfold`, :"
"tacn:`fold`, :tacn:`pattern`."
msgstr ""

#: ../../proof-engine/ltac.rst:961
msgid "Recovering the type of a term"
msgstr ""

#: ../../proof-engine/ltac.rst:963
msgid "The following returns the type of term:"
msgstr ""

#: ../../proof-engine/ltac.rst:968
msgid "Manipulating untyped terms"
msgstr ""

#: ../../proof-engine/ltac.rst:972
msgid ""
"The terms built in |Ltac| are well-typed by default. It may not be "
"appropriate for building large terms using a recursive |Ltac| function: the "
"term has to be entirely type checked at each step, resulting in potentially "
"very slow behavior. It is possible to build untyped terms using |Ltac| with "
"the :n:`uconstr : @term` syntax."
msgstr ""

#: ../../proof-engine/ltac.rst:980
msgid ""
"An untyped term, in |Ltac|, can contain references to hypotheses or to |"
"Ltac| variables containing typed or untyped terms. An untyped term can be "
"type checked using the function type_term whose argument is parsed as an "
"untyped term and returns a well-typed term which can be used in tactics."
msgstr ""

#: ../../proof-engine/ltac.rst:985
msgid ""
"Untyped terms built using :n:`uconstr :` can also be used as arguments to "
"the :tacn:`refine` tactic. In that case the untyped term is type checked "
"against the conclusion of the goal, and the holes which are not solved by "
"the typing procedure are turned into new subgoals."
msgstr ""

#: ../../proof-engine/ltac.rst:991
msgid "Counting the goals"
msgstr ""

#: ../../proof-engine/ltac.rst:995
msgid ""
"The number of goals under focus can be recovered using the :n:`numgoals` "
"function. Combined with the guard command below, it can be used to branch "
"over the number of goals produced by previous tactics."
msgstr ""

#: ../../proof-engine/ltac.rst:1013
msgid "Testing boolean expressions"
msgstr ""

#: ../../proof-engine/ltac.rst:1018
msgid ""
"The :tacn:`guard` tactic tests a boolean expression, and fails if the "
"expression evaluates to false. If the expression evaluates to true, it "
"succeeds without affecting the proof."
msgstr ""

#: ../../proof-engine/ltac.rst:1022
msgid "The accepted tests are simple integer comparisons."
msgstr ""

#: ../../proof-engine/ltac.rst:1039
msgid "Proving a subgoal as a separate lemma"
msgstr ""

#: ../../proof-engine/ltac.rst:1044
msgid ""
"From the outside, :n:`abstract @expr` is the same as :n:`solve @expr`. "
"Internally it saves an auxiliary lemma called ``ident_subproofn`` where "
"``ident`` is the name of the current goal and ``n`` is chosen so that this "
"is a fresh name. Such an auxiliary lemma is inlined in the final proof term."
msgstr ""

#: ../../proof-engine/ltac.rst:1049
msgid ""
"This tactical is useful with tactics such as :tacn:`omega` or :tacn:"
"`discriminate` that generate huge proof terms. With that tool the user can "
"avoid the explosion at time of the Save command without having to cut "
"manually the proof in smaller lemmas."
msgstr ""

#: ../../proof-engine/ltac.rst:1054
msgid ""
"It may be useful to generate lemmas minimal w.r.t. the assumptions they "
"depend on. This can be obtained thanks to the option below."
msgstr ""

#: ../../proof-engine/ltac.rst:1059
msgid "Give explicitly the name of the auxiliary lemma."
msgstr ""

#: ../../proof-engine/ltac.rst:1063
msgid ""
"Use this feature at your own risk; explicitly named and reused subterms "
"don’t play well with asynchronous proofs."
msgstr ""

#: ../../proof-engine/ltac.rst:1069
msgid "Save the subproof in a transparent lemma rather than an opaque one."
msgstr ""

#: ../../proof-engine/ltac.rst:1073
msgid ""
"Use this feature at your own risk; building computationally relevant terms "
"with tactics is fragile."
msgstr ""

#: ../../proof-engine/ltac.rst:1078
msgid "Give explicitly the name of the auxiliary transparent lemma."
msgstr ""

#: ../../proof-engine/ltac.rst:1082
msgid ""
"Use this feature at your own risk; building computationally relevant terms "
"with tactics is fragile, and explicitly named and reused subterms don’t play "
"well with asynchronous proofs."
msgstr ""

#: ../../proof-engine/ltac.rst:1090
msgid "Tactic toplevel definitions"
msgstr ""

#: ../../proof-engine/ltac.rst:1093
msgid "Defining |Ltac| functions"
msgstr ""

#: ../../proof-engine/ltac.rst:1095
msgid "Basically, |Ltac| toplevel definitions are made as follows:"
msgstr ""

#: ../../proof-engine/ltac.rst:1099
msgid ""
"This defines a new |Ltac| function that can be used in any tactic script or "
"new |Ltac| toplevel definition."
msgstr ""

#: ../../proof-engine/ltac.rst:1104
msgid "The preceding definition can equivalently be written:"
msgstr ""

#: ../../proof-engine/ltac.rst:1106
msgid ":n:`Ltac @ident := fun {+ @ident} => @expr`"
msgstr ""

#: ../../proof-engine/ltac.rst:1108
msgid ""
"Recursive and mutual recursive function definitions are also possible with "
"the syntax:"
msgstr ""

#: ../../proof-engine/ltac.rst:1113
msgid ""
"It is also possible to *redefine* an existing user-defined tactic using the "
"syntax:"
msgstr ""

#: ../../proof-engine/ltac.rst:1117
msgid ""
"A previous definition of qualid must exist in the environment. The new "
"definition will always be used instead of the old one and it goes across "
"module boundaries."
msgstr ""

#: ../../proof-engine/ltac.rst:1121
msgid ""
"If preceded by the keyword Local the tactic definition will not be exported "
"outside the current module."
msgstr ""

#: ../../proof-engine/ltac.rst:1125
msgid "Printing |Ltac| tactics"
msgstr ""

#: ../../proof-engine/ltac.rst:1129
msgid "Defined |Ltac| functions can be displayed using this command."
msgstr ""

#: ../../proof-engine/ltac.rst:1133
msgid ""
"This command displays a list of all user-defined tactics, with their "
"arguments."
msgstr ""

#: ../../proof-engine/ltac.rst:1136
msgid "Debugging |Ltac| tactics"
msgstr ""

#: ../../proof-engine/ltac.rst:1139
msgid "Info trace"
msgstr ""

#: ../../proof-engine/ltac.rst:1144
msgid ""
"This command can be used to print the trace of the path eventually taken by "
"an |Ltac| script. That is, the list of executed tactics, discarding all the "
"branches which have failed. To that end the :cmd:`Info` command can be used "
"with the following syntax."
msgstr ""

#: ../../proof-engine/ltac.rst:1150
msgid ""
"The number :n:`@num` is the unfolding level of tactics in the trace. At "
"level 0, the trace contains a sequence of tactics in the actual script, at "
"level 1, the trace will be the concatenation of the traces of these tactics, "
"etc…"
msgstr ""

#: ../../proof-engine/ltac.rst:1173
msgid ""
"The trace produced by :cmd:`Info` tries its best to be a reparsable |Ltac| "
"script, but this goal is not achievable in all generality. So some of the "
"output traces will contain oddities."
msgstr ""

#: ../../proof-engine/ltac.rst:1177
msgid ""
"As an additional help for debugging, the trace produced by :cmd:`Info` "
"contains (in comments) the messages produced by the :tacn:`idtac` tactical "
"at the right position in the script. In particular, the calls to idtac in "
"branches which failed are not printed."
msgstr ""

#: ../../proof-engine/ltac.rst:1185
msgid "This option is an alternative to the :cmd:`Info` command."
msgstr ""

#: ../../proof-engine/ltac.rst:1187
msgid ""
"This will automatically print the same trace as :n:`Info @num` at each "
"tactic call. The unfolding level can be overridden by a call to the :cmd:"
"`Info` command."
msgstr ""

#: ../../proof-engine/ltac.rst:1192
msgid "Interactive debugger"
msgstr ""

#: ../../proof-engine/ltac.rst:1196
msgid ""
"This option governs the step-by-step debugger that comes with the |Ltac| "
"interpreter"
msgstr ""

#: ../../proof-engine/ltac.rst:1198
msgid ""
"When the debugger is activated, it stops at every step of the evaluation of "
"the current |Ltac| expression and prints information on what it is doing. "
"The debugger stops, prompting for a command which can be one of the "
"following:"
msgstr ""

#: ../../proof-engine/ltac.rst:1204
msgid "simple newline:"
msgstr ""

#: ../../proof-engine/ltac.rst:1204
msgid "go to the next step"
msgstr ""

#: ../../proof-engine/ltac.rst:1206
msgid "h:"
msgstr ""

#: ../../proof-engine/ltac.rst:1206
msgid "get help"
msgstr ""

#: ../../proof-engine/ltac.rst:1208
msgid "x:"
msgstr ""

#: ../../proof-engine/ltac.rst:1208
msgid "exit current evaluation"
msgstr ""

#: ../../proof-engine/ltac.rst:1210
msgid "s:"
msgstr ""

#: ../../proof-engine/ltac.rst:1210
msgid "continue current evaluation without stopping"
msgstr ""

#: ../../proof-engine/ltac.rst:1212
msgid "r n:"
msgstr ""

#: ../../proof-engine/ltac.rst:1212
msgid "advance n steps further"
msgstr ""

#: ../../proof-engine/ltac.rst:1214
msgid "r string:"
msgstr ""

#: ../../proof-engine/ltac.rst:1214
msgid "advance up to the next call to “idtac string”"
msgstr ""

#: ../../proof-engine/ltac.rst:1220
msgid "A non-interactive mode for the debugger is available via the option:"
msgstr ""

#: ../../proof-engine/ltac.rst:1224
msgid ""
"This option has the effect of presenting a newline at every prompt, when the "
"debugger is on. The debug log thus created, which does not require user "
"input to generate when this option is set, can then be run through external "
"tools such as diff."
msgstr ""

#: ../../proof-engine/ltac.rst:1230
msgid "Profiling |Ltac| tactics"
msgstr ""

#: ../../proof-engine/ltac.rst:1232
msgid ""
"It is possible to measure the time spent in invocations of primitive tactics "
"as well as tactics defined in |Ltac| and their inner invocations. The "
"primary use is the development of complex tactics, which can sometimes be so "
"slow as to impede interactive usage. The reasons for the performence "
"degradation can be intricate, like a slowly performing |Ltac| match or a sub-"
"tactic whose performance only degrades in certain situations. The profiler "
"generates a call tree and indicates the time spent in a tactic depending on "
"its calling context. Thus it allows to locate the part of a tactic "
"definition that contains the performance issue."
msgstr ""

#: ../../proof-engine/ltac.rst:1245
msgid "This option enables and disables the profiler."
msgstr ""

#: ../../proof-engine/ltac.rst:1249
msgid "Prints the profile"
msgstr ""

#: ../../proof-engine/ltac.rst:1253
msgid ""
"Prints a profile for all tactics that start with :n:`@string`. Append a "
"period (.) to the string if you only want exactly that name."
msgstr ""

#: ../../proof-engine/ltac.rst:1258
msgid "Resets the profile, that is, deletes all accumulated information."
msgstr ""

#: ../../proof-engine/ltac.rst:1262
msgid ""
"Backtracking across a :cmd:`Reset Ltac Profile` will not restore the "
"information."
msgstr ""

#: ../../proof-engine/ltac.rst:1298
msgid "This tactic behaves like :tacn:`idtac` but enables the profiler."
msgstr ""

#: ../../proof-engine/ltac.rst:1303
msgid ""
"Similarly to :tacn:`start ltac profiling`, this tactic behaves like :tacn:"
"`idtac`. Together, they allow you to exclude parts of a proof script from "
"profiling."
msgstr ""

#: ../../proof-engine/ltac.rst:1310 ../../proof-engine/ltac.rst:1317
#: ../../proof-engine/ltac.rst:1324
msgid ""
"This tactic behaves like the corresponding vernacular command and allow "
"displaying and resetting the profile from tactic scripts for benchmarking "
"purposes."
msgstr ""

#: ../../proof-engine/ltac.rst:1328
msgid ""
"You can also pass the ``-profile-ltac`` command line option to ``coqc``, "
"which turns the :flag:`Ltac Profiling` option on at the beginning of each "
"document, and performs a :cmd:`Show Ltac Profile` at the end."
msgstr ""

#: ../../proof-engine/ltac.rst:1334
msgid ""
"Note that the profiler currently does not handle backtracking into multi-"
"success tactics, and issues a warning to this effect in many cases when such "
"backtracking occurs."
msgstr ""

#: ../../proof-engine/ltac.rst:1339
msgid "Run-time optimization tactic"
msgstr ""

#: ../../proof-engine/ltac.rst:1344
msgid ""
"This tactic behaves like :n:`idtac`, except that running it compacts the "
"heap in the OCaml run-time system. It is analogous to the Vernacular "
"command :cmd:`Optimize Heap`."
msgstr ""

#: ../../proof-engine/proof-handling.rst:5
msgid "Proof handling"
msgstr ""

#: ../../proof-engine/proof-handling.rst:7
msgid ""
"In |Coq|’s proof editing mode all top-level commands documented in Chapter :"
"ref:`vernacularcommands` remain available and the user has access to "
"specialized commands dealing with proof development pragmas documented in "
"this section. They can also use some other specialized commands called "
"*tactics*. They are the very tools allowing the user to deal with logical "
"reasoning. They are documented in Chapter :ref:`tactics`."
msgstr ""

#: ../../proof-engine/proof-handling.rst:14
msgid ""
"Coq user interfaces usually have a way of marking whether the user has "
"switched to proof editing mode. For instance, in coqtop the prompt ``Coq "
"<``   is changed into :n:`@ident <`   where :token:`ident` is the declared "
"name of the theorem currently edited."
msgstr ""

#: ../../proof-engine/proof-handling.rst:18
msgid ""
"At each stage of a proof development, one has a list of goals to prove. "
"Initially, the list consists only in the theorem itself. After having "
"applied some tactics, the list of goals contains the subgoals generated by "
"the tactics."
msgstr ""

#: ../../proof-engine/proof-handling.rst:23
msgid ""
"To each subgoal is associated a number of hypotheses called the *local "
"context* of the goal. Initially, the local context contains the local "
"variables and hypotheses of the current section (see Section :ref:`gallina-"
"assumptions`) and the local variables and hypotheses of the theorem "
"statement. It is enriched by the use of certain tactics (see e.g. :tacn:"
"`intro`)."
msgstr ""

#: ../../proof-engine/proof-handling.rst:29
msgid ""
"When a proof is completed, the message ``Proof completed`` is displayed. One "
"can then register this proof as a defined constant in the environment. "
"Because there exists a correspondence between proofs and terms of λ-"
"calculus, known as the *Curry-Howard isomorphism* :cite:`How80,Bar81,Gir89,"
"Hue88`, |Coq| stores proofs as terms of |Cic|. Those terms are called *proof "
"terms*."
msgstr ""

#: ../../proof-engine/proof-handling.rst:39
msgid ""
"Coq raises this error message when one attempts to use a proof editing "
"command out of the proof editing mode."
msgstr ""

#: ../../proof-engine/proof-handling.rst:45
msgid "Switching on/off the proof editing mode"
msgstr ""

#: ../../proof-engine/proof-handling.rst:47
msgid ""
"The proof editing mode is entered by asserting a statement, which typically "
"is the assertion of a theorem using an assertion command like :cmd:"
"`Theorem`. The list of assertion commands is given in :ref:`Assertions`. The "
"command :cmd:`Goal` can also be used."
msgstr ""

#: ../../proof-engine/proof-handling.rst:54
msgid ""
"This is intended for quick assertion of statements, without knowing in "
"advance which name to give to the assertion, typically for quick testing of "
"the provability of a statement. If the proof of the statement is eventually "
"completed and validated, the statement is then bound to the name "
"``Unnamed_thm`` (or a variant of this name not already used for another "
"statement)."
msgstr ""

#: ../../proof-engine/proof-handling.rst:63
msgid ""
"This command is available in interactive editing proof mode when the proof "
"is completed. Then :cmd:`Qed` extracts a proof term from the proof script, "
"switches back to Coq top-level and attaches the extracted proof term to the "
"declared name of the original goal. This name is added to the environment as "
"an opaque constant."
msgstr ""

#: ../../proof-engine/proof-handling.rst:73
msgid ""
"Sometimes an error occurs when building the proof term, because tactics do "
"not enforce completely the term construction constraints."
msgstr ""

#: ../../proof-engine/proof-handling.rst:77
msgid ""
"The user should also be aware of the fact that since the proof term is "
"completely rechecked at this point, one may have to wait a while when the "
"proof is large. In some exceptional cases one may even incur a memory "
"overflow."
msgstr ""

#: ../../proof-engine/proof-handling.rst:85
msgid ""
"Same as :cmd:`Qed` but the proof is then declared transparent, which means "
"that its content can be explicitly used for type checking and that it can be "
"unfolded in conversion tactics (see :ref:`performingcomputations`, :cmd:"
"`Opaque`, :cmd:`Transparent`)."
msgstr ""

#: ../../proof-engine/proof-handling.rst:93
msgid ""
"Forces the name of the original goal to be :token:`ident`. This command (and "
"the following ones) can only be used if the original goal has been opened "
"using the :cmd:`Goal` command."
msgstr ""

#: ../../proof-engine/proof-handling.rst:99
msgid ""
"This command is available in interactive editing mode to give up the current "
"proof and declare the initial goal as an axiom."
msgstr ""

#: ../../proof-engine/proof-handling.rst:104
msgid ""
"This command cancels the current proof development, switching back to the "
"previous proof development, or to the |Coq| toplevel if no other proof was "
"edited."
msgstr ""

#: ../../proof-engine/proof-handling.rst:112
msgid ""
"Aborts the editing of the proof named :token:`ident` (in case you have "
"nested proofs)."
msgstr ""

#: ../../proof-engine/proof-handling.rst:117
msgid "Aborts all current goals."
msgstr ""

#: ../../proof-engine/proof-handling.rst:122
msgid ""
"This command applies in proof editing mode. It is equivalent to :n:`exact "
"@term. Qed.` That is, you have to give the full proof in one gulp, as a "
"proof term (see Section :ref:`applyingtheorems`)."
msgstr ""

#: ../../proof-engine/proof-handling.rst:129
msgid ""
"Is a no-op which is useful to delimit the sequence of tactic commands which "
"start a proof, after a :cmd:`Theorem` command. It is a good practice to use :"
"cmd:`Proof` as an opening parenthesis, closed in the script with a closing :"
"cmd:`Qed`."
msgstr ""

#: ../../proof-engine/proof-handling.rst:134
msgid ":cmd:`Proof with`"
msgstr ""

#: ../../proof-engine/proof-handling.rst:138
msgid ""
"This command applies in proof editing mode. It declares the set of section "
"variables (see :ref:`gallina-assumptions`) used by the proof. At :cmd:`Qed` "
"time, the system will assert that the set of section variables actually used "
"in the proof is a subset of the declared one."
msgstr ""

#: ../../proof-engine/proof-handling.rst:144
msgid ""
"The set of declared variables is closed under type dependency. For example "
"if ``T`` is variable and a is a variable of type ``T``, the commands ``Proof "
"using a`` and ``Proof using T a`` are actually equivalent."
msgstr ""

#: ../../proof-engine/proof-handling.rst:150
msgid "Combines in a single line :cmd:`Proof with` and :cmd:`Proof using`."
msgstr ""

#: ../../proof-engine/proof-handling.rst:152
msgid ":ref:`tactics-implicit-automation`"
msgstr ""

#: ../../proof-engine/proof-handling.rst:156
msgid "Use all section variables."
msgstr ""

#: ../../proof-engine/proof-handling.rst:160
msgid "Use only section variables occurring in the statement."
msgstr ""

#: ../../proof-engine/proof-handling.rst:164
msgid ""
"The ``*`` operator computes the forward transitive closure. E.g. if the "
"variable ``H`` has type ``p < 5`` then ``H`` is in ``p*`` since ``p`` occurs "
"in the type of ``H``. ``Type*`` is the forward transitive closure of the "
"entire set of section variables occurring in the statement."
msgstr ""

#: ../../proof-engine/proof-handling.rst:171
msgid "Use all section variables except the list of :token:`ident`."
msgstr ""

#: ../../proof-engine/proof-handling.rst:175
msgid ""
"Use section variables from the union of both collections. See :ref:"
"`nameaset` to know how to form a named collection."
msgstr ""

#: ../../proof-engine/proof-handling.rst:180
msgid ""
"Use section variables which are in the first collection but not in the "
"second one."
msgstr ""

#: ../../proof-engine/proof-handling.rst:185
msgid ""
"Use section variables which are in the first collection but not in the list "
"of :token:`ident`."
msgstr ""

#: ../../proof-engine/proof-handling.rst:190
msgid ""
"Use section variables in the forward transitive closure of the collection. "
"The ``*`` operator binds stronger than ``+`` and ``-``."
msgstr ""

#: ../../proof-engine/proof-handling.rst:195
msgid "Proof using options"
msgstr ""

#: ../../proof-engine/proof-handling.rst:197
msgid "The following options modify the behavior of ``Proof using``."
msgstr ""

#: ../../proof-engine/proof-handling.rst:203
msgid ""
"Use :n:`@expression` as the default ``Proof using`` value. E.g. ``Set "
"Default Proof Using \"a b\"`` will complete all ``Proof`` commands not "
"followed by a ``using`` part with ``using a b``."
msgstr ""

#: ../../proof-engine/proof-handling.rst:210
msgid ""
"When :cmd:`Qed` is performed, suggest a ``using`` annotation if the user did "
"not provide one."
msgstr ""

#: ../../proof-engine/proof-handling.rst:216
msgid "Name a set of section hypotheses for ``Proof using``"
msgstr ""

#: ../../proof-engine/proof-handling.rst:220
msgid ""
"This can be used to name a set of section hypotheses, with the purpose of "
"making ``Proof using`` annotations more compact."
msgstr ""

#: ../../proof-engine/proof-handling.rst:226
msgid ""
"Define the collection named ``Some`` containing ``x``, ``y`` and ``z``::"
msgstr ""

#: ../../proof-engine/proof-handling.rst:230
msgid "Define the collection named ``Fewer`` containing only ``x`` and ``y``::"
msgstr ""

#: ../../proof-engine/proof-handling.rst:234
msgid ""
"Define the collection named ``Many`` containing the set union or set "
"difference of ``Fewer`` and ``Some``::"
msgstr ""

#: ../../proof-engine/proof-handling.rst:240
msgid ""
"Define the collection named ``Many`` containing the set difference of "
"``Fewer`` and the unnamed collection ``x y``::"
msgstr ""

#: ../../proof-engine/proof-handling.rst:249
msgid ""
"This command instantiates an existential variable. :token:`num` is an index "
"in the list of uninstantiated existential variables displayed by :cmd:`Show "
"Existentials`."
msgstr ""

#: ../../proof-engine/proof-handling.rst:252
msgid ""
"This command is intended to be used to instantiate existential variables "
"when the proof is completed but some uninstantiated existential variables "
"remain. To instantiate existential variables during proof edition, you "
"should use the tactic :tacn:`instantiate`."
msgstr ""

#: ../../proof-engine/proof-handling.rst:259
msgid ""
"This command can be run when a proof has no more goal to be solved but has "
"remaining uninstantiated existential variables. It takes every "
"uninstantiated existential variable and turns it into a goal."
msgstr ""

#: ../../proof-engine/proof-handling.rst:265
msgid "Navigation in the proof tree"
msgstr ""

#: ../../proof-engine/proof-handling.rst:269
msgid ""
"This command cancels the effect of the last command. Thus, it backtracks one "
"step."
msgstr ""

#: ../../proof-engine/proof-handling.rst:274
msgid "Repeats Undo :token:`num` times."
msgstr ""

#: ../../proof-engine/proof-handling.rst:279
msgid "This command restores the proof editing process to the original goal."
msgstr ""

#: ../../proof-engine/proof-handling.rst:285
msgid ""
"This focuses the attention on the first subgoal to prove and the printing of "
"the other subgoals is suspended until the focused subgoal is solved or "
"unfocused. This is useful when there are many current subgoals which clutter "
"your screen."
msgstr ""

#: ../../proof-engine/proof-handling.rst:292
msgid "Prefer the use of bullets or focusing brackets (see below)."
msgstr ""

#: ../../proof-engine/proof-handling.rst:296
msgid "This focuses the attention on the :token:`num` th subgoal to prove."
msgstr ""

#: ../../proof-engine/proof-handling.rst:300
msgid "Prefer the use of focusing brackets with a goal selector (see below)."
msgstr ""

#: ../../proof-engine/proof-handling.rst:304
msgid ""
"This command restores to focus the goal that were suspended by the last :cmd:"
"`Focus` command."
msgstr ""

#: ../../proof-engine/proof-handling.rst:311
msgid ""
"Succeeds if the proof is fully unfocused, fails if there are some goals out "
"of focus."
msgstr ""

#: ../../proof-engine/proof-handling.rst:321
msgid ""
"The command ``{`` (without a terminating period) focuses on the first goal, "
"much like :cmd:`Focus` does, however, the subproof can only be unfocused "
"when it has been fully solved ( *i.e.* when there is no focused goal left). "
"Unfocusing is then handled by ``}`` (again, without a terminating period). "
"See also an example in the next section."
msgstr ""

#: ../../proof-engine/proof-handling.rst:327
msgid ""
"Note that when a focused goal is proved a message is displayed together with "
"a suggestion about the right bullet or ``}`` to unfocus it or focus the next "
"one."
msgstr ""

#: ../../proof-engine/proof-handling.rst:333
msgid "This focuses on the :token:`num` th subgoal to prove."
msgstr ""

#: ../../proof-engine/proof-handling.rst:335
#: ../../proof-engine/vernacular-commands.rst:20
msgid "Error messages:"
msgstr ""

#: ../../proof-engine/proof-handling.rst:339
msgid ""
"You are trying to use ``}`` but the current subproof has not been fully "
"solved."
msgstr ""

#: ../../proof-engine/proof-handling.rst:347
msgid "The error messages about bullets below."
msgstr ""

#: ../../proof-engine/proof-handling.rst:352
msgid "Bullets"
msgstr ""

#: ../../proof-engine/proof-handling.rst:354
msgid ""
"Alternatively to ``{`` and ``}``, proofs can be structured with bullets. The "
"use of a bullet ``b`` for the first time focuses on the first goal ``g``, "
"the same bullet cannot be used again until the proof of ``g`` is completed, "
"then it is mandatory to focus the next goal with ``b``. The consequence is "
"that ``g`` and all goals present when ``g`` was focused are focused with the "
"same bullet ``b``. See the example below."
msgstr ""

#: ../../proof-engine/proof-handling.rst:361
msgid ""
"Different bullets can be used to nest levels. The scope of bullet does not "
"go beyond enclosing ``{`` and ``}``, so bullets can be reused as further "
"nesting levels provided they are delimited by these. Bullets are made of "
"repeated ``-``, ``+`` or ``*`` symbols:"
msgstr ""

#: ../../proof-engine/proof-handling.rst:368
msgid ""
"Note again that when a focused goal is proved a message is displayed "
"together with a suggestion about the right bullet or ``}`` to unfocus it or "
"focus the next one."
msgstr ""

#: ../../proof-engine/proof-handling.rst:374
msgid ""
"In Proof General (``Emacs`` interface to |Coq|), you must use bullets with "
"the priority ordering shown above to have a correct indentation. For example "
"``-`` must be the outer bullet and ``**`` the inner one in the example below."
msgstr ""

#: ../../proof-engine/proof-handling.rst:379
msgid "The following example script illustrates all these features:"
msgstr ""

#: ../../proof-engine/proof-handling.rst:403
msgid ""
"Before using bullet :n:`@bullet__1` again, you should first finish proving "
"the current focused goal. Note that :n:`@bullet__1` and :n:`@bullet__2` may "
"be the same."
msgstr ""

#: ../../proof-engine/proof-handling.rst:409
msgid ""
"You must put :n:`@bullet__2` to focus on the next goal. No other bullet is "
"allowed here."
msgstr ""

#: ../../proof-engine/proof-handling.rst:414
msgid ""
"You tried to apply a tactic but no goals were under focus. Using :n:"
"`@bullet` is  mandatory here."
msgstr ""

#: ../../proof-engine/proof-handling.rst:424
msgid ""
"You just finished a goal focused by ``{``, you must unfocus it with ``}``."
msgstr ""

#: ../../proof-engine/proof-handling.rst:427
msgid "Set Bullet Behavior"
msgstr ""

#: ../../proof-engine/proof-handling.rst:431
msgid ""
"This option controls the bullet behavior and can take two possible values:"
msgstr ""

#: ../../proof-engine/proof-handling.rst:433
msgid "\"None\": this makes bullets inactive."
msgstr ""

#: ../../proof-engine/proof-handling.rst:434
msgid ""
"\"Strict Subproofs\": this makes bullets active (this is the default "
"behavior)."
msgstr ""

#: ../../proof-engine/proof-handling.rst:439
msgid "Requesting information"
msgstr ""

#: ../../proof-engine/proof-handling.rst:444
msgid "This command displays the current goals."
msgstr ""

#: ../../proof-engine/proof-handling.rst:450
msgid "Displays only the :token:`num`\\-th subgoal."
msgstr ""

#: ../../proof-engine/proof-handling.rst:457
msgid ""
"Displays the named goal :token:`ident`. This is useful in particular to "
"display a shelved goal but only works if the corresponding existential "
"variable has been named by the user (see :ref:`existential-variables`) as in "
"the following example."
msgstr ""

#: ../../proof-engine/proof-handling.rst:473
msgid ""
"Displays the whole list of tactics applied from the beginning of the current "
"proof. This tactics script may contain some holes (subgoals not yet proved). "
"They are printed under the form"
msgstr ""

#: ../../proof-engine/proof-handling.rst:477
msgid "``<Your Tactic Text here>``."
msgstr ""

#: ../../proof-engine/proof-handling.rst:482
msgid ""
"It displays the proof term generated by the tactics that have been applied. "
"If the proof is not completed, this term contain holes, which correspond to "
"the sub-terms which are still to be constructed. These holes appear as a "
"question mark indexed by an integer, and applied to the list of variables in "
"the context, since it may depend on them. The types obtained by abstracting "
"away the context from the type of each placeholder are also printed."
msgstr ""

#: ../../proof-engine/proof-handling.rst:493
msgid ""
"It prints the list of the names of all the theorems that are currently being "
"proved. As it is possible to start proving a previous lemma during the proof "
"of a theorem, this list may contain several names."
msgstr ""

#: ../../proof-engine/proof-handling.rst:501
msgid ""
"If the current goal begins by at least one product, this command prints the "
"name of the first product, as it would be generated by an anonymous :tacn:"
"`intro`. The aim of this command is to ease the writing of more robust "
"scripts. For example, with an appropriate Proof General macro, it is "
"possible to transform any anonymous :tacn:`intro` into a qualified one such "
"as ``intro y13``. In the case of a non-product goal, it prints nothing."
msgstr ""

#: ../../proof-engine/proof-handling.rst:512
msgid ""
"This command is similar to the previous one, it simulates the naming process "
"of an :tacn:`intros`."
msgstr ""

#: ../../proof-engine/proof-handling.rst:518
msgid ""
"It displays the set of all uninstantiated existential variables in the "
"current proof tree, along with the type and the context of each variable."
msgstr ""

#: ../../proof-engine/proof-handling.rst:524
msgid ""
"This variant displays a template of the Gallina ``match`` construct with a "
"branch for each constructor of the type :token:`ident`"
msgstr ""

#: ../../proof-engine/proof-handling.rst:539
msgid ""
"It displays the set of all universe constraints and its normalized form at "
"the current stage of the proof, useful for debugging universe "
"inconsistencies."
msgstr ""

#: ../../proof-engine/proof-handling.rst:546
msgid ""
"Some tactics (e.g. :tacn:`refine`) allow to build proofs using fixpoint or "
"co-fixpoint constructions. Due to the incremental nature of interactive "
"proof construction, the check of the termination (or guardedness) of the "
"recursive calls in the fixpoint or cofixpoint constructions is postponed to "
"the time of the completion of the proof."
msgstr ""

#: ../../proof-engine/proof-handling.rst:552
msgid ""
"The command :cmd:`Guarded` allows checking if the guard condition for "
"fixpoint and cofixpoint is violated at some time of the construction of the "
"proof without having to wait the completion of the proof."
msgstr ""

#: ../../proof-engine/proof-handling.rst:558
msgid "Controlling the effect of proof editing commands"
msgstr ""

#: ../../proof-engine/proof-handling.rst:564
msgid ""
"This option controls the maximum number of hypotheses displayed in goals "
"after the application of a tactic. All the hypotheses remain usable in the "
"proof development. When unset, it goes back to the default mode which is to "
"print all available hypotheses."
msgstr ""

#: ../../proof-engine/proof-handling.rst:573
msgid ""
"This option controls the way binders are handled in assertion commands such "
"as :n:`Theorem @ident {? @binders} : @term`. When the option is on, which is "
"the default, binders are automatically put in the local context of the goal "
"to prove."
msgstr ""

#: ../../proof-engine/proof-handling.rst:578
msgid ""
"When the option is off, binders are discharged on the statement to be proved "
"and a tactic such as :tacn:`intro` (see Section :ref:"
"`managingthelocalcontext`) has to be used to move the assumptions to the "
"local context."
msgstr ""

#: ../../proof-engine/proof-handling.rst:584
msgid "Controlling memory usage"
msgstr ""

#: ../../proof-engine/proof-handling.rst:586
msgid ""
"When experiencing high memory usage the following commands can be used to "
"force |Coq| to optimize some of its internal data structures."
msgstr ""

#: ../../proof-engine/proof-handling.rst:592
msgid ""
"This command forces |Coq| to shrink the data structure used to represent the "
"ongoing proof."
msgstr ""

#: ../../proof-engine/proof-handling.rst:598
msgid ""
"This command forces the |OCaml| runtime to perform a heap compaction. This "
"is in general an expensive operation. See: `OCaml Gc <http://caml.inria.fr/"
"pub/docs/manual-ocaml/libref/Gc.html#VALcompact>`_ There is also an "
"analogous tactic :tacn:`optimize_heap`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5
msgid "The |SSR| proof language"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:0
msgid "Authors"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:7
msgid "Georges Gonthier, Assia Mahboubi, Enrico Tassi"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:11
msgid "Introduction"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:13
msgid ""
"This chapter describes a set of tactics known as |SSR| originally designed "
"to provide support for the so-called *small scale reflection* proof "
"methodology. Despite the original purpose this set of tactic is of general "
"interest and is available in |Coq| starting from version 8.7."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:18
msgid ""
"|SSR| was developed independently of the tactics described in Chapter :ref:"
"`tactics`. Indeed the scope of the tactics part of |SSR| largely overlaps "
"with the standard set of tactics. Eventually the overlap will be reduced in "
"future releases of |Coq|."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:23
msgid ""
"Proofs written in |SSR| typically look quite different from the ones written "
"using only tactics as per Chapter :ref:`tactics`. We try to summarise here "
"the most “visible” ones in order to help the reader already accustomed to "
"the tactics described in Chapter :ref:`tactics` to read this chapter."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:29
msgid ""
"The first difference between the tactics described in this chapter and the "
"tactics described in Chapter :ref:`tactics` is the way hypotheses are "
"managed (we call this *bookkeeping*). In Chapter :ref:`tactics` the most "
"common approach is to avoid moving explicitly hypotheses back and forth "
"between the context and the conclusion of the goal. On the contrary in |SSR| "
"all bookkeeping is performed on the conclusion of the goal, using for that "
"purpose a couple of syntactic constructions behaving similar to tacticals "
"(and often named as such in this chapter). The ``:`` tactical moves "
"hypotheses from the context to the conclusion, while ``=>`` moves hypotheses "
"from the conclusion to the context, and ``in`` moves back and forth a "
"hypothesis from the context to the conclusion for the time of applying an "
"action to it."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:41
msgid ""
"While naming hypotheses is commonly done by means of an ``as`` clause in the "
"basic model of Chapter :ref:`tactics`, it is here to ``=>`` that this task "
"is devoted. Tactics frequently leave new assumptions in the conclusion, and "
"are often followed by ``=>`` to explicitly name them. While generalizing the "
"goal is normally not explicitly needed in Chapter :ref:`tactics`, it is an "
"explicit operation performed by ``:``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:48
msgid ":ref:`bookkeeping_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:50
msgid ""
"Beside the difference of bookkeeping model, this chapter includes specific "
"tactics which have no explicit counterpart in Chapter :ref:`tactics` such as "
"tactics to mix forward steps and generalizations as :tacn:`generally have` "
"or :tacn:`without loss`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:55
msgid ""
"|SSR| adopts the point of view that rewriting, definition expansion and "
"partial evaluation participate all to a same concept of rewriting a goal in "
"a larger sense. As such, all these functionalities are provided by the :tacn:"
"`rewrite <rewrite (ssreflect)>` tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:60
msgid ""
"|SSR| includes a little language of patterns to select subterms in tactics "
"or tacticals where it matters. Its most notable application is in the :tacn:"
"`rewrite <rewrite (ssreflect)>` tactic, where patterns are used to specify "
"where the rewriting step has to take place."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:65
msgid ""
"Finally, |SSR| supports so-called reflection steps, typically allowing to "
"switch back and forth between the computational view and logical view of a "
"concept."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:69
msgid ""
"To conclude it is worth mentioning that |SSR| tactics can be mixed with non |"
"SSR| tactics in the same proof, or in the same Ltac expression. The few "
"exceptions to this statement are described in section :ref:"
"`compatibility_issues_ssr`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:76
msgid "Acknowledgments"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:78
msgid ""
"The authors would like to thank Frédéric Blanqui, François Pottier and "
"Laurence Rideau for their comments and suggestions."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:83
msgid "Usage"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:87
msgid "Getting started"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:89
msgid ""
"To be available, the tactics presented in this manual need the following "
"minimal set of libraries to be loaded: ``ssreflect.v``, ``ssrfun.v`` and "
"``ssrbool.v``. Moreover, these tactics come with a methodology specific to "
"the authors of |SSR| and which requires a few options to be set in a "
"different way than in their default way. All in all, this corresponds to "
"working in the following context:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:105
msgid ""
":flag:`Implicit Arguments`, :flag:`Strict Implicit`, :flag:`Printing "
"Implicit Defensive`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:112
msgid "Compatibility issues"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:114
msgid ""
"Requiring the above modules creates an environment which is mostly "
"compatible with the rest of |Coq|, up to a few discrepancies:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:118
msgid ""
"New keywords (``is``) might clash with variable, constant, tactic or "
"tactical names, or with quasi-keywords in tactic or vernacular notations."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:121
msgid ""
"New tactic(al)s names (:tacn:`last`, :tacn:`done`, :tacn:`have`, :tacn:"
"`suffices`, :tacn:`suff`, :tacn:`without loss`, :tacn:`wlog`, :tacn:"
"`congr`, :tacn:`unlock`) might clash with user tactic names."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:124
msgid ""
"Identifiers with both leading and trailing ``_``, such as ``_x_``, are "
"reserved by |SSR| and cannot appear in scripts."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:126
msgid ""
"The extensions to the :tacn:`rewrite` tactic are partly incompatible with "
"those available in current versions of |Coq|; in particular: ``rewrite .. in "
"(type of k)`` or ``rewrite .. in *`` or any other variant of :tacn:`rewrite` "
"will not work, and the |SSR| syntax and semantics for occurrence selection "
"and rule chaining is different. Use an explicit rewrite direction (``rewrite "
"<- …`` or ``rewrite -> …``) to access the |Coq| rewrite tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:132
msgid ""
"New symbols (``//``, ``/=``, ``//=``) might clash with adjacent existing "
"symbols. This can be avoided by inserting white spaces."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:135
msgid ""
"New constant and theorem names might clash with the user theory. This can be "
"avoided by not importing all of |SSR|:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:143
msgid ""
"Note that the full syntax of |SSR|’s rewrite and reserved identifiers are "
"enabled only if the ssreflect module has been required and if ``SsrSyntax`` "
"has been imported. Thus a file that requires (without importing) "
"``ssreflect`` and imports ``SsrSyntax``, can be required and imported "
"without automatically enabling |SSR|’s extended rewrite syntax and reserved "
"identifiers."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:150
msgid ""
"Some user notations (in particular, defining an infix ``;``) might interfere "
"with the \"open term\", parenthesis free, syntax of tactics such as have, "
"set and pose."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:153
msgid ""
"The generalization of if statements to non-Boolean conditions is turned off "
"by |SSR|, because it is mostly subsumed by Coercion to ``bool`` of the "
"``sumXXX`` types (declared in ``ssrfun.v``) and the :n:`if @term is @pattern "
"then @term else @term` construct (see :ref:`pattern_conditional_ssr`).  To "
"use the generalized form, turn off the |SSR| Boolean ``if`` notation using "
"the command: ``Close Scope boolean_if_scope``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:160
msgid ""
"The following two options can be unset to disable the incompatible rewrite "
"syntax and allow reserved identifiers to appear in scripts."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:170
msgid "|Gallina| extensions"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:172
msgid ""
"Small-scale reflection makes an extensive use of the programming subset of |"
"Gallina|, |Coq|’s logical specification language. This subset is quite "
"suited to the description of functions on representations, because it "
"closely follows the well-established design of the ML programming language. "
"The |SSR| extension provides three additions to |Gallina|, for pattern "
"assignment, pattern testing, and polymorphism; these mitigate minor but "
"annoying discrepancies between |Gallina| and ML."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:183
msgid "Pattern assignment"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:185
msgid ""
"The |SSR| extension provides the following construct for irrefutable pattern "
"matching, that is, destructuring assignment:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:191
msgid ""
"Note the colon ``:`` after the ``let`` keyword, which avoids any ambiguity "
"with a function definition or |Coq|’s basic destructuring let. The let: "
"construct differs from the latter in that"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:196
msgid ""
"The pattern can be nested (deep pattern matching), in particular, this "
"allows expression of the form:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:203
msgid ""
"The destructured constructor is explicitly given in the pattern, and is used "
"for type inference."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:220
msgid ""
"Using :g:`let:` Coq infers a type for :g:`f`, whereas with a usual ``let`` "
"the same term requires an extra type annotation in order to type check."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:229
msgid ""
"The ``let:`` construct is just (more legible) notation for the primitive |"
"Gallina| expression :n:`match @term with @pattern => @term end`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:232
msgid ""
"The |SSR| destructuring assignment supports all the dependent match "
"annotations; the full syntax is"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:238
msgid ""
"where the second :token:`pattern` and the second :token:`term` are *types*."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:240
msgid ""
"When the ``as`` and ``return`` keywords are both present, then :token:"
"`ident` is bound in both the second :token:`pattern` and the second :token:"
"`term`; variables in the optional type :token:`pattern` are bound only in "
"the second term, and other variables in the first  :token:`pattern` are "
"bound only in the third :token:`term`, however."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:250
msgid "Pattern conditional"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:252
msgid ""
"The following construct can be used for a refutable pattern matching, that "
"is, pattern testing:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:258
msgid ""
"Although this construct is not strictly ML (it does exist in variants such "
"as the pattern calculus or the ρ-calculus), it turns out to be very "
"convenient for writing functions on representations, because most such "
"functions manipulate simple data types such as Peano integers, options, "
"lists, or binary trees, and the pattern conditional above is almost always "
"the right construct for analyzing such simple types. For example, the null "
"and all list function(al)s can be defined as follows:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:285
msgid ""
"The pattern conditional also provides a notation for destructuring "
"assignment with a refutable pattern, adapted to the pure functional setting "
"of |Gallina|, which lacks a ``Match_Failure`` exception."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:289
msgid ""
"Like ``let:`` above, the ``if…is`` construct is just (more legible) notation "
"for the primitive |Gallina| expression :n:`match @term with @pattern => "
"@term | _ => @term end`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:293
msgid ""
"Similarly, it will always be displayed as the expansion of this form in "
"terms of primitive match expressions (where the default expression may be "
"replicated)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:297
msgid ""
"Explicit pattern testing also largely subsumes the generalization of the "
"``if`` construct to all binary data types; compare :n:`if @term is inl _ "
"then @term else @term` and :n:`if @term then @term else @term`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:302
msgid ""
"The latter appears to be marginally shorter, but it is quite ambiguous, and "
"indeed often requires an explicit annotation ``(term : {_} + {_})`` to type "
"check, which evens the character count."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:306
msgid ""
"Therefore, |SSR| restricts by default the condition of a plain if construct "
"to the standard ``bool`` type; this avoids spurious type annotations."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:316
msgid ""
"As pointed out in section :ref:`compatibility_issues_ssr`, this restriction "
"can be removed with the command:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:320
msgid "``Close Scope boolean_if_scope.``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:322
msgid ""
"Like ``let:`` above, the ``if-is-then-else`` construct supports the "
"dependent match annotations:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:329
msgid ""
"As in ``let:`` the variable :token:`ident` (and those in the type pattern) "
"are bound in the second :token:`term`; :token:`ident` is also bound in the "
"third :token:`term` (but not in the fourth :token:`term`), while the "
"variables in the first :token:`pattern` are bound only in the third :token:"
"`term`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:335
msgid "Another variant allows to treat the ``else`` case first:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:340
msgid ""
"Note that :token:`pattern` eventually binds variables in the third :token:"
"`term` and not in the second :token:`term`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:346
msgid "Parametric polymorphism"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:348
msgid ""
"Unlike ML, polymorphism in core |Gallina| is explicit: the type parameters "
"of polymorphic functions must be declared explicitly, and supplied at each "
"point of use. However, |Coq| provides two features to suppress redundant "
"parameters:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:354
msgid ""
"Sections are used to provide (possibly implicit) parameters for a set of "
"definitions."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:356
msgid ""
"Implicit arguments declarations are used to tell |Coq| to use type inference "
"to deduce some parameters from the context at each point of call."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:361
msgid ""
"The combination of these features provides a fairly good emulation of ML-"
"style polymorphism, but unfortunately this emulation breaks down for higher-"
"order programming. Implicit arguments are indeed not inferred at all points "
"of use, but only at points of call, leading to expressions such as"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:384
msgid ""
"Unfortunately, such higher-order expressions are quite frequent in "
"representation functions, especially those which use |Coq|'s ``Structures`` "
"to emulate Haskell typeclasses."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:388
msgid ""
"Therefore, |SSR| provides a variant of |Coq|’s implicit argument "
"declaration, which causes |Coq| to fill in some implicit parameters at each "
"point of use, e.g., the above definition can be written:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:411
msgid ""
"Better yet, it can be omitted entirely, since ``all_null s`` isn’t much of "
"an improvement over ``all null s``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:414
msgid "The syntax of the new declaration is"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:418
msgid ""
"Let us denote :math:`c_1` … :math:`c_n` the list of identifiers given to a "
"``Prenex Implicits`` command.  The command checks that each ci is the name "
"of a functional constant, whose implicit arguments are prenex, i.e., the "
"first :math:`n_i > 0` arguments of :math:`c_i` are implicit; then it assigns "
"``Maximal Implicit`` status to these arguments."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:424
msgid ""
"As these prenex implicit arguments are ubiquitous and have often large "
"display strings, it is strongly recommended to change the default display "
"settings of |Coq| so that they are not printed (except after a ``Set "
"Printing All`` command). All |SSR| library files thus start with the "
"incantation"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:438
msgid "Anonymous arguments"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:440
msgid ""
"When in a definition, the type of a certain argument is mandatory, but not "
"its name, one usually uses “arrow” abstractions for prenex arguments, or the "
"``(_ : term)`` syntax for inner arguments. In |SSR|, the latter can be "
"replaced by the open syntax ``of term`` or (equivalently) ``& term``, which "
"are both syntactically equivalent to a ``(_ : term)`` expression. This "
"feature almost behaves as the following extension of the binder syntax:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:451
msgid ""
"Caveat: ``& T`` and ``of T`` abbreviations have to appear at the end of a "
"binder list. For instance, the usual two-constructor polymorphic type list, "
"i.e. the one of the standard ``List`` library, can be defined by the "
"following declaration:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:471
msgid "Wildcards"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:473
msgid ""
"The terms passed as arguments to |SSR| tactics can contain *holes*, "
"materialized by wildcards ``_``. Since |SSR| allows a more powerful form of "
"type inference for these arguments, it enhances the possibilities of using "
"such wildcards. These holes are in particular used as a convenient shorthand "
"for abstractions, especially in local definitions or type expressions."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:480
msgid ""
"Wildcards may be interpreted as abstractions (see for example sections :ref:"
"`definitions_ssr` and ref:`structure_ssr`), or their content can be inferred "
"from the whole context of the goal (see for example section :ref:"
"`abbreviations_ssr`)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:489
msgid "Definitions"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:494
msgid ""
"This tactic allows to add a defined constant to a proof context. |SSR| "
"generalizes this tactic in several ways. In particular, the |SSR| pose "
"tactic supports *open syntax*: the body of the definition does not need "
"surrounding parentheses. For instance:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:503
msgid "is a valid tactic expression."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:505
msgid ""
"The pose tactic is also improved for the local definition of higher order "
"terms. Local definitions of functions can use the same syntax as global "
"ones. For example, the tactic :tacn:`pose <pose (ssreflect)>` supoprts "
"parameters:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:524
msgid ""
"The |SSR| pose tactic also supports (co)fixpoints, by providing the local "
"counterpart of the ``Fixpoint f := …`` and ``CoFixpoint f := …`` constructs. "
"For instance, the following tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:533
msgid ""
"defines a local fixpoint ``f``, which mimics the standard plus operation on "
"natural numbers."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:536
msgid "Similarly, local cofixpoints can be defined by a tactic of the form:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:542
msgid ""
"The possibility to include wildcards in the body of the definitions offers a "
"smooth way of defining local abstractions. The type of “holes” is guessed by "
"type inference, and the holes are abstracted. For instance the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:551
#: ../../proof-engine/ssreflect-proof-language.rst:564
msgid "is shorthand for:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:557
msgid ""
"When the local definition of a function involves both arguments and holes, "
"hole abstractions appear first. For instance, the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:570
msgid ""
"The interaction of the pose tactic with the interpretation of implicit "
"arguments results in a powerful and concise syntax for local definitions "
"involving dependent types. For instance, the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:578
msgid "adds to the context the local definition:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:584
msgid ""
"The generalization of wildcards makes the use of the pose tactic resemble ML-"
"like definitions of polymorphic functions."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:592
msgid "Abbreviations"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:594
msgid ""
"The |SSR| set tactic performs abbreviations: it introduces a defined "
"constant for a subterm appearing in the goal and/or in the context."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:598
msgid "|SSR| extends the set tactic by supplying:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:601
msgid "an open syntax, similarly to the pose tactic;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:602
msgid "a more aggressive matching algorithm;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:603
msgid ""
"an improved interpretation of wildcards, taking advantage of the matching "
"algorithm;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:605
msgid ""
"an improved occurrence selection mechanism allowing to abstract only "
"selected occurrences of a term."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:609
msgid "The general syntax of this tactic is"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:617
#: ../../proof-engine/ssreflect-proof-language.rst:4549
msgid "where:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:619
msgid ":token:`ident` is a fresh identifier chosen by the user."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:620
msgid ""
"term 1 is an optional type annotation. The type annotation term 1 can be "
"given in open syntax (no surrounding parentheses). If no :token:`occ_switch` "
"(described hereafter) is present, it is also the case for the second :token:"
"`term`. On the other hand, in presence of :token:`occ_switch`, parentheses "
"surrounding the second :token:`term` are mandatory."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:626
msgid ""
"In the occurrence switch :token:`occ_switch`, if the first element of the "
"list is a natural, this element should be a number, and not an Ltac "
"variable. The empty list ``{}`` is not interpreted as a valid occurrence "
"switch."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:631
msgid "The tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:657
msgid ""
"The type annotation may contain wildcards, which will be filled with the "
"appropriate value by the matching process."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:660
msgid ""
"The tactic first tries to find a subterm of the goal matching the second :"
"token:`term` (and its type), and stops at the first subterm it finds. Then "
"the occurrences of this subterm selected by the optional :token:`occ_switch` "
"are replaced by :token:`ident` and a definition :n:`@ident := @term` is "
"added to the context. If no :token:`occ_switch` is present, then all the "
"occurrences are abstracted."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:671
msgid "Matching"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:673
msgid ""
"The matching algorithm compares a pattern :token:`term` with a subterm of "
"the goal by comparing their heads and then pairwise unifying their arguments "
"(modulo conversion). Head symbols match under the following conditions:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:679
msgid ""
"If the head of :token:`term` is a constant, then it should be syntactically "
"equal to the head symbol of the subterm."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:681
msgid ""
"If this head is a projection of a canonical structure, then canonical "
"structure equations are used for the matching."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:683
msgid ""
"If the head of term is *not* a constant, the subterm should have the same "
"structure (λ abstraction,let…in structure …)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:685
msgid ""
"If the head of :token:`term` is a hole, the subterm should have at least as "
"many arguments as :token:`term`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:702
msgid ""
"In the special case where ``term`` is of the form ``(let f := t0 in f) t1 … "
"tn`` , then the pattern ``term`` is treated as ``(_ t1 … tn)``. For each "
"subterm in the goal having the form ``(A u1 … um)`` with m ≥ n, the matching "
"algorithm successively tries to find the largest partial application ``(A u1 "
"… uj)`` convertible to the head ``t0`` of ``term``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:723
msgid ""
"The notation ``unkeyed`` defined in ``ssreflect.v`` is a shorthand for the "
"degenerate term ``let x := … in x``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:726
msgid "Moreover:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:728
msgid "Multiple holes in ``term`` are treated as independent placeholders."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:744
msgid ""
"The type of the subterm matched should fit the type (possibly casted by some "
"type annotations) of the pattern ``term``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:746
msgid ""
"The replacement of the subterm found by the instantiated pattern should not "
"capture variables. In the example above ``x`` is bound and should not be "
"captured."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:764
msgid ""
"Typeclass inference should fill in any residual hole, but matching should "
"never assign a value to a global existential variable."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:771
msgid "Occurrence selection"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:773
msgid ""
"|SSR| provides a generic syntax for the selection of occurrences by their "
"position indexes. These *occurrence switches* are shared by all |SSR| "
"tactics which require control on subterm selection like rewriting, "
"generalization, …"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:778
msgid "An *occurrence switch* can be:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:780
msgid ""
"A list natural numbers ``{+ n1 … nm}`` of occurrences affected by the tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:798
msgid ""
"Notice that some occurrences of a given term may be hidden to the user, for "
"example because of a notation. The vernacular ``Set Printing All`` command "
"displays all these hidden occurrences and should be used to find the correct "
"coding of the occurrences to be selected [#1]_."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:819
msgid ""
"A list of natural numbers between ``{n1 … nm}``. This is equivalent to the "
"previous ``{+ n1 … nm}`` but the list should start with a number, and not "
"with an Ltac variable."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:822
msgid ""
"A list ``{- n1 … nm}`` of occurrences *not* to be affected by the tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:841
msgid "Note that, in this goal, it behaves like ``set x := {1 3}(f 2).``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:842
msgid ""
"In particular, the switch ``{+}`` selects *all* the occurrences. This switch "
"is useful to turn off the default behavior of a tactic which automatically "
"clears some assumptions (see section :ref:`discharge_ssr` for instance)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:846
msgid ""
"The switch ``{-}`` imposes that *no* occurrences of the term should be "
"affected by the tactic. The tactic: ``set x := {-}(f 2).`` leaves the goal "
"unchanged and adds the definition ``x := f 2`` to the context. This kind of "
"tactic may be used to take advantage of the power of the matching algorithm "
"in a local definition, instead of copying large terms by hand."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:853
msgid ""
"It is important to remember that matching *preceeds* occurrence selection."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:870
msgid ""
"Hence, in the following goal, the same tactic fails since there is only one "
"occurrence of the selected term."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:891
msgid "Basic localization"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:893
msgid ""
"It is possible to define an abbreviation for a term appearing in the context "
"of a goal thanks to the in tactical."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:896
#: ../../proof-engine/ssreflect-proof-language.rst:905
#: ../../proof-engine/ssreflect-proof-language.rst:2196
msgid "A tactic of the form:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:900
msgid ""
"introduces a defined constant called ``x`` in the context, and folds it in "
"the context entries mentioned on the right hand side of ``in``. The body of "
"``x`` is the first subterm matching these context entries (taken in the "
"given order)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:909
msgid ""
"matches term and then folds ``x`` similarly in all the given context entries "
"but also folds ``x`` in the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:926
msgid ""
"If the localization also mentions the goal, then the result is the following "
"one:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:935
msgid "Indeed, remember that 4 is just a notation for (S 3)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:937
msgid ""
"The use of the ``in`` tactical is not limited to the localization of "
"abbreviations: for a complete description of the in tactical, see section :"
"ref:`bookkeeping_ssr` and :ref:`localization_ssr`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:945
msgid "Basic tactics"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:947
msgid ""
"A sizable fraction of proof scripts consists of steps that do not \"prove\" "
"anything new, but instead perform menial bookkeeping tasks such as selecting "
"the names of constants and assumptions or splitting conjuncts. Although they "
"are logically trivial, bookkeeping steps are extremely important because "
"they define the structure of the data-flow of a proof script. This is "
"especially true for reflection-based proofs, which often involve large "
"numbers of constants and assumptions. Good bookkeeping consists in always "
"explicitly declaring (i.e., naming) all new constants and assumptions in the "
"script, and systematically pruning irrelevant constants and assumptions in "
"the context. This is essential in the context of an interactive development "
"environment (IDE), because it facilitates navigating the proof, allowing to "
"instantly \"jump back\" to the point at which a questionable assumption was "
"added, and to find relevant assumptions by browsing the pruned context. "
"While novice or casual |Coq| users may find the automatic name selection "
"feature convenient, the usage of such a feature severely undermines the "
"readability and maintainability of proof scripts, much like automatic "
"variable declaration in programming languages. The |SSR| tactics are "
"therefore designed to support precise bookkeeping and to eliminate name "
"generation heuristics. The bookkeeping features of |SSR| are implemented as "
"tacticals (or pseudo-tacticals), shared across most |SSR| tactics, and thus "
"form the foundation of the |SSR| proof language."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:975
msgid "Bookkeeping"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:977
msgid ""
"During the course of a proof |Coq| always present the user with a *sequent* "
"whose general form is::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:991
msgid ""
"The *goal* to be proved appears below the double line; above the line is the "
"*context* of the sequent, a set of declarations of *constants* ``ci`` , "
"*defined constants* d i , and *facts* ``Fk`` that can be used to prove the "
"goal (usually, ``Ti`` , ``Tj : Type`` and ``Pk : Prop``). The various kinds "
"of declarations can come in any order. The top part of the context consists "
"of declarations produced by the Section commands ``Variable``, ``Let``, and "
"``Hypothesis``. This *section context* is never affected by the |SSR| "
"tactics: they only operate on the lower part — the *proof context*. As in "
"the figure above, the goal often decomposes into a series of (universally) "
"quantified *variables* ``(xl : Tl)``, local *definitions* ``let ym := bm "
"in``, and *assumptions* ``P n ->``, and a *conclusion* ``C`` (as in the "
"context, variables, definitions, and assumptions can appear in any order). "
"The conclusion is what actually needs to be proved — the rest of the goal "
"can be seen as a part of the proof context that happens to be “below the "
"line”."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1011
msgid ""
"However, although they are logically equivalent, there are fundamental "
"differences between constants and facts on the one hand, and variables and "
"assumptions on the others. Constants and facts are *unordered*, but *named* "
"explicitly in the proof text; variables and assumptions are *ordered*, but "
"*unnamed*: the display names of variables may change at any time because of "
"α-conversion."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1018
msgid ""
"Similarly, basic deductive steps such as apply can only operate on the goal "
"because the |Gallina| terms that control their action (e.g., the type of the "
"lemma used by ``apply``) only provide unnamed bound variables. [#2]_ Since "
"the proof script can only refer directly to the context, it must constantly "
"shift declarations from the goal to the context and conversely in between "
"deductive steps."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1025
msgid ""
"In |SSR| these moves are performed by two *tacticals* ``=>`` and ``:``, so "
"that the bookkeeping required by a deductive step can be directly associated "
"to that step, and that tactics in an |SSR| script correspond to actual "
"logical steps in the proof rather than merely shuffle facts. Still, some "
"isolated bookkeeping is unavoidable, such as naming variables and "
"assumptions at the beginning of a proof. |SSR| provides a specific ``move`` "
"tactic for this purpose."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1033
msgid ""
"Now ``move`` does essentially nothing: it is mostly a placeholder for ``=>`` "
"and ``:``. The ``=>`` tactical moves variables, local definitions, and "
"assumptions to the context, while the ``:`` tactical moves facts and "
"constants to the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1040
msgid "For example, the proof of [#3]_"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1053
msgid "might start with"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1059
msgid ""
"where move does nothing, but ``=> m n le_m_n`` changes the variables and "
"assumption of the goal in the constants ``m n : nat`` and the fact "
"``le_n_m : n <=  m``, thus exposing the conclusion ``m - n + n = m``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1064
msgid ""
"The ``:`` tactical is the converse of ``=>``, indeed it removes facts and "
"constants from the context by turning them into variables and assumptions."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1072
msgid ""
"turns back ``m`` and ``le_m_n`` into a variable and an assumption, removing "
"them from the proof context, and changing the goal to ``forall m, n <= m -> "
"m - n + n = m`` which can be proved by induction on ``n`` using ``elim: n``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1077
msgid "Because they are tacticals, ``:`` and ``=>`` can be combined, as in"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1083
msgid ""
"simultaneously renames ``m`` and ``le_m_n`` into ``p`` and ``le_n_p``, "
"respectively, by first turning them into unnamed variables, then turning "
"these variables back into constants and facts."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1087
msgid ""
"Furthermore, |SSR| redefines the basic |Coq| tactics ``case``, ``elim``, and "
"``apply`` so that they can take better advantage of ``:`` and ``=>``. In "
"there |SSR| variants, these tactic operate on the first variable or constant "
"of the goal and they do not use or change the proof context. The ``:`` "
"tactical is used to operate on an element in the context."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1096
msgid ""
"For instance the proof of ``subnK`` could continue with ``elim: n``. Instead "
"of ``elim n`` (note, no colon), this has the advantage of removing n from "
"the context. Better yet, this ``elim`` can be combined with previous move "
"and with the branching version of the ``=>`` tactical (described in :ref:"
"`introduction_ssr`), to encapsulate the inductive step in a single command:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1117
msgid ""
"which breaks down the proof into two subgoals, the second one having in its "
"context ``lt_n_m : S n <= m`` and ``IHn : forall m, n <= m -> m - n + n = "
"m``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1122
msgid ""
"The ``:`` and ``=>`` tacticals can be explained very simply if one views the "
"goal as a stack of variables and assumptions piled on a conclusion:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1125
msgid ""
"``tactic : a b c`` pushes the context constants ``a``, ``b``, ``c`` as goal "
"variables *before* performing tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1127
msgid ""
"``tactic => a b c`` pops the top three goal variables as context constants "
"``a``, ``b``, ``c``, *after* tactic has been performed."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1130
msgid ""
"These pushes and pops do not need to balance out as in the examples above, "
"so ``move: m le_n_m => p`` would rename ``m`` into ``p``, but leave an extra "
"assumption ``n <= p`` in the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1135
msgid ""
"Basic tactics like apply and elim can also be used without the ’:’ tactical: "
"for example we can directly start a proof of ``subnK`` by induction on the "
"top variable ``m`` with"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1143
msgid ""
"The general form of the localization tactical in is also best explained in "
"terms of the goal stack::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1148
msgid "is basically equivalent to"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1155
msgid ""
"with two differences: the in tactical will preserve the body of a ifa is a "
"defined constant, and if the ``*`` is omitted it will use a temporary "
"abbreviation to hide the statement of the goal from ``tactic``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1160
msgid ""
"The general form of the in tactical can be used directly with the ``move``, "
"``case`` and ``elim`` tactics, so that one can write"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1167
msgid "instead of"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1173
msgid "This is quite useful for inductive proofs that involve many facts."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1175
msgid ""
"See section :ref:`localization_ssr` for the general syntax and presentation "
"of the in tactical."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1183
msgid "The defective tactics"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1185
msgid ""
"In this section we briefly present the three basic tactics performing "
"context manipulations and the main backward chaining tool."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1190
msgid "The move tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1192
msgid ""
"The move tactic, in its defective form, behaves like the primitive ``hnf`` |"
"Coq| tactic. For example, such a defective:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1198
msgid ""
"exposes the first assumption in the goal, i.e. its changes the goal ``not "
"False`` into ``False -> False``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1201
msgid ""
"More precisely, the ``move`` tactic inspects the goal and does nothing "
"(``idtac``) if an introduction step is possible, i.e. if the goal is a "
"product or a ``let…in``, and performs ``hnf`` otherwise."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1205
msgid ""
"Of course this tactic is most often used in combination with the bookkeeping "
"tacticals (see section :ref:`introduction_ssr` and :ref:`discharge_ssr`). "
"These combinations mostly subsume the :tacn:`intros`, :tacn:`generalize`, :"
"tacn:`revert`, :tacn:`rename`, :tacn:`clear` and :tacn:`pattern` tactics."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1212
msgid "The case tactic"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1214
msgid ""
"The ``case`` tactic performs *primitive case analysis* on (co)inductive "
"types; specifically, it destructs the top variable or assumption of the "
"goal, exposing its constructor(s) and its arguments, as well as setting the "
"value of its type family indices if it belongs to a type family (see "
"section :ref:`type_families_ssr`)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1220
msgid ""
"The |SSR| case tactic has a special behavior on equalities. If the top "
"assumption of the goal is an equality, the case tactic “destructs” it as a "
"set of equalities between the constructor arguments of its left and right "
"hand sides, as per the tactic injection. For example, ``case`` changes the "
"goal::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1228
msgid "into::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1232
msgid ""
"Note also that the case of |SSR| performs ``False`` elimination, even if no "
"branch is generated by this case operation. Hence the command: ``case.`` on "
"a goal of the form ``False -> G`` will succeed and prove the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1239
msgid "The elim tactic"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1241
msgid ""
"The ``elim`` tactic performs inductive elimination on inductive types. The "
"defective:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1247
msgid ""
"tactic performs inductive elimination on a goal whose top assumption has an "
"inductive type."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1268
msgid "The apply tactic"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1270
msgid ""
"The ``apply`` tactic is the main backward chaining tactic of the proof "
"system. It takes as argument any :token:`term` and applies it to the goal. "
"Assumptions in the type of :token:`term` that don’t directly match the goal "
"may generate one or more subgoals."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1275
msgid "In fact the |SSR| tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1280
msgid "is a synonym for::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1284
msgid ""
"where ``top`` is a fresh name, and the sequence of refine tactics tries to "
"catch the appropriate number of wildcards to be inserted. Note that this use "
"of the refine tactic implies that the tactic tries to match the goal up to "
"expansion of constants and evaluation of subterms."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1289
msgid ""
"|SSR|’s apply has a special behavior on goals containing existential "
"metavariables of sort Prop."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1309
msgid ""
"Note that the last ``_`` of the tactic ``apply: (ex_intro _ (exist _ y _))`` "
"represents a proof that ``y < 3``. Instead of generating the goal::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1315
msgid ""
"the system tries to prove ``y < 3`` calling the trivial tactic. If it "
"succeeds, let’s say because the context contains ``H : y < 3``, then the "
"system generates the following goal::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1322
msgid ""
"Otherwise the missing proof is considered to be irrelevant, and is thus "
"discharged generating the two goals shown above."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1325
msgid ""
"Last, the user can replace the trivial tactic by defining an Ltac expression "
"named ``ssrautoprop``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1332
msgid "Discharge"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1334
msgid "The general syntax of the discharging tactical ``:`` is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1344
msgid "with the following requirements:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1346
msgid ""
":token:`tactic` must be one of the four basic tactics described in :ref:"
"`the_defective_tactics_ssr`, i.e., ``move``, ``case``, ``elim`` or "
"``apply``, the ``exact`` tactic (section :ref:`terminators_ssr`), the "
"``congr`` tactic (section :ref:`congruence_ssr`), or the application of the "
"*view* tactical ‘/’ (section :ref:`interpreting_assumptions_ssr`) to one of "
"move, case, or elim."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1352
msgid ""
"The optional :token:`ident` specifies *equation generation* (section :ref:"
"`generation_of_equations_ssr`), and is only allowed if tactic is ``move``, "
"``case`` or ``elim``, or the application of the view tactical ‘/’ (section :"
"ref:`interpreting_assumptions_ssr`) to ``case`` or ``elim``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1355
msgid ""
"An :token:`occ_switch` selects occurrences of :token:`term`, as in :ref:"
"`abbreviations_ssr`; :token:`occ_switch` is not allowed if :token:`tactic` "
"is ``apply`` or ``exact``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1357
msgid ""
"A clear item :token:`clear_switch` specifies facts and constants to be "
"deleted from the proof context (as per the clear tactic)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1361
msgid ""
"The ``:`` tactical first *discharges* all the :token:`d_item`, right to "
"left, and then performs tactic, i.e., for each :token:`d_item`, starting "
"with the last one :"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1365
msgid ""
"The |SSR| matching algorithm described in section :ref:`abbreviations_ssr` "
"is used to find occurrences of term in the goal, after filling any holes ‘_’ "
"in term; however if tactic is apply or exact a different matching algorithm, "
"described below, is used [#4]_."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1369
msgid ""
"These occurrences are replaced by a new variable; in particular, if term is "
"a fact, this adds an assumption to the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1371
msgid ""
"If term is *exactly* the name of a constant or fact in the proof context, it "
"is deleted from the context, unless there is an :token:`occ_switch`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1376
msgid ""
"Finally, tactic is performed just after the first :token:`d_item` has been "
"generalized — that is, between steps 2 and 3. The names listed in the final :"
"token:`clear_switch` (if it is present) are cleared first, before :token:"
"`d_item` n is discharged."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1382
msgid "Switches affect the discharging of a :token:`d_item` as follows:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1385
msgid ""
"An :token:`occ_switch` restricts generalization (step 2) to a specific "
"subset of the occurrences of term, as per section :ref:`abbreviations_ssr`, "
"and prevents clearing (step 3)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1388
msgid ""
"All the names specified by a :token:`clear_switch` are deleted from the "
"context in step 3, possibly in addition to term."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1392
msgid "For example, the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1398
msgid "first generalizes ``(refl_equal n : n = n)``;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1399
msgid "then generalizes the second occurrence of ``n``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1400
msgid ""
"finally generalizes all the other occurrences of ``n``, and clears ``n`` "
"from the proof context (assuming n is a proof constant)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1403
msgid "Therefore this tactic changes any goal ``G`` into"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1409
msgid ""
"where the name ``n0`` is picked by the |Coq| display function, and assuming "
"``n`` appeared only in ``G``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1412
msgid ""
"Finally, note that a discharge operation generalizes defined constants as "
"variables, and not as local definitions. To override this behavior, prefix "
"the name of the local definition with a ``@``, like in ``move: @n``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1416
msgid ""
"This is in contrast with the behavior of the in tactical (see section :ref:"
"`localization_ssr`), which preserves local definitions by default."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1422
msgid "Clear rules"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1424
msgid ""
"The clear step will fail if term is a proof constant that appears in other "
"facts; in that case either the facts should be cleared explicitly with a :"
"token:`clear_switch`, or the clear step should be disabled. The latter can "
"be done by adding an :token:`occ_switch` or simply by putting parentheses "
"around term: both ``move: (n).`` and ``move: {+}n.`` generalize ``n`` "
"without clearing ``n`` from the proof context."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1434
msgid ""
"The clear step will also fail if the :token:`clear_switch` contains a :token:"
"`ident` that is not in the *proof* context. Note that |SSR| never clears a "
"section constant."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1438
msgid ""
"If tactic is ``move`` or ``case`` and an equation :token:`ident` is given, "
"then clear (step 3) for :token:`d_item` is suppressed (see section :ref:"
"`generation_of_equations_ssr`)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1443
msgid "Matching for apply and exact"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1445
msgid ""
"The matching algorithm for :token:`d_item` of the |SSR| ``apply`` and "
"``exact`` tactics exploits the type of the first :token:`d_item` to "
"interpret wildcards in the other :token:`d_item` and to determine which "
"occurrences of these should be generalized. Therefore, occur switches are "
"not needed for apply and exact."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1453
msgid ""
"Indeed, the |SSR| tactic ``apply: H x`` is equivalent to ``refine (@H _ … _ "
"x); clear H x`` with an appropriate number of wildcards between ``H`` and "
"``x``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1457
msgid ""
"Note that this means that matching for ``apply`` and ``exact`` has much more "
"context to interpret wildcards; in particular it can accommodate the ``_`` :"
"token:`d_item`, which would always be rejected after ``move:``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1477
msgid ""
"This tactic is equivalent (see section :ref:`bookkeeping_ssr`) to: ``refine "
"(trans_equal (Hfg _) _).`` and this is a common idiom for applying "
"transitivity on the left hand side of an equation."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1487
msgid "The abstract tactic"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1492
msgid ""
"This tactic assigns an abstract constant previously introduced with the ``[: "
"name ]`` intro pattern (see section :ref:`introduction_ssr`)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1495
msgid "In a goal like the following::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1503
msgid ""
"The tactic ``abstract: abs n`` first generalizes the goal with respect ton "
"(that is not visible to the abstract constant abs) and then assigns abs. The "
"resulting goal is::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1512
msgid ""
"Once this subgoal is closed, all other goals having abs in their context see "
"the type assigned to ``abs``. In this case::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1520
msgid ""
"For a more detailed example the reader should refer to section :ref:"
"`structure_ssr`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1527
msgid "Introduction in the context"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1529
msgid ""
"The application of a tactic to a given goal can generate (quantified) "
"variables, assumptions, or definitions, which the user may want to "
"*introduce* as new facts, constants or defined constants, respectively. If "
"the tactic splits the goal into several subgoals, each of them may require "
"the introduction of different constants and facts. Furthermore it is very "
"common to immediately decompose or rewrite with an assumption instead of "
"adding it to the context, as the goal can often be simplified and even "
"proved after this."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1538
msgid ""
"All these operations are performed by the introduction tactical ``=>``, "
"whose general syntax is"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1553
msgid ""
"The ``=>`` tactical first executes tactic, then the :token:`i_item` s, left "
"to right. An :token:`s_item` specifies a simplification operation; a :token:"
"`clear_switch` h specifies context pruning as in :ref:`discharge_ssr`. The :"
"token:`i_pattern` s can be seen as a variant of *intro patterns* :ref:"
"`tactics`: each performs an introduction operation, i.e., pops some "
"variables or assumptions from the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1561
msgid ""
"An :token:`s_item` can simplify the set of subgoals or the subgoals "
"themselves:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1563
msgid ""
"``//`` removes all the “trivial” subgoals that can be resolved by the |SSR| "
"tactic :tacn:`done` described in :ref:`terminators_ssr`, i.e., it executes "
"``try done``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1566
msgid ""
"``/=`` simplifies the goal by performing partial evaluation, as per the "
"tactic ``simpl`` [#5]_."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1568
msgid ""
"``//=`` combines both kinds of simplification; it is equivalent to ``/= //"
"``, i.e., ``simpl; try done``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1572
msgid ""
"When an :token:`s_item` bears a :token:`clear_switch`, then the :token:"
"`clear_switch` is executed *after* the :token:`s_item`, e.g., ``{IHn}//`` "
"will solve some subgoals, possibly using the fact ``IHn``, and will erase "
"``IHn`` from the context of the remaining subgoals."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1578
msgid ""
"The last entry in the :token:`i_item` grammar rule, ``/``:token:`term`, "
"represents a view (see section :ref:`views_and_reflection_ssr`). If the "
"next :token:`i_item` is a view, then the view is applied to the assumption "
"in top position once all the previous :token:`i_item` have been performed."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1584
msgid "The view is applied to the top assumption."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1586
msgid "|SSR| supports the following :token:`i_pattern` s:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1591
msgid ":token:`ident`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1589
msgid ""
"pops the top variable, assumption, or local definition into a new constant, "
"fact, or defined constant :token:`ident`, respectively. Note that defined "
"constants cannot be introduced when δ-expansion is required to expose the "
"top variable or assumption."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1595
msgid "``?``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1594
msgid ""
"pops the top variable into an anonymous constant or fact, whose name is "
"picked by the tactic interpreter. |SSR| only generates names that cannot "
"appear later in the user script [#6]_."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1602
msgid "``_``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1598
msgid ""
"pops the top variable into an anonymous constant that will be deleted from "
"the proof context of all the subgoals produced by the ``=>`` tactical. They "
"should thus never be displayed, except in an error message if the constant "
"is still actually used in the goal or context after the last :token:`i_item` "
"has been executed (:token:`s_item` can erase goals or terms where the "
"constant appears)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1613
msgid "``*``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1605
msgid ""
"pops all the remaining apparent variables/assumptions as anonymous constants/"
"facts. Unlike ``?`` and ``move`` the ``*`` :token:`i_item` does not expand "
"definitions in the goal to expose quantifiers, so it may be useful to repeat "
"a ``move=> *`` tactic, e.g., on the goal::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1613
msgid ""
"a first ``move=> *`` adds only ``_a_ : bool`` and ``_b_ : bool`` to the "
"context; it takes a second ``move=> *`` to add ``_Hyp_ : _a_ = _b_``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1620
msgid ":token:`occ_switch` ``->``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1616
msgid ""
"(resp. :token:`occ_switch` ``<-``) pops the top assumption (which should be "
"a rewritable proposition) into an anonymous fact, rewrites (resp. rewrites "
"right to left) the goal with this fact (using the |SSR| ``rewrite`` tactic "
"described in section :ref:`rewriting_ssr`, and honoring the optional "
"occurrence selector), and finally deletes the anonymous fact from the "
"context."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1631
#: ../../proof-engine/ssreflect-proof-language.rst:1645
msgid "``[`` :token:`i_item` * ``| … |`` :token:`i_item` * ``]``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1623
msgid ""
"when it is the very *first* :token:`i_pattern` after tactic ``=>`` tactical "
"*and* tactic is not a move, is a *branching*:token:`i_pattern`. It executes "
"the sequence :token:`i_item`:math:`_i` on the i-th   subgoal produced by "
"tactic. The execution of tactic should thus generate exactly m subgoals, "
"unless the ``[…]`` :token:`i_pattern` comes after an initial ``//`` or ``//"
"=`` :token:`s_item` that closes some of the goals produced by ``tactic``, in "
"which case exactly m subgoals should remain after thes- item, or we have the "
"trivial branching :token:`i_pattern` [], which always does nothing, "
"regardless of the number of remaining subgoals."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1634
msgid ""
"when it is *not* the first :token:`i_pattern` or when tactic is a ``move``, "
"is a *destructing* :token:`i_pattern`. It starts by destructing the top "
"variable, using the |SSR| ``case`` tactic described in :ref:"
"`the_defective_tactics_ssr`. It then behaves as the corresponding branching :"
"token:`i_pattern`, executing the sequence:token:`i_item`:math:`_i`  in the i-"
"th subgoal generated by the case analysis; unless we have the trivial "
"destructing :token:`i_pattern` ``[]``, the latter should generate exactly m "
"subgoals, i.e., the top variable should have an inductive type with exactly "
"m constructors [#7]_. While it is good style to use the :token:`i_item` i * "
"to pop the variables and assumptions corresponding to each constructor, this "
"is not enforced by |SSR|."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1654
msgid "``-``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1648
msgid ""
"does nothing, but counts as an intro pattern. It can also be used to force "
"the interpretation of ``[`` :token:`i_item` * ``| … |`` :token:`i_item` * "
"``]`` as a case analysis like in ``move=> -[H1 H2]``. It can also be used to "
"indicate explicitly the link between a view and a name like in ``move=> /eqP-"
"H1``.  Last, it can serve as a separator between views.  Section :ref:"
"`views_and_reflection_ssr` [#9]_ explains in which respect the tactic "
"``move=> /v1/v2`` differs from the tactic ``move=> /v1-/v2``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1660
msgid "``[:`` :token:`ident` ``…]``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1657
msgid ""
"introduces in the context an abstract constant for each :token:`ident`.  Its "
"type has to be fixed later on by using the ``abstract`` tactic.  Before then "
"the type displayed is ``<hidden>``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1662
msgid ""
"Note that |SSR| does not support the syntax ``(ipat, …, ipat)`` for "
"destructing intro-patterns."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1665
msgid "Clears are deferred until the end of the intro pattern."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1681
msgid ""
"If the cleared names are reused in the same intro pattern, a renaming is "
"performed behind the scenes."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1684
msgid ""
"Facts mentioned in a clear switch must be valid names in the proof context "
"(excluding the section context)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1687
msgid ""
"The rules for interpreting branching and destructing :token:`i_pattern` are "
"motivated by the fact that it would be pointless to have a branching pattern "
"if tactic is a ``move``, and in most of the remaining cases tactic is "
"``case`` or ``elim``, which implies destruction. The rules above imply that:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1693
msgid "``move=> [a b].``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1694
msgid "``case=> [a b].``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1695
msgid "``case=> a b.``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1697
msgid ""
"are all equivalent, so which one to use is a matter of style; ``move`` "
"should be used for casual decomposition, such as splitting a pair, and "
"``case`` should be used for actual decompositions, in particular for type "
"families (see :ref:`type_families_ssr`) and proof by contradiction."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1702
msgid ""
"The trivial branching :token:`i_pattern` can be used to force the branching "
"interpretation, e.g.:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1705
msgid "``case=> [] [a b] c.``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1706
msgid "``move=> [[a b] c].``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1707
msgid "``case; case=> a b c.``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1709
msgid "are all equivalent."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1715
msgid "Generation of equations"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1717
msgid ""
"The generation of named equations option stores the definition of a new "
"constant as an equation. The tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1724
msgid ""
"where ``l`` is a list, replaces ``size l`` by ``n`` in the goal and adds the "
"fact ``En : size l = n`` to the context. This is quite different from:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1732
msgid ""
"which generates a definition ``n := (size l)``. It is not possible to "
"generalize or rewrite such a definition; on the other hand, it is "
"automatically expanded during computation, whereas expanding the equation "
"``En`` requires explicit rewriting."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1737
msgid ""
"The use of this equation name generation option with a ``case`` or an "
"``elim`` tactic changes the status of the first :token:`i_item`, in order to "
"deal with the possible parameters of the constants introduced."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1755
msgid ""
"If the user does not provide a branching :token:`i_item` as first :token:"
"`i_item`, or if the :token:`i_item` does not provide enough names for the "
"arguments of a constructor, then the constants generated are introduced "
"under fresh |SSR| names."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1775
msgid ""
"Combining the generation of named equations mechanism with thecase tactic "
"strengthens the power of a case analysis. On the other hand, when combined "
"with the elim tactic, this feature is mostly useful for debug purposes, to "
"trace the values of decomposed parameters and pinpoint failing branches."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1785
msgid "Type families"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1787
msgid ""
"When the top assumption of a goal has an inductive type, two specific "
"operations are possible: the case analysis performed by the ``case`` tactic, "
"and the application of an induction principle, performed by the ``elim`` "
"tactic. When this top assumption has an inductive type, which is moreover an "
"instance of a type family, |Coq| may need help from the user to specify "
"which occurrences of the parameters of the type should be substituted."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1795
msgid ""
"A specific ``/`` switch indicates the type family parameters of the type of "
"a :token:`d_item` immediately following this ``/`` switch, using the syntax:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1804
msgid ""
"The :token:`d_item` on the right side of the ``/`` switch are discharged as "
"described in section :ref:`discharge_ssr`. The case analysis or elimination "
"will be done on the type of the top assumption after these discharge "
"operations."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1809
msgid ""
"Every :token:`d_item` preceding the ``/`` is interpreted as arguments of "
"this type, which should be an instance of an inductive type family. These "
"terms are not actually generalized, but rather selected for substitution. "
"Occurrence switches can be used to restrict the substitution. If a term is "
"left completely implicit (e.g. writing just ``_``), then a pattern is "
"inferred looking at the type of the top assumption. This allows for the "
"compact syntax:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1821
msgid ""
"where ``_`` is interpreted as ``(_ == _)`` since ``eqP T a b : reflect (a = "
"b) (a == b)`` and reflect is a type family with one index."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1825
msgid ""
"Moreover if the :token:`d_item` list is too short, it is padded with an "
"initial sequence of ``_`` of the right length."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1830
#: ../../proof-engine/ssreflect-proof-language.rst:2157
msgid ""
"Here is a small example on lists. We define first a function which adds an "
"element at the end of a given list."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1851
msgid ""
"Then we define an inductive predicate for case analysis on lists according "
"to their last element:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1863
msgid "We are now ready to use ``lastP`` in conjunction with ``case``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1870
msgid ""
"Applied to the same goal, the command: ``case: l / (lastP l).`` generates "
"the same subgoals but ``l`` has been cleared from both contexts."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1874
msgid "Again applied to the same goal, the command."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1885
msgid ""
"Note that selected occurrences on the left of the ``/`` switch have been "
"substituted with l instead of being affected by the case analysis."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1889
msgid ""
"The equation name generation feature combined with a type family / switch "
"generates an equation for the *first* dependent :token:`d_item` specified by "
"the user. Again starting with the above goal, the command:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1907
msgid ""
"There must be at least one :token:`d_item` to the left of the / switch; this "
"prevents any confusion with the view feature. However, the :token:`d_item` "
"to the right of the ``/`` are optional, and if they are omitted the first "
"assumption provides the instance of the type family."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1912
msgid ""
"The equation always refers to the first :token:`d_item` in the actual tactic "
"call, before any padding with initial ``_``. Thus, if an inductive type has "
"two family parameters, it is possible to have|SSR| generate an equation for "
"the second one by omitting the pattern for the first; note however that this "
"will fail if the type of the second parameter depends on the value of the "
"first parameter."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1921
msgid "Control flow"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1927
msgid "Indentation and bullets"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1929
msgid ""
"A linear development of |Coq| scripts gives little information on the "
"structure of the proof. In addition, replaying a proof after some changes in "
"the statement to be proved will usually not display information to "
"distinguish between the various branches of case analysis for instance."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1935
msgid ""
"To help the user in this organization of the proof script at development "
"time, |SSR| provides some bullets to highlight the structure of branching "
"proofs. The available bullets are ``-``, ``+`` and ``*``.  Combined with "
"tabulation, this lets us highlight four nested levels of branching; the most "
"we have ever needed is three. Indeed, the use of “simpl and closing” "
"switches, of terminators (see above section :ref:`terminators_ssr`) and "
"selectors (see section :ref:`selectors_ssr`) is powerful enough to avoid "
"most of the time more than two levels of indentation."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1944
msgid "Here is a fragment of such a structured script::"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1967
msgid "Terminators"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1969
msgid ""
"To further structure scripts, |SSR| supplies *terminating* tacticals to "
"explicitly close off tactics. When replaying scripts, we then have the nice "
"property that an error immediately occurs when a closed tactic fails to "
"prove its subgoal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1974
msgid ""
"It is hence recommended practice that the proof of any subgoal should end "
"with a tactic which *fails if it does not solve the current goal*, like "
"discriminate, contradiction or assumption."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1978
msgid ""
"In fact, |SSR| provides a generic tactical which turns any tactic into a "
"closing one (similar to now). Its general syntax is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1984
msgid ""
"The Ltac expression :n:`by [@tactic | [@tactic | …]` is equivalent to :n:"
"`[by @tactic | by @tactic | ...]` and this form should be preferred to the "
"former."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1988
msgid ""
"In the script provided as example in section :ref:`indentation_ssr`, the "
"paragraph corresponding to each sub-case ends with a tactic line prefixed "
"with a ``by``, like in:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:1999
msgid ""
"The :tacn:`by` tactical is implemented using the user-defined, and "
"extensible :tacn:`done` tactic. This :tacn:`done` tactic tries to solve the "
"current goal by some trivial means and fails if it doesn’t succeed. Indeed, "
"the tactic expression :n:`by @tactic` is equivalent to :n:`@tactic; done`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2004
msgid "Conversely, the tactic"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2010
#: ../../proof-engine/ssreflect-proof-language.rst:2041
#: ../../proof-engine/ssreflect-proof-language.rst:2055
msgid "is equivalent to:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2016
msgid ""
"The default implementation of the done tactic, in the ``ssreflect.v`` file, "
"is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2028
msgid ""
"The lemma ``not_locked_false_eq_true`` is needed to discriminate *locked* "
"boolean predicates (see section :ref:`locking_ssr`). The iterator tactical "
"do is presented in section :ref:`iteration_ssr`. This tactic can be "
"customized by the user, for instance to include an ``auto`` tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2033
msgid ""
"A natural and common way of closing a goal is to apply a lemma which is the "
"exact one needed for the goal to be solved. The defective form of the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2047
msgid ""
"where ``top`` is a fresh name assigned to the top assumption of the goal. "
"This applied form is supported by the : discharge tactical, and the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2061
msgid ""
"(see section :ref:`discharge_ssr` for the documentation of the apply: "
"combination)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2065
msgid ""
"The list of tactics (possibly chained by semicolons) that follows the ``by`` "
"keyword is considered to be a parenthesized block applied to the current "
"goal. Hence for example if the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2073
msgid "succeeds, then the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2079
msgid "usually fails since it is equivalent to:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2089
msgid "Selectors"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2091
msgid ""
"When composing tactics, the two tacticals ``first`` and ``last`` let the "
"user restrict the application of a tactic to only one of the subgoals "
"generated by the previous tactic. This covers the frequent cases where a "
"tactic generates two subgoals one of which can be easily disposed of."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2097
msgid ""
"This is another powerful way of linearization of scripts, since it happens "
"very often that a trivial subgoal can be solved in a less than one line "
"tactic. For instance, the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2104
msgid ""
"tries to solve the last subgoal generated by the first tactic using the "
"given second tactic, and fails if it does not succeed. Its analogue"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2111
msgid ""
"tries to solve the first subgoal generated by the first tactic using the "
"second given tactic, and fails if it does not succeed."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2114
msgid ""
"|SSR| also offers an extension of this facility, by supplying tactics to "
"*permute* the subgoals generated by a tactic. The tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2119
msgid ""
"inverts the order of the subgoals generated by tactic. It is equivalent to:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2124
msgid "More generally, the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2129
msgid ""
"where :token:`num` is a |Coq| numeral, or an Ltac variable denoting a |Coq| "
"numeral, having the value k. It rotates the n subgoals G1 , …, Gn generated "
"by tactic. The first subgoal becomes Gn + 1 − k and the circular order of "
"subgoals remains unchanged."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2135
msgid "Conversely, the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2140
msgid ""
"rotates the n subgoals G1 , …, Gn generated by tactic in order that the "
"first subgoal becomes Gk ."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2143
msgid ""
"Finally, the tactics ``last`` and ``first`` combine with the branching "
"syntax of Ltac: if the tactic generates n subgoals on a given goal, then the "
"tactic"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2151
msgid ""
"where natural denotes the integer k as above, applies tactic1 to the n −k + "
"1-th goal, … tacticm to the n −k + 2 − m-th goal and tactic n to the others."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2183
msgid "Iteration"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2185
msgid ""
"|SSR| offers an accurate control on the repetition of tactics, thanks to the "
"do tactical, whose general syntax is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2191
msgid "where :token:`mult` is a *multiplier*."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2193
msgid ""
"Brackets can only be omitted if a single tactic is given *and* a multiplier "
"is present."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2202
msgid "is equivalent to the standard Ltac expression:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2208
msgid ""
"The optional multiplier :token:`mult` specifies how many times the action of "
"tactic should be repeated on the current subgoal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2211
msgid "There are four kinds of multipliers:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2216
msgid "Their meaning is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2218
msgid ""
"``n!`` the step tactic is repeated exactly n times (where n is a positive "
"integer argument)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2220
msgid ""
"``!`` the step tactic is repeated as many times as possible, and done at "
"least once."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2222
msgid ""
"``?`` the step tactic is repeated as many times as possible, optionally."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2224
msgid "``n?`` the step tactic is repeated up to n times, optionally."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2227
msgid "For instance, the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2233
msgid ""
"rewrites at most one time the lemma ``mult_comm`` in all the subgoals "
"generated by tactic , whereas the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2240
msgid ""
"rewrites exactly two times the lemma ``mult_comm`` in all the subgoals "
"generated by tactic, and fails if this rewrite is not possible in some "
"subgoal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2244
msgid ""
"Note that the combination of multipliers and rewrite is so often used that "
"multipliers are in fact integrated to the syntax of the |SSR| rewrite "
"tactic, see section :ref:`rewriting_ssr`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2252
msgid "Localization"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2254
msgid ""
"In sections :ref:`basic_localization_ssr` and :ref:`bookkeeping_ssr`, we "
"have already presented the *localization* tactical in, whose general syntax "
"is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2260
msgid ""
"where :token:`ident` is a name in the context. On the left side of ``in``, :"
"token:`tactic` can be ``move``, ``case``, ``elim``, ``rewrite``, ``set``, or "
"any tactic formed with the general iteration tactical ``do`` (see section :"
"ref:`iteration_ssr`)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2266
msgid ""
"The operation described by tactic is performed in the facts listed after "
"``in`` and in the goal if a ``*`` ends the list of names."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2269
msgid "The ``in`` tactical successively:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2271
msgid ""
"generalizes the selected hypotheses, possibly “protecting” the goal if ``*`` "
"is not present,"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2273
msgid "performs :token:`tactic`, on the obtained goal,"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2274
msgid "reintroduces the generalized facts, under the same names."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2276
msgid ""
"This defective form of the ``do`` tactical is useful to avoid clashes "
"between standard Ltac in and the |SSR| tactical in."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2295
msgid ""
"the last tactic rewrites the hypothesis ``H2 : y = 3`` both in ``H1 : x = "
"y`` and in the goal ``x + y = 6``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2298
msgid ""
"By default ``in`` keeps the body of local definitions. To erase the body of "
"a local definition during the generalization phase, the name of the local "
"definition must be written between parentheses, like in ``rewrite H in H1 "
"(def_n) H2.``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2303
msgid ""
"From |SSR| 1.5 the grammar for the in tactical has been extended to the "
"following one:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2308
msgid ""
"In its simplest form the last option lets one rename hypotheses that can’t "
"be cleared (like section variables). For example, ``(y := x)`` generalizes "
"over ``x`` and reintroduces the generalized variable under the name ``y`` "
"(and does not clear ``x``). For a more precise description of this form of "
"localization refer to :ref:`advanced_generalization_ssr`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2319
msgid "Structure"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2321
msgid ""
"Forward reasoning structures the script by explicitly specifying some "
"assumptions to be added to the proof context. It is closely associated with "
"the declarative style of proof, since an extensive use of these highlighted "
"statements make the script closer to a (very detailed) textbook proof."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2327
msgid ""
"Forward chaining tactics allow to state an intermediate lemma and start a "
"piece of script dedicated to the proof of this statement. The use of closing "
"tactics (see section :ref:`terminators_ssr`) and of indentation makes "
"syntactically explicit the portion of the script building the proof of the "
"intermediate statement."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2335
msgid "The have tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2337
msgid ""
"The main |SSR| forward reasoning tactic is the ``have`` tactic. It can be "
"use in two modes: one starts a new (sub)proof for an intermediate result in "
"the main proof, and the other provides explicitly a proof term for this "
"intermediate step."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2342
msgid "In the first mode, the syntax of have in its defective form is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2347
msgid ""
"This tactic supports open syntax for :token:`term`. Applied to a goal ``G``, "
"it generates a first subgoal requiring a proof of ``term`` in the context of "
"``G``. The second generated subgoal is of the form ``term -> G``, where term "
"becomes the new top assumption, instead of being introduced with a fresh "
"name. At the proof-term level, the have tactic creates a β redex, and "
"introduces the lemma under a fresh name, automatically chosen."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2355
msgid ""
"Like in the case of the ``pose`` tactic (see section :ref:"
"`definitions_ssr`), the types of the holes are abstracted in term."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2372
msgid "The invokation of ``have`` is equivalent to:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2386
msgid ""
"The have tactic also enjoys the same abstraction mechanism as the ``pose`` "
"tactic for the non-inferred implicit arguments. For instance, the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2404
msgid "opens a new subgoal where the type of ``x`` is quantified."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2406
msgid ""
"The behavior of the defective have tactic makes it possible to generalize it "
"in the following general construction:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2411
msgid ""
"Open syntax is supported for both :token:`term`. For the description of :"
"token:`i_item` and :token:`s_item` see section :ref:`introduction_ssr`. The "
"first mode of the have tactic, which opens a sub-proof for an intermediate "
"result, uses tactics of the form:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2419
msgid "which behave like:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2426
msgid ""
"Note that the :token:`clear_switch` *precedes* the:token:`i_item`, which "
"allows to reuse a name of the context, possibly used by the proof of the "
"assumption, to introduce the new assumption itself."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2431
msgid ""
"The``by`` feature is especially convenient when the proof script of the "
"statement is very short, basically when it fits in one line like in:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2438
msgid ""
"The possibility of using :token:`i_item` supplies a very concise syntax for "
"the further use of the intermediate step. For instance,"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2455
msgid ""
"Note how the second goal was rewritten using the stated equality. Also note "
"that in this last subgoal, the intermediate result does not appear in the "
"context."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2459
msgid ""
"Thanks to the deferred execution of clears, the following idiom is also "
"supported (assuming x occurs in the goal only):"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2466
msgid ""
"Another frequent use of the intro patterns combined with ``have`` is the "
"destruction of existential assumptions like in the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2484
msgid ""
"An alternative use of the ``have`` tactic is to provide the explicit proof "
"term for the intermediate lemma, using tactics of the form:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2489
msgid ""
"This tactic creates a new assumption of type the type of :token:`term`. If "
"the optional :token:`ident` is present, this assumption is introduced under "
"the name :token:`ident`. Note that the body of the constant is lost for the "
"user."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2494
msgid ""
"Again, non inferred implicit arguments and explicit holes are abstracted."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2511
msgid ""
"adds to the context ``H : Type -> Prop.`` This is a schematic example but "
"the feature is specially useful when the proof term to give involves for "
"instance a lemma with some hidden implicit arguments."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2515
msgid "After the :token:`i_pattern`, a list of binders is allowed."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2533
msgid ""
"A proof term provided after ``:=`` can mention these bound variables (that "
"are automatically introduced with the given names). Since the :token:"
"`i_pattern` can be omitted, to avoid ambiguity, bound variables can be "
"surrounded with parentheses even if no type is specified:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2543
msgid ""
"The :token:`i_item` and :token:`s_item` can be used to interpret the "
"asserted hypothesis with views (see section :ref:`views_and_reflection_ssr`) "
"or simplify the resulting goals."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2547
msgid ""
"The ``have`` tactic also supports a ``suff`` modifier which allows for "
"asserting that a given statement implies the current goal without copying "
"the goal itself."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2563
msgid "Note that H is introduced in the second goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2565
msgid ""
"The ``suff`` modifier is not compatible with the presence of a list of "
"binders."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2571
msgid "Generating let in context entries with have"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2573
msgid ""
"Since |SSR| 1.5 the ``have`` tactic supports a “transparent” modifier to "
"generate let in context entries: the ``@`` symbol in front of the context "
"entry name."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2593
msgid ""
"Note that the sub-term produced by ``omega`` is in general huge and "
"uninteresting, and hence one may want to hide it. For this purpose the ``[: "
"name ]`` intro pattern and the tactic ``abstract`` (see :ref:`abstract_ssr`) "
"are provided."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2609
msgid ""
"The type of ``pm`` can be cleaned up by its annotation ``(*1*)`` by just "
"simplifying it. The annotations are there for technical reasons only."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2612
msgid ""
"When intro patterns for abstract constants are used in conjunction with have "
"and an explicit term, they must be used as follows:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2627
msgid ""
"In this case the abstract constant ``pm`` is assigned by using it in the "
"term that follows ``:=`` and its corresponding goal is left to be solved. "
"Goals corresponding to intro patterns for abstract constants are opened in "
"the order in which the abstract constants are declared (not in the “order” "
"in which they are used in the term)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2633
msgid ""
"Note that abstract constants do respect scopes. Hence, if a variable is "
"declared after their introduction, it has to be properly generalized (i.e. "
"explicitly passed to the abstract constant when one makes use of it)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2649
msgid ""
"Last, notice that the use of intro patterns for abstract constants is "
"orthogonal to the transparent flag ``@`` for have."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2654
msgid "The have tactic and typeclass resolution"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2656
msgid ""
"Since |SSR| 1.5 the ``have`` tactic behaves as follows with respect to "
"typeclass inference."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2672
msgid ""
"Full inference for ``ty``. The first subgoal demands a proof of such "
"instantiated statement."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2679
msgid ""
"No inference for ``ty``. Unresolved instances are quantified in ``ty``. The "
"first subgoal demands a proof of such quantified statement. Note that no "
"proof term follows ``:=``, hence two subgoals are generated."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2688
msgid "No inference for ``ty`` and ``t``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2694
msgid ""
"No inference for ``t``. Unresolved instances are quantified in the "
"(inferred) type of ``t`` and abstracted in ``t``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2699
msgid ""
"This option restores the behavior of |SSR| 1.4 and below (never resolve "
"typeclasses)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2702
msgid "Variants: the suff and wlog tactics"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2704
msgid ""
"As it is often the case in mathematical textbooks, forward reasoning may be "
"used in slightly different variants. One of these variants is to show that "
"the intermediate step L easily implies the initial goal G. By easily we mean "
"here that the proof of L ⇒ G is shorter than the one of L itself. This kind "
"of reasoning step usually starts with: “It suffices to show that …”."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2711
msgid ""
"This is such a frequent way of reasoning that |SSR| has a variant of the "
"``have`` tactic called ``suffices`` (whose abridged name is ``suff``). The "
"``have`` and ``suff`` tactics are equivalent and have the same syntax but:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2717
msgid "the order of the generated subgoals is inversed"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2718
msgid ""
"but the optional clear item is still performed in the *second* branch. This "
"means that the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2725
msgid ""
"fails if the context of the current goal indeed contains an assumption named "
"``H``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2729
msgid ""
"The rationale of this clearing policy is to make possible “trivial” "
"refinements of an assumption, without changing its name in the main branch "
"of the reasoning."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2733
msgid "The ``have`` modifier can follow the ``suff`` tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2747
msgid ""
"Note that, in contrast with ``have suff``, the name H has been introduced in "
"the first goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2750
msgid ""
"Another useful construct is reduction, showing that a particular case is in "
"fact general enough to prove a general property. This kind of reasoning step "
"usually starts with: “Without loss of generality, we can suppose that …”. "
"Formally, this corresponds to the proof of a goal ``G`` by introducing a cut "
"``wlog_statement -> G``. Hence the user shall provide a proof for both "
"``(wlog_statement -> G) -> G`` and ``wlog_statement -> G``. However, such "
"cuts are usually rather painful to perform by hand, because the statement "
"``wlog_statement`` is tedious to write by hand, and sometimes even to read."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2761
msgid ""
"|SSR| implements this kind of reasoning step through the :tacn:`without "
"loss` tactic, whose short name is :tacn:`wlog`. It offers support to "
"describe the shape of the cut statements, by providing the simplifying "
"hypothesis and by pointing at the elements of the initial goals which should "
"be generalized. The general syntax of without loss is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2772
msgid ""
"where each :token:`ident` is a constant in the context of the goal. Open "
"syntax is supported for :token:`term`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2775
msgid "In its defective form:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2781
msgid ""
"on a goal G, it creates two subgoals: a first one to prove the formula (term "
"-> G) -> G and a second one to prove the formula term -> G."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2785
msgid ""
"If the optional list of :token:`ident` is present on the left side of ``/``, "
"these constants are generalized in the premise (term -> G) of the first "
"subgoal. By default bodies of local definitions are erased. This behavior "
"can be inhibited by prefixing the name of the local definition with the "
"``@`` character."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2791
msgid "In the second subgoal, the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2797
msgid ""
"is performed if at least one of these optional switches is present in the :"
"tacn:`wlog` tactic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2800
msgid ""
"The :tacn:`wlog` tactic is specially useful when a symmetry argument "
"simplifies a proof. Here is an example showing the beginning of the proof "
"that quotient and reminder of natural number euclidean division are unique."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2818
msgid ""
"The ``wlog suff`` variant is simpler, since it cuts ``wlog_statement`` "
"instead of ``wlog_statement -> G``. It thus opens the goals ``wlog_statement "
"-> G`` and ``wlog_statement``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2823
msgid ""
"In its simplest form the ``generally have : …`` tactic is equivalent to "
"``wlog suff : …`` followed by last first. When the ``have`` tactic is used "
"with the ``generally`` (or ``gen``) modifier it accepts an extra identifier "
"followed by a comma before the usual intro pattern. The identifier will name "
"the new hypothesis in its more general form, while the intro pattern will be "
"used to process its instance."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2855
msgid "Advanced generalization"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2857
msgid ""
"The complete syntax for the items on the left hand side of the ``/`` "
"separator is the following one:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2862
msgid ""
"Clear operations are intertwined with generalization operations. This helps "
"in particular avoiding dependency issues while generalizing some facts."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2866
msgid ""
"If an :token:`ident` is prefixed with the ``@`` mark, then a let-in redex is "
"created, which keeps track if its body (if any). The syntax ``( ident := "
"c_pattern)`` allows to generalize an arbitrary term using a given name. Note "
"that its simplest form ``(x := y)`` is just a renaming of ``y`` into ``x``. "
"In particular, this can be useful in order to simulate the generalization of "
"a section variable, otherwise not allowed. Indeed renaming does not require "
"the original variable to be cleared."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2874
msgid ""
"The syntax ``(@x := y)`` generates a let-in abstraction but with the "
"following caveat: ``x`` will not bind ``y``, but its body, whenever ``y`` "
"can be unfolded. This covers the case of both local and global definitions, "
"as illustrated in the following example."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2896
msgid ""
"To avoid unfolding the term captured by the pattern add x one can use the "
"pattern ``id (addx x)``, that would produce the following first subgoal"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2917
msgid "Rewriting"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2919
msgid ""
"The generalized use of reflection implies that most of the intermediate "
"results handled are properties of effectively computable functions. The most "
"efficient mean of establishing such results are computation and "
"simplification of expressions involving such functions, i.e., rewriting. |"
"SSR| therefore includes an extended ``rewrite`` tactic, that unifies and "
"combines most of the rewriting functionalities."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2929
msgid "An extended rewrite tactic"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2931
msgid "The main features of the rewrite tactic are:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2933
msgid ""
"It can perform an entire series of such operations in any subset of the goal "
"and/or context;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2935
msgid ""
"It allows to perform rewriting, simplifications, folding/unfolding of "
"definitions, closing of goals;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2937
msgid "Several rewriting operations can be chained in a single tactic;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2938
msgid ""
"Control over the occurrence at which rewriting is to be performed is "
"significantly enhanced."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2941
msgid "The general form of an |SSR| rewrite tactic is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2946
msgid ""
"The combination of a rewrite tactic with the in tactical (see section :ref:"
"`localization_ssr`) performs rewriting in both the context and the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2949
msgid "A rewrite step :token:`rstep` has the general form:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2963
msgid ""
"An :token:`r_prefix` contains annotations to qualify where and how the "
"rewrite operation should be performed:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2966
msgid ""
"The optional initial ``-`` indicates the direction of the rewriting of :"
"token:`r_item`: if present the direction is right-to-left and it is left-to-"
"right otherwise."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2969
msgid ""
"The multiplier :token:`mult` (see section :ref:`iteration_ssr`) specifies if "
"and how the rewrite operation should be repeated."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2972
msgid ""
"A rewrite operation matches the occurrences of a *rewrite pattern*, and "
"replaces these occurrences by another term, according to the given :token:"
"`r_item`. The optional *redex switch* ``[r_pattern]``, which should always "
"be surrounded by brackets, gives explicitly this rewrite pattern. In its "
"simplest form, it is a regular term. If no explicit redex switch is present "
"the rewrite pattern to be matched is inferred from the :token:`r_item`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2980
msgid ""
"This optional term, or the :token:`r_item`, may be preceded by an occurrence "
"switch (see section :ref:`selectors_ssr`) or a clear item (see section :ref:"
"`discharge_ssr`), these two possibilities being exclusive. An occurrence "
"switch selects the occurrences of the rewrite pattern which should be "
"affected by the rewrite operation."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2988
msgid "An :token:`r_item` can be:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2991
msgid ""
"A *simplification* :token:`r_item`, represented by a :token:`s_item` (see "
"section :ref:`introduction_ssr`). Simplification operations are intertwined "
"with the possible other rewrite operations specified by the list of :token:"
"`r_item`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:2995
msgid ""
"A *folding/unfolding* :token:`r_item`. The tactic: ``rewrite /term`` unfolds "
"the head constant of term in every occurrence of the first matching of term "
"in the goal. In particular, if ``my_def`` is a (local or global) defined "
"constant, the tactic: ``rewrite /my_def.`` is analogous to: ``unfold "
"my_def``. Conversely: ``rewrite -/my_def.`` is equivalent to: ``fold "
"my_def``. When an unfold :token:`r_item` is combined with a redex pattern, a "
"conversion operation is performed. A tactic of the form: ``rewrite -[term1]/"
"term2.`` is equivalent to: ``change term1 with term2.`` If ``term2`` is a "
"single constant and ``term1`` head symbol is not ``term2``, then the head "
"symbol of ``term1`` is repeatedly unfolded until ``term2`` appears."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3017
msgid "A :token:`term`, which can be:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3010
msgid ""
"A term whose type has the form: ``forall (x1 : A1 )…(xn : An ), eq term1 "
"term2`` where ``eq`` is the Leibniz equality or a registered setoid equality."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3014
msgid ""
"A list of terms ``(t1 ,…,tn)``, each ``ti`` having a type above. The tactic: "
"``rewrite r_prefix (t1 ,…,tn ).`` is equivalent to: ``do [rewrite r_prefix "
"t1 | … | rewrite r_prefix tn ].``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3017
msgid ""
"An anonymous rewrite lemma ``(_ : term)``, where term has a type as above.  "
"tactic: ``rewrite (_ : term)`` is in fact synonym of: ``cutrewrite (term).``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3037
msgid ""
"The |SSR| terms containing holes are *not* typed as abstractions in this "
"context. Hence the following script fails."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3050
msgid "but the following script succeeds"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3062
msgid "Remarks and examples"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3065
msgid "Rewrite redex selection"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3067
msgid ""
"The general strategy of |SSR| is to grasp as many redexes as possible and to "
"let the user select the ones to be rewritten thanks to the improved syntax "
"for the control of rewriting."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3071
msgid ""
"This may be a source of incompatibilities between the two rewrite tactics."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3074
msgid "In a rewrite tactic of the form:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3080
msgid ""
"``term1`` is the explicit rewrite redex and ``term2`` is the rewrite rule. "
"This execution of this tactic unfolds as follows:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3084
msgid ""
"First ``term1`` and ``term2`` are βι normalized. Then ``term2`` is put in "
"head normal form if the Leibniz equality constructor ``eq`` is not the head "
"symbol. This may involve ζ reductions."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3088
msgid ""
"Then, the matching algorithm (see section :ref:`abbreviations_ssr`) "
"determines the first subterm of the goal matching the rewrite pattern. The "
"rewrite pattern is given by ``term1``, if an explicit redex pattern switch "
"is provided, or by the type of ``term2`` otherwise. However, matching skips "
"over matches that would lead to trivial rewrites. All the occurrences of "
"this subterm in the goal are candidates for rewriting."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3095
msgid ""
"Then only the occurrences coded by :token:`occ_switch` (see again section :"
"ref:`abbreviations_ssr`) are finally selected for rewriting."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3097
msgid ""
"The left hand side of ``term2`` is unified with the subterm found by the "
"matching algorithm, and if this succeeds, all the selected occurrences in "
"the goal are replaced by the right hand side of ``term2``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3100
msgid "Finally the goal is βι normalized."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3103
msgid ""
"In the case ``term2`` is a list of terms, the first top-down (in the goal) "
"left-to-right (in the list) matching rule gets selected."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3108
msgid "Chained rewrite steps"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3110
msgid ""
"The possibility to chain rewrite operations in a single tactic makes scripts "
"more compact and gathers in a single command line a bunch of surgical "
"operations which would be described by a one sentence in a pen and paper "
"proof."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3115
msgid ""
"Performing rewrite and simplification operations in a single tactic enhances "
"significantly the concision of scripts. For instance the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3124
msgid ""
"unfolds ``my_def`` in the goal, simplifies the second occurrence of the "
"first subterm matching pattern ``[f _]``, rewrites ``my_eq``, simplifies the "
"goals and closes trivial goals."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3128
msgid ""
"Here are some concrete examples of chained rewrite operations, in the proof "
"of basic results on natural numbers arithmetic."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3155
msgid ""
"Note the use of the ``?`` switch for parallel rewrite operations in the "
"proof of ``addnCA``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3160
msgid "Explicit redex switches are matched first"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3162
msgid ""
"If an :token:`r_prefix` involves a *redex switch*, the first step is to find "
"a subterm matching this redex pattern, independently from the left hand side "
"of the equality the user wants to rewrite."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3182
msgid ""
"Note that if this first pattern matching is not compatible with the :token:"
"`r_item`, the rewrite fails, even if the goal contains a correct redex "
"matching both the redex switch and the left hand side of the equality."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3202
msgid ""
"Indeed the left hand side of ``H`` does not match the redex identified by "
"the pattern ``x + y * 4``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3207
msgid "Occurrence switches and redex switches"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3224
msgid ""
"The second subgoal is generated by the use of an anonymous lemma in the "
"rewrite tactic. The effect of the tactic on the initial goal is to rewrite "
"this lemma at the second occurrence of the first matching ``x + y + 0`` of "
"the explicit rewrite redex ``_ + y + 0``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3231
msgid "Occurrence selection and repetition"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3233
msgid ""
"Occurrence selection has priority over repetition switches. This means the "
"repetition of a rewrite tactic specified by a multiplier will perform "
"matching each time an elementary rewrite operation is performed. Repeated "
"rewrite tactics apply to every subgoal generated by the previous tactic, "
"including the previous instances of the repetition."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3254
msgid ""
"This last tactic generates *three* subgoals because the second rewrite "
"operation specified with the ``2!`` multiplier applies to the two subgoals "
"generated by the first rewrite."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3260
msgid "Multi-rule rewriting"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3262
msgid ""
"The rewrite tactic can be provided a *tuple* of rewrite rules, or more "
"generally a tree of such rules, since this tuple can feature arbitrary inner "
"parentheses. We call *multirule* such a generalized rewrite rule. This "
"feature is of special interest when it is combined with multiplier switches, "
"which makes the rewrite tactic iterate the rewrite operations prescribed by "
"the rules on the current goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3290
msgid ""
"Indeed rule ``eqab`` is the first to apply among the ones gathered in the "
"tuple passed to the rewrite tactic. This multirule ``(eqab, eqac)`` is "
"actually a |Coq| term and we can name it with a definition:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3303
msgid ""
"In this case, the tactic ``rewrite multi1`` is a synonym for ``rewrite "
"(eqab, eqac)``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3306
msgid ""
"More precisely, a multirule rewrites the first subterm to which one of the "
"rules applies in a left-to-right traversal of the goal, with the first rule "
"from the multirule tree in left-to-right order. Matching is performed "
"according to the algorithm described in Section :ref:`abbreviations_ssr`, "
"but literal matches have priority."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3324
msgid "Indeed rule ``eqd0`` applies without unfolding the definition of ``d``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3327
msgid "For repeated rewrites the selection process is repeated anew."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3346
msgid ""
"It uses ``eq_adda_b`` then ``eqb0`` on the left-hand side only. Without the "
"bound ``2`` one would obtain ``0 = 0``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3349
msgid ""
"The grouping of rules inside a multirule does not affect the selection "
"strategy but can make it easier to include one rule set in another or to "
"(universally) quantify over the parameters of a subset of rules (as there is "
"special code that will omit unnecessary quantifiers for rules that can be "
"syntactically extracted). It is also possible to reverse the direction of a "
"rule subset, using a special dedicated syntax: the tactic rewrite ``(=~ "
"multi1)`` is equivalent to ``rewrite multi1_rev``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3369
msgid ""
"except that the constants ``eqba``, ``eqab``, ``mult1_rev`` have not been "
"created."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3372
msgid ""
"Rewriting with multirules is useful to implement simplification or "
"transformation procedures, to be applied on terms of small to medium size. "
"For instance the library `ssrnat` (Mathematical Components library) provides "
"two implementations for arithmetic operations on natural numbers: an "
"elementary one and a tail recursive version, less inefficient but also less "
"convenient for reasoning purposes. The library also provides one lemma per "
"such operation, stating that both versions return the same values when "
"applied to the same arguments:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3392
msgid ""
"The operation on the left hand side of each lemma is the efficient version, "
"and the corresponding naive implementation is on the right hand side. In "
"order to reason conveniently on expressions involving the efficient "
"operations, we gather all these rules in the definition ``trecE``:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3402
msgid ""
"The tactic: ``rewrite !trecE.`` restores the naive versions of each "
"operation in a goal involving the efficient ones, e.g. for the purpose of a "
"correctness proof."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3408
msgid "Wildcards vs abstractions"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3410
msgid ""
"The rewrite tactic supports :token:`r_items` containing holes. For example, "
"in the tactic ``rewrite (_ : _ * 0 = 0).`` the term ``_ * 0 = 0`` is "
"interpreted as ``forall n : nat, n * 0 = 0.`` Anyway this tactic is *not* "
"equivalent to ``rewrite (_ : forall x, x * 0 = 0).``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3432
msgid "while the other tactic results in"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3442
msgid ""
"The first tactic requires you to prove the instance of the (missing) lemma "
"that was used, while the latter requires you prove the quantified form."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3447
msgid "When |SSR| rewrite fails on standard |Coq| licit rewrite"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3449
msgid ""
"In a few cases, the |SSR| rewrite tactic fails rewriting some redexes which "
"standard |Coq| successfully rewrites. There are two main cases:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3454
msgid "|SSR| never accepts to rewrite indeterminate patterns like:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3460
msgid "|SSR| will however accept the ηζ expansion of this rule:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3467
msgid ""
"The standard rewrite tactic provided by |Coq| uses a different algorithm to "
"find instances of the rewrite rule."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3491
msgid ""
"This rewriting is not possible in |SSR| because there is no occurrence of "
"the head symbol ``f`` of the rewrite rule in the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3503
msgid ""
"Rewriting with ``H`` first requires unfolding the occurrences of ``f`` where "
"the substitution is to be performed (here there is a single such "
"occurrence), using tactic ``rewrite /f`` (for a global replacement of f by "
"g) or ``rewrite pattern/f``, for a finer selection."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3517
msgid "alternatively one can override the pattern inferred from ``H``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3529
msgid "Existential metavariables and rewriting"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3531
msgid ""
"The rewrite tactic will not instantiate existing existential metavariables "
"when matching a redex pattern."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3534
msgid ""
"If a rewrite rule generates a goal with new existential metavariables in the "
"``Prop`` sort, these will be generalized as for ``apply`` (see :ref:"
"`apply_ssr`) and corresponding new goals will be generated."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3565
msgid ""
"Since the argument corresponding to Px is not supplied by the user, the "
"resulting goal should be ``Some x = Some (Sub y ?Goal).`` Instead, |SSR| "
"``rewrite`` tactic hides the existential variable."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3569
msgid ""
"As in :ref:`apply_ssr`, the ``ssrautoprop`` tactic is used to try to solve "
"the existential variable."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3582
msgid ""
"As a temporary limitation, this behavior is available only if the rewriting "
"rule is stated using Leibniz equality (as opposed to setoid relations). It "
"will be extended to other rewriting relations in the future."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3591
msgid "Locking, unlocking"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3593
msgid ""
"As program proofs tend to generate large goals, it is important to be able "
"to control the partial evaluation performed by the simplification operations "
"that are performed by the tactics. These evaluations can for example come "
"from a ``/=`` simplification switch, or from rewrite steps which may expand "
"large terms while performing conversion. We definitely want to avoid "
"repeating large subterms of the goal in the proof script. We do this by "
"“clamping down” selected function symbols in the goal, which prevents them "
"from being considered in simplification or rewriting steps. This clamping is "
"accomplished by using the occurrence switches (see section:ref:"
"`abbreviations_ssr`) together with “term tagging” operations."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3605
msgid "|SSR| provides two levels of tagging."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3607
msgid ""
"The first one uses auxiliary definitions to introduce a provably equal copy "
"of any term t. However this copy is (on purpose) *not convertible* to t in "
"the |Coq| system [#8]_. The job is done by the following construction:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3618
msgid ""
"Note that the definition of *master_key* is explicitly opaque. The equation "
"``t = locked t`` given by the ``lock`` lemma can be used for selective "
"rewriting, blocking on the fly the reduction in the term ``t``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3641
msgid ""
"It is sometimes desirable to globally prevent a definition from being "
"expanded by simplification; this is done by adding locked in the definition."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3663
msgid ""
"We provide a special tactic unlock for unfolding such definitions while "
"removing “locks”, e.g., the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3669
msgid ""
"replaces the occurrence(s) of :token:`ident` coded by the :token:"
"`occ_switch` with the corresponding body."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3672
msgid ""
"We found that it was usually preferable to prevent the expansion of some "
"functions by the partial evaluation switch ``/=``, unless this allowed the "
"evaluation of a condition. This is possible thanks to another mechanism of "
"term tagging, resting on the following *Notation*:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3681
msgid ""
"The term ``(nosimpl t)`` simplifies to ``t`` *except* in a definition. More "
"precisely, given:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3688
msgid ""
"the term ``foo`` (or ``(foo t’)``) will *not* be expanded by the *simpl* "
"tactic unless it is in a forcing context (e.g., in ``match foo t’ with … "
"end``, ``foo t’`` will be reduced if this allows ``match`` to be reduced). "
"Note that ``nosimpl bar`` is simply notation for a term that reduces to "
"``bar``; hence ``unfold foo`` will replace ``foo`` by ``bar``, and ``fold "
"foo`` will replace ``bar`` by ``foo``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3697
msgid ""
"The ``nosimpl`` trick only works if no reduction is apparent in ``t``; in "
"particular, the declaration:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3704
msgid ""
"will usually not work. Anyway, the common practice is to tag only the "
"function, and to use the following definition, which blocks the reduction as "
"expected:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3712
msgid ""
"A standard example making this technique shine is the case of arithmetic "
"operations. We define for instance:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3719
msgid ""
"The operation ``addn`` behaves exactly like ``plus``, except that ``(addn (S "
"n) m)`` will not simplify spontaneously to ``(S (addn n m))`` (the two "
"terms, however, are convertible). In addition, the unfolding step: "
"``rewrite /addn`` will replace ``addn`` directly with ``plus``, so the "
"``nosimpl`` form is essentially invisible."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3730
msgid "Congruence"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3732
msgid ""
"Because of the way matching interferes with parameters of type families, the "
"tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3739
msgid ""
"will generally fail to perform congruence simplification, even on rather "
"simple cases. We therefore provide a more robust alternative in which the "
"function is supplied:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3746
msgid ""
"This tactic: + checks that the goal is a Leibniz equality + matches both "
"sides of this equality with “term applied to some arguments”, inferring the "
"right number of arguments from the goal and the type of term. This may "
"expand some definitions or fixpoints. + generates the subgoals corresponding "
"to pairwise equalities of the arguments present in the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3751
msgid ""
"The goal can be a non dependent product ``P -> Q``. In that case, the system "
"asserts the equation ``P = Q``, uses it to solve the goal, and calls the "
"``congr`` tactic on the remaining goal ``P = Q``. This can be useful for "
"instance to perform a transitivity step, like in the following situation."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3776
msgid ""
"The optional :token:`num` forces the number of arguments for which the "
"tactic should generate equality proof obligations."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3779
msgid ""
"This tactic supports equalities between applications with dependent "
"arguments. Yet dependent arguments should have exactly the same parameters "
"on both sides, and these parameters should appear as first arguments."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3803
msgid ""
"This script shows that the ``congr`` tactic matches ``plus`` with ``f 0`` on "
"the left hand side and ``g 1 1`` on the right hand side, and solves the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3822
msgid ""
"The tactic ``rewrite -/plus`` folds back the expansion of plus which was "
"necessary for matching both sides of the equality with an application of "
"``S``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3826
msgid "Like most |SSR| arguments, term can contain wildcards."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3846
msgid "Contextual patterns"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3848
msgid ""
"The simple form of patterns used so far, terms possibly containing wild "
"cards, often require an additional :token:`occ_switch` to be specified. "
"While this may work pretty fine for small goals, the use of polymorphic "
"functions and dependent types may lead to an invisible duplication of "
"function arguments. These copies usually end up in types hidden by the "
"implicit arguments machinery or by user-defined notations. In these "
"situations computing the right occurrence numbers is very tedious because "
"they must be counted on the goal as printed after setting the :flag:"
"`Printing All` flag. Moreover the resulting script is not really informative "
"for the reader, since it refers to occurrence numbers he cannot easily see."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3860
msgid ""
"Contextual patterns mitigate these issues allowing to specify occurrences "
"according to the context they occur in."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3867
msgid ""
"The following table summarizes the full syntax of :token:`c_pattern` and the "
"corresponding subterm(s) identified by the pattern. In the third column we "
"use s.m.r. for “the subterms matching the redex” specified in the second "
"column."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3875
#: ../../proof-engine/ssreflect-proof-language.rst:3953
msgid ":token:`c_pattern`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3876
#: ../../proof-engine/ssreflect-proof-language.rst:3906
msgid "redex"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3877
#: ../../proof-engine/ssreflect-proof-language.rst:3907
msgid "subterms affected"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3879
#: ../../proof-engine/ssreflect-proof-language.rst:3880
#: ../../proof-engine/ssreflect-proof-language.rst:3956
msgid "``term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3881
msgid "all occurrences of ``term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3883
#: ../../proof-engine/ssreflect-proof-language.rst:3960
msgid "``ident in term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3884
msgid "subterm of ``term`` selected by ``ident``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3885
msgid ""
"all the subterms identified by ``ident`` in all the occurrences of ``term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3888
#: ../../proof-engine/ssreflect-proof-language.rst:3965
msgid "``term1 in ident in term2``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3889
msgid "``term1`` in all s.m.r."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3890
msgid ""
"in all the subterms identified by ``ident`` in all the occurrences of "
"``term2``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3892
#: ../../proof-engine/ssreflect-proof-language.rst:3971
msgid "``term1 as ident in term2``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3893
msgid "``term 1``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3894
msgid ""
"in all the subterms identified by ``ident` in all the occurrences of "
"``term2[term 1 /ident]``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3897
msgid ""
"The rewrite tactic supports two more patterns obtained prefixing the first "
"two with in. The intended meaning is that the pattern identifies all "
"subterms of the specified context. The ``rewrite`` tactic will infer a "
"pattern for the redex looking at the rule used for rewriting."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3905
#: ../../proof-engine/ssreflect-proof-language.rst:3981
msgid ":token:`r_pattern`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3909
#: ../../proof-engine/ssreflect-proof-language.rst:3989
msgid "``in term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3910
#: ../../proof-engine/ssreflect-proof-language.rst:3914
msgid "inferred from rule"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3911
msgid "in all s.m.r. in all occurrences of ``term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3913
#: ../../proof-engine/ssreflect-proof-language.rst:3984
msgid "``in ident in term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3915
msgid ""
"in all s.m.r. in all the subterms identified by ``ident`` in all the "
"occurrences of ``term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3918
msgid ""
"The first :token:`c_pattern` is the simplest form matching any context but "
"selecting a specific redex and has been described in the previous sections. "
"We have seen so far that the possibility of selecting a redex using a term "
"with holes is already a powerful means of redex selection. Similarly, any "
"terms provided by the user in the more complex forms of :token:`c_patterns` "
"presented in the tables above can contain holes."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3927
msgid ""
"For a quick glance at what can be expressed with the last :token:`r_pattern` "
"consider the goal ``a = b`` and the tactic"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3935
msgid ""
"It rewrites all occurrences of the left hand side of ``rule`` inside ``b``  "
"only (``a``, and the hidden type of the equality, are ignored). Note that "
"the variant ``rewrite [X in _ = X]rule`` would have rewritten ``b`` exactly "
"(i.e., it would only work if ``b`` and the left hand side of rule can be "
"unified)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3943
msgid "Matching contextual patterns"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3945
msgid ""
"The :token:`c_pattern` and :token:`r_pattern` involving terms with holes are "
"matched against the goal in order to find a closed instantiation. This "
"matching proceeds as follows:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3954
#: ../../proof-engine/ssreflect-proof-language.rst:3982
msgid "instantiation order and place for ``term_i`` and redex"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3957
msgid ""
"``term`` is matched against the goal, redex is unified with the "
"instantiation of ``term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3961
msgid ""
"``term`` is matched against the goal, redex is unified with the subterm of "
"the instantiation of ``term`` identified by ``ident``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3966
msgid ""
"``term2`` is matched against the goal, ``term1`` is matched against the "
"subterm of the instantiation of ``term1`` identified by ``ident``, redex is "
"unified with the instantiation of ``term1``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3972
msgid ""
"``term2[term1/ident]`` is matched against the goal, redex is unified with "
"the instantiation of ``term1``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3975
msgid ""
"In the following patterns, the redex is intended to be inferred from the "
"rewrite rule."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3985
msgid ""
"``term`` is matched against the goal, the redex is matched against the "
"subterm of the instantiation of ``term`` identified by ``ident``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3990
msgid ""
"``term`` is matched against the goal, redex is matched against the "
"instantiation of ``term``"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3995
msgid "Examples"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:3999
msgid "Contextual pattern in set and the : tactical"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4001
msgid ""
"As already mentioned in section :ref:`abbreviations_ssr` the ``set`` tactic "
"takes as an argument a term in open syntax. This term is interpreted as the "
"simplest form of :token:`c_pattern`. To avoid confusion in the grammar, open "
"syntax is supported only for the simplest form of patterns, while "
"parentheses are required around more complex patterns."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4026
msgid ""
"Since the user may define an infix notation for ``in`` the result of the "
"former tactic may be ambiguous. The disambiguation rule implemented is to "
"prefer patterns over simple terms, but to interpret a pattern with double "
"parentheses as a simple term. For example, the following tactic would "
"capture any occurrence of the term ``a in A``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4036
msgid ""
"Contextual patterns can also be used as arguments of the ``:`` tactical. For "
"example:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4045
msgid "Contextual patterns in rewrite"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4069
msgid ""
"Note: the simplification rule ``addSn`` is applied only under the ``f`` "
"symbol. Then we simplify also the first addition and expand 0 into 0+0."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4077
msgid ""
"Note that the right hand side of ``addn0`` is undetermined, but the rewrite "
"pattern specifies the redex explicitly. The right hand side of ``addn0`` is "
"unified with the term identified by ``X``, here ``0``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4082
msgid ""
"The following pattern does not specify a redex, since it identifies an "
"entire region, hence the rewrite rule has to be instantiated explicitly. "
"Thus the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4090
msgid "The following tactic is quite tricky:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4096
msgid ""
"The explicit redex ``_.+1`` is important since its head constant ``S`` "
"differs from the head constant inferred from ``(addnC x.+1)`` (that is ``"
"+``). Moreover, the pattern ``f _ X`` is important to rule out the first "
"occurrence of ``(x + y).+1``. Last, only the subterms of ``f _ X`` "
"identified by ``X`` are rewritten, thus the first argument of ``f`` is "
"skipped too. Also note the pattern ``_.+1`` is interpreted in the context "
"identified by ``X``, thus it gets instantiated to ``(y + x).+1`` and not "
"``(x + y).+1``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4108
msgid ""
"The last rewrite pattern allows to specify exactly the shape of the term "
"identified by X, that is thus unified with the left hand side of the rewrite "
"rule."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4118
msgid "Patterns for recurrent contexts"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4120
msgid ""
"The user can define shortcuts for recurrent contexts corresponding to the "
"``ident in term`` part. The notation scope identified with ``%pattern`` "
"provides a special notation ``(X in t)`` the user must adopt in order to "
"define context shortcuts."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4127
msgid ""
"The following example is taken from ``ssreflect.v`` where the ``LHS`` and "
"``RHS`` shortcuts are defined."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4135
msgid ""
"Shortcuts defined this way can be freely used in place of the trailing "
"``ident in term`` part of any contextual pattern. Some examples follow:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4148
msgid "Views and reflection"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4150
msgid ""
"The bookkeeping facilities presented in section :ref:`basic_tactics_ssr` are "
"crafted to ease simultaneous introductions and generalizations of facts and "
"operations of casing, naming etc. It also a common practice to make a stack "
"operation immediately followed by an *interpretation* of the fact being "
"pushed, that is, to apply a lemma to this fact before passing it to a tactic "
"for decomposition, application and so on."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4157
msgid ""
"|SSR| provides a convenient, unified syntax to combine these interpretation "
"operations with the proof stack operations. This *view mechanism* relies on "
"the combination of the ``/`` view switch with bookkeeping tactics and "
"tacticals."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4164
msgid "Interpreting eliminations"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4166
msgid ""
"The view syntax combined with the ``elim`` tactic specifies an elimination "
"scheme to be used instead of the default, generated, one. Hence the |SSR| "
"tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4174
#: ../../proof-engine/ssreflect-proof-language.rst:4190
msgid "is a synonym for:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4180
msgid "where top is a fresh name and V any second-order lemma."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4182
msgid ""
"Since an elimination view supports the two bookkeeping tacticals of "
"discharge and introduction (see section :ref:`basic_tactics_ssr`), the |SSR| "
"tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4196
msgid ""
"where ``x`` is a variable in the context, ``y`` a fresh name and ``V`` any "
"second order lemma; |SSR| relaxes the syntactic restrictions of the |Coq| "
"``elim``. The first pattern following ``:`` can be a ``_`` wildcard if the "
"conclusion of the view ``V`` specifies a pattern for its last argument (e."
"g., if ``V`` is a functional induction lemma generated by the ``Function`` "
"command)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4203
msgid ""
"The elimination view mechanism is compatible with the equation name "
"generation (see section :ref:`generation_of_equations_ssr`)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4209
msgid ""
"The following script illustrates a toy example of this feature. Let us "
"define a function adding an element at the end of a list:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4226
msgid ""
"One can define an alternative, reversed, induction principle on inductively "
"defined lists, by proving the following lemma:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4235
msgid ""
"Then the combination of elimination views with equation names result in a "
"concise syntax for reasoning inductively using the user-defined elimination "
"scheme."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4245
msgid ""
"User-provided eliminators (potentially generated with |Coq|’s ``Function`` "
"command) can be combined with the type family switches described in section :"
"ref:`type_families_ssr`. Consider an eliminator ``foo_ind`` of type:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4254
msgid "and consider the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4260
msgid "The ``elim/`` tactic distinguishes two cases:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:0
msgid "truncated eliminator"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4262
msgid ""
"when ``x`` does not occur in ``P p1 … pm`` and the type of ``en`` unifies "
"with ``T`` and ``en`` is not ``_``. In that case, ``en`` is passed to the "
"eliminator as the last argument (``x`` in ``foo_ind``) and ``en−1 … e1`` are "
"used as patterns to select in the goal the occurrences that will be bound by "
"the predicate ``P``, thus it must be possible to unify the sub-term of the "
"goal matched by ``en−1`` with ``pm`` , the one matched by ``en−2`` with ``pm"
"−1`` and so on."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:0
msgid "regular eliminator"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4270
msgid ""
"in all the other cases. Here it must be possible to unify the term matched "
"by ``en`` with ``pm`` , the one matched by ``en−1`` with ``pm−1`` and so on. "
"Note that standard eliminators have the shape ``…forall x, P … x``, thus "
"``en`` is the pattern identifying the eliminated term, as expected."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4278
msgid ""
"As explained in section :ref:`type_families_ssr`, the initial prefix of "
"``ei`` can be omitted."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4281
msgid "Here is an example of a regular, but nontrivial, eliminator."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4285
msgid "Here is a toy example illustrating this feature."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4304
msgid ""
"The following tactics are all valid and perform the same elimination on this "
"goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4333
msgid ""
"The two latter examples feature a wildcard pattern: in this case, the "
"resulting pattern is inferred from the type of the eliminator. In both these "
"examples, it is ``(plus _ _)``, which matches the subterm ``plus (plus x y) "
"z`` thus instantiating the last ``_`` with ``z``. Note that the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4358
msgid ""
"triggers an error: in the conclusion of the ``plus_ind`` eliminator, the "
"first argument of the predicate ``P`` should be the same as the second "
"argument of ``plus``, in the second argument of ``P``, but ``y`` and ``z`` "
"do no unify."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4363
msgid "Here is an example of a truncated eliminator:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4367
msgid "Consider the goal:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4386
msgid "where the type of the ``big_prop`` eliminator is"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4397
msgid ""
"Since the pattern for the argument of Pb is not specified, the inferred one "
"is used instead: ``big[_/_]_(i <- _ | _ i) _ i``, and after the "
"introductions, the following goals are generated:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4411
msgid ""
"Note that the pattern matching algorithm instantiated all the variables "
"occurring in the pattern."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4418
#: ../../proof-engine/ssreflect-proof-language.rst:4848
msgid "Interpreting assumptions"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4420
msgid ""
"Interpreting an assumption in the context of a proof consists in applying to "
"it a lemma before generalizing, and/or decomposing this assumption. For "
"instance, with the extensive use of boolean reflection (see section :ref:"
"`views_and_reflection_ssr`.4), it is quite frequent to need to decompose the "
"logical interpretation of (the boolean expression of) a fact, rather than "
"the fact itself. This can be achieved by a combination of ``move : _ => _`` "
"switches, like in the following example, where ``||`` is a notation for the "
"boolean disjunction."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4449
msgid ""
"which transforms the hypothesis ``HPa : P a`` which has been introduced from "
"the initial statement into ``HQa : Q a``. This operation is so common that "
"the tactic shell has specific syntax for it. The following scripts:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4471
msgid "or more directly:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4477
msgid ""
"are equivalent to the former one. The former script shows how to interpret a "
"fact (already in the context), thanks to the discharge tactical (see "
"section :ref:`discharge_ssr`) and the latter, how to interpret the top "
"assumption of a goal. Note that the number of wildcards to be inserted to "
"find the correct application of the view lemma to the hypothesis has been "
"automatically inferred."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4484
msgid ""
"The view mechanism is compatible with the ``case`` tactic and with the "
"equation name generation mechanism (see section :ref:"
"`generation_of_equations_ssr`):"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4505
msgid "This view tactic performs:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4511
msgid ""
"The term on the right of the ``/`` view switch is called a *view lemma*. Any "
"|SSR| term coercing to a product type can be used as a view lemma."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4515
msgid ""
"The examples we have given so far explicitly provide the direction of the "
"translation to be performed. In fact, view lemmas need not to be oriented. "
"The view mechanism is able to detect which application is relevant for the "
"current goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4538
msgid "has the same behavior as the first example above."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4540
msgid ""
"The view mechanism can insert automatically a *view hint* to transform the "
"double implication into the expected simple implication. The last script is "
"in fact equivalent to:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4557
#: ../../proof-engine/ssreflect-proof-language.rst:4829
msgid "Specializing assumptions"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4559
msgid ""
"The special case when the *head symbol* of the view lemma is a wildcard is "
"used to interpret an assumption by *specializing* it. The view mechanism "
"hence offers the possibility to apply a higher-order assumption to some "
"given arguments."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4581
#: ../../proof-engine/ssreflect-proof-language.rst:4963
msgid "Interpreting goals"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4583
msgid ""
"In a similar way, it is also often convenient to changing a goal by turning "
"it into an equivalent proposition. The view mechanism of |SSR| has a special "
"syntax ``apply/`` for combining  in a single tactic simultaneous goal "
"interpretation operations and bookkeeping steps."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4592
msgid ""
"The following example use the ``~~`` prenex notation for boolean negation:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4611
msgid ""
"thus in this case, the tactic ``apply/PQequiv`` is equivalent to ``apply: "
"(iffRL (PQequiv _ _))``, where ``iffRL`` is tha analogue of ``iffRL`` for "
"the converse implication."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4615
msgid ""
"Any |SSR| term whose type coerces to a double implication can be used as a "
"view for goal interpretation."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4618
msgid ""
"Note that the goal interpretation view mechanism supports both ``apply`` and "
"``exact`` tactics. As expected, a goal interpretation view command exact/"
"term should solve the current goal or it will fail."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4624
msgid ""
"Goal interpretation view tactics are *not* compatible with the bookkeeping "
"tactical ``=>`` since this would be redundant with the ``apply: term => _`` "
"construction."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4630
msgid "Boolean reflection"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4632
msgid ""
"In the Calculus of Inductive Constructions, there is an obvious distinction "
"between logical propositions and boolean values. On the one hand, logical "
"propositions are objects of *sort* ``Prop`` which is the carrier of "
"intuitionistic reasoning. Logical connectives in ``Prop`` are *types*, which "
"give precise information on the structure of their proofs; this information "
"is automatically exploited by |Coq| tactics.  For example, |Coq| knows that "
"a proof of ``A \\/ B`` is either a proof of ``A`` or a proof of ``B``.  The "
"tactics ``left`` and ``right`` change the goal ``A \\/ B`` to ``A`` and "
"``B``, respectively; dually, the tactic ``case`` reduces the goal ``A \\/ B "
"=> G`` to two subgoals ``A => G`` and ``B => G``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4644
msgid ""
"On the other hand, bool is an inductive *datatype* with two constructors "
"true and false. Logical connectives on bool are *computable functions*, "
"defined by their truth tables, using case analysis:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4663
msgid "Properties of such connectives are also established using case analysis"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4681
msgid ""
"Once ``b`` is replaced by ``true`` in the first goal and by ``false`` in the "
"second one, the goals reduce by computations to the trivial ``true = true``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4684
msgid ""
"Thus, ``Prop`` and ``bool`` are truly complementary: the former supports "
"robust natural deduction, the latter allows brute-force evaluation. |SSR| "
"supplies a generic mechanism to have the best of the two worlds and move "
"freely from a propositional version of a decidable predicate to its boolean "
"version."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4690
msgid ""
"First, booleans are injected into propositions using the coercion mechanism:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4697
msgid ""
"This allows any boolean formula ``b`` to be used in a context where |Coq| "
"would expect a proposition, e.g., after ``Lemma … : ``. It is then "
"interpreted as ``(is_true b)``, i.e., the proposition ``b = true``. "
"Coercions are elided by the pretty-printer, so they are essentially "
"transparent to the user."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4704
msgid "The reflect predicate"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4706
msgid ""
"To get all the benefits of the boolean reflection, it is in fact convenient "
"to introduce the following inductive predicate ``reflect`` to relate "
"propositions and booleans:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4716
msgid ""
"The statement ``(reflect P b)`` asserts that ``(is_true b)`` and ``P`` are "
"logically equivalent propositions."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4719
msgid "For instance, the following lemma:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4725
msgid ""
"relates the boolean conjunction to the logical one ``/\\``. Note that in "
"``andP``, ``b1`` and ``b2`` are two boolean variables and the proposition "
"``b1 /\\ b2`` hides two coercions. The conjunction of ``b1`` and ``b2`` can "
"then be viewed as ``b1 /\\ b2`` or as ``b1 && b2``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4730
msgid ""
"Expressing logical equivalences through this family of inductive types makes "
"possible to take benefit from *rewritable equations* associated to the case "
"analysis of |Coq|’s inductive types."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4734
msgid "Since the equivalence predicate is defined in |Coq| as:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4740
msgid "where ``/\\`` is a notation for ``and``:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4746
msgid ""
"This make case analysis very different according to the way an equivalence "
"property has been defined."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4753
msgid "Let us compare the respective behaviors of ``andE`` and ``andP``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4779
msgid ""
"Expressing reflection relation through the ``reflect`` predicate is hence a "
"very convenient way to deal with classical reasoning, by case analysis. "
"Using the ``reflect`` predicate allows moreover to program rich "
"specifications inside its two constructors, which will be automatically "
"taken into account during destruction. This formalisation style gives far "
"more efficient specifications than quantified (double) implications."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4787
msgid ""
"A naming convention in |SSR| is to postfix the name of view lemmas with "
"``P``. For example, ``orP`` relates ``||`` and ``\\/``, ``negP`` relates "
"``~~`` and ``~``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4791
msgid "The view mechanism is compatible with reflect predicates."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4808
msgid "Conversely"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4819
msgid ""
"The same tactics can also be used to perform the converse operation, "
"changing a boolean conjunction into a logical one. The view mechanism "
"guesses the direction of the transformation to be used i.e., the constructor "
"of the reflect predicate which should be chosen."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4826
msgid "General mechanism for interpreting goals and assumptions"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4831
msgid "The |SSR| tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4837
msgid "is equivalent to the tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4843
msgid ""
"where ``top`` is a fresh name for introducing the top assumption of the "
"current goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4850
msgid "The general form of an assumption view tactic is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4854
msgid "The term , called the *view lemma* can be:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4857
msgid "a (term coercible to a) function;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4858
msgid "a (possibly quantified) implication;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4859
msgid "a (possibly quantified) double implication;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4860
msgid ""
"a (possibly quantified) instance of the reflect predicate (see section :ref:"
"`views_and_reflection_ssr`)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4864
msgid "Let ``top`` be the top assumption in the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4866
msgid "There are three steps in the behavior of an assumption view tactic:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4868
msgid "It first introduces ``top``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4869
msgid ""
"If the type of :token:`term` is neither a double implication nor an instance "
"of the reflect predicate, then the tactic automatically generalises a term "
"of the form: ``term term1 … termn`` where the terms ``term1 … termn`` "
"instantiate the possible quantified variables of ``term`` , in order for "
"``(term term1 … termn top)`` to be well typed."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4874
msgid ""
"If the type of ``term`` is an equivalence, or an instance of the reflect "
"predicate, it generalises a term of the form: ``(termvh (term term1 … "
"termn ))`` where the term ``termvh`` inserted is called an *assumption "
"interpretation view hint*."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4879
msgid "It finally clears top."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4882
msgid ""
"For a ``case/term`` tactic, the generalisation step is replaced by a case "
"analysis step."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4885
msgid ""
"*View hints* are declared by the user (see section:ref:"
"`views_and_reflection_ssr`.8) and are stored in the Hint View database. The "
"proof engine automatically detects from the shape of the top assumption "
"``top`` and of the view lemma ``term`` provided to the tactic the "
"appropriate view hint in the database to be inserted."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4891
msgid ""
"If ``term`` is a double implication, then the view hint will be one of the "
"defined view hints for implication. These hints are by default the ones "
"present in the file ``ssreflect.v``:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4899
msgid "which transforms a double implication into the left-to-right one, or:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4905
msgid ""
"which produces the converse implication. In both cases, the two first Prop "
"arguments are implicit."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4908
msgid ""
"If ``term`` is an instance of the ``reflect`` predicate, then ``A`` will be "
"one of the defined view hints for the ``reflec``t predicate, which are by "
"default the ones present in the file ``ssrbool.v``. These hints are not only "
"used for choosing the appropriate direction of the translation, but they "
"also allow complex transformation, involving negations."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4933
msgid ""
"In fact this last script does not exactly use the hint ``introN``, but the "
"more general hint:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4941
msgid "The lemma ` `introN`` is an instantiation of introNF using c := true."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4943
msgid ""
"Note that views, being part of :token:`i_pattern`, can be used to interpret "
"assertions too. For example the following script asserts ``a && b`` but "
"actually uses its propositional interpretation."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4965
msgid "A goal interpretation view tactic of the form:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4969
msgid "applied to a goal ``top`` is interpreted in the following way:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4971
msgid ""
"If the type of ``term`` is not an instance of the ``reflect`` predicate, nor "
"an equivalence, then the term ``term`` is applied to the current goal "
"``top``, possibly inserting implicit arguments."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4974
msgid ""
"If the type of ``term`` is an instance of the reflect predicate or an "
"equivalence, then a *goal interpretation view hint* can possibly be "
"inserted, which corresponds to the application of a term ``(termvh (term _ … "
"_))`` to the current goal, possibly inserting implicit arguments."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4980
msgid ""
"Like assumption interpretation view hints, goal interpretation ones are user-"
"defined lemmas stored (see section :ref:`views_and_reflection_ssr`) in the "
"``Hint View`` database bridging the possible gap between the type of "
"``term`` and the type of the goal."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4987
msgid "Interpreting equivalences"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4989
msgid ""
"Equivalent boolean propositions are simply *equal* boolean terms. A special "
"construction helps the user to prove boolean equalities by considering them "
"as logical double implications (between their coerced versions), while "
"performing at the same time logical operations on both sides."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4995
msgid "The syntax of double views is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:4999
msgid ""
"The first term is the view lemma applied to the left hand side of the "
"equality, while the second term is the one applied to the right hand side."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5002
msgid ""
"In this context, the identity view can be used when no view has to be "
"applied:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5023
msgid ""
"The same goal can be decomposed in several ways, and the user may choose the "
"most convenient interpretation."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5043
msgid "Declaring new Hint Views"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5045
msgid ""
"The database of hints for the view mechanism is extensible via a dedicated "
"vernacular command. As library ``ssrbool.v`` already declares a corpus of "
"hints, this feature is probably useful only for users who define their own "
"logical connectives. Users can declare their own hints following the syntax "
"used in ``ssrbool.v``:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5054
msgid ""
"The :token:`ident` is the name of the lemma to be declared as a hint. If "
"`move` is used as tactic, the hint is declared for assumption interpretation "
"tactics, `apply` declares hints for goal interpretations. Goal "
"interpretation view hints are declared for both simple views and left hand "
"side views. The optional natural number is the number of implicit arguments "
"to be considered for the declared hint view lemma."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5062
msgid "The command:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5066
msgid ""
"with a double slash ``//``, declares hint views for right hand sides of "
"double views."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5069
msgid "See the files ``ssreflect.v`` and ``ssrbool.v`` for examples."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5073
msgid "Multiple views"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5075
msgid ""
"The hypotheses and the goal can be interpreted by applying multiple views in "
"sequence. Both move and apply can be followed by an arbitrary number of ``/"
"term``. The main difference between the following two tactics"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5085
msgid ""
"is that the former applies all the views to the principal goal. Applying a "
"view with hypotheses generates new goals, and the second line would apply "
"the view ``v2`` to all the goals generated by ``apply/v1``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5089
msgid ""
"Note that the NO-OP intro pattern ``-`` can be used to separate two views, "
"making the two following examples equivalent:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5097
msgid ""
"The tactic ``move`` can be used together with the ``in`` tactical to pass a "
"given hypothesis to a lemma."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5120
msgid ""
"If the list of views is of length two, ``Hint Views`` for interpreting "
"equivalences are indeed taken into account, otherwise only single ``Hint "
"Views`` are used."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5126
msgid "|SSR| searching tool"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5128
msgid "|SSR| proposes an extension of the Search command. Its syntax is:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5133
msgid ""
"where :token:`qualid` is the name of an open module. This command returns "
"the list of lemmas:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5137
msgid ""
"whose *conclusion* contains a subterm matching the optional first pattern. A "
"- reverses the test, producing the list of lemmas whose conclusion does not "
"contain any subterm matching the pattern;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5140
msgid ""
"whose name contains the given string. A ``-`` prefix reverses the test, "
"producing the list of lemmas whose name does not contain the string. A "
"string that contains symbols or is followed by a scope key, is interpreted "
"as the constant whose notation involves that string (e.g., `+` for `addn`), "
"if this is unambiguous; otherwise the diagnostic includes the output of the "
"``Locate`` vernacular command."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5146
msgid ""
"whose statement, including assumptions and types, contains a subterm "
"matching the next patterns. If a pattern is prefixed by ``-``, the test is "
"reversed;"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5149
msgid ""
"contained in the given list of modules, except the ones in the modules "
"prefixed by a ``-``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5153
msgid "Note that:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5156
msgid ""
"As for regular terms, patterns can feature scope indications. For instance, "
"the command: ``Search _ (_ + _)%N.`` lists all the lemmas whose statement "
"(conclusion or hypotheses) involves an application of the binary operation "
"denoted by the infix ``+`` symbol in the ``N`` scope (which is |SSR| scope "
"for natural numbers)."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5161
msgid "Patterns with holes should be surrounded by parentheses."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5162
msgid ""
"Search always volunteers the expansion of the notation, avoiding the need to "
"execute Locate independently. Moreover, a string fragment looks for any "
"notation that contains fragment as a substring. If the ``ssrbool.v`` library "
"is imported, the command: ``Search \"~~\".`` answers :"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5180
msgid ""
"A diagnostic is issued if there are different matching notations; it is an "
"error if all matches are partial."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5182
msgid ""
"Similarly, a diagnostic warns about multiple interpretations, and signals an "
"error if there is no default one."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5184
msgid ""
"The command ``Search in M.`` is a way of obtaining the complete signature of "
"the module ``M``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5186
msgid ""
"Strings and pattern indications can be interleaved, but the first indication "
"has a special status if it is a pattern, and only filters the conclusion of "
"lemmas:"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5190
msgid ""
"The command : ``Search (_ =1 _) \"bij\".`` lists all the lemmas whose "
"conclusion features a ``=1`` and whose name contains the string ``bij``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5192
msgid ""
"The command : ``Search \"bij\" (_ =1 _).`` lists all the lemmas whose "
"statement, including hypotheses, features a ``=1`` and whose name contains "
"the string ``bij``."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5197
msgid "Synopsis and Index"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5200
msgid "Parameters"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5202
msgid "|SSR| tactics"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5207
msgid "Notation scope"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5211
msgid "Module name"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5215
msgid "Natural number"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5219
msgid ""
"where :token:`ident` is an Ltac variable denoting a standard |Coq| numeral "
"(should not be the name of a tactic which can be followed by a bracket "
"``[``, like ``do``, ``have``,…)"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5224
msgid "Items and switches"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5228
msgid "binder see :ref:`abbreviations_ssr`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5232
msgid "clear switch see :ref:`discharge_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5236
msgid "context pattern see :ref:`contextual_patterns_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5240
msgid "discharge item see :ref:`discharge_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5244
msgid "generalization item see :ref:`structure_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5248
msgid "intro pattern :ref:`introduction_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5252
msgid "intro item  see :ref:`introduction_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5256
msgid "multiplier  see :ref:`iteration_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5260
msgid "occur. switch see :ref:`occurrence_selection_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5264
msgid "multiplier see :ref:`iteration_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5268
msgid "multiplier mark see :ref:`iteration_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5272
msgid "rewrite item see :ref:`rewriting_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5276
msgid "rewrite prefix see :ref:`rewriting_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5280
msgid "rewrite pattern see :ref:`rewriting_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5284
msgid "rewrite step see :ref:`rewriting_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5288
msgid "simplify switch see :ref:`introduction_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5291
#: ../../proof-engine/tactics.rst:4
msgid "Tactics"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5293
msgid ""
"*Note*: ``without loss`` and ``suffices`` are synonyms for ``wlog`` and "
"``suff`` respectively."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5298
msgid "idtac or hnf see  :ref:`bookkeeping_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5303
msgid "application see :ref:`the_defective_tactics_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5307
msgid "see :ref:`abstract_ssr` and :ref:`generating_let_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5311
msgid "induction see :ref:`the_defective_tactics_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5315
msgid "case analysis see :ref:`the_defective_tactics_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5319
msgid "rewrite  see :ref:`rewriting_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5329
msgid "forward  chaining see :ref:`structure_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5334
msgid "specializing see :ref:`structure_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5343
msgid "backchaining see :ref:`structure_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5347
msgid "local definition :ref:`definitions_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5351
msgid "local function definition"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5355
msgid "local fix definition"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5359
msgid "local cofix definition"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5363
msgid "abbreviation see :ref:`abbreviations_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5367
msgid "unlock see :ref:`locking_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5371
msgid "congruence :ref:`congruence_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5375
msgid "Tacticals"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5379
msgid "discharge :ref:`discharge_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5383
msgid "introduction see :ref:`introduction_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5387
msgid "localization see :ref:`localization_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5391
msgid "iteration  see :ref:`iteration_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5395
msgid "selector  see :ref:`selectors_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5399
msgid "rotation see :ref:`selectors_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5403
msgid "closing see :ref:`terminators_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5406
msgid "Commands"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5410
msgid "view hint declaration see :ref:`declaring_new_hints_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5414
msgid ""
"right hand side double , view hint declaration see :ref:"
"`declaring_new_hints_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5418
msgid "prenex implicits declaration see :ref:`parametric_polymorphism_ssr`"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5421
msgid "Footnotes"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5422
msgid ""
"Unfortunately, even after a call to the Set Printing All command, some "
"occurrences are still not displayed to the user, essentially the ones "
"possibly hidden in the predicate of a dependent match structure."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5425
msgid ""
"Thus scripts that depend on bound variable names, e.g., via intros or with, "
"are inherently fragile."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5427
msgid ""
"The name ``subnK`` reads as “right cancellation rule for nat subtraction”."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5429
msgid ""
"Also, a slightly different variant may be used for the first :token:`d_item` "
"of case and elim; see section :ref:`type_families_ssr`."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5431
msgid ""
"Except /= does not expand the local definitions created by the |SSR| in "
"tactical."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5433
msgid ""
"|SSR| reserves all identifiers of the form “_x_”, which is used for such "
"generated names."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5435
msgid ""
"More precisely, it should have a quantified inductive type with a "
"assumptions and m − a constructors."
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5437
msgid ""
"This is an implementation feature: there is no such obstruction in the "
"metatheory"
msgstr ""

#: ../../proof-engine/ssreflect-proof-language.rst:5439
msgid ""
"The current state of the proof shall be displayed by the Show Proof command "
"of |Coq| proof mode."
msgstr ""

#: ../../proof-engine/tactics.rst:6
msgid ""
"A deduction rule is a link between some (unique) formula, that we call the "
"*conclusion* and (several) formulas that we call the *premises*. A deduction "
"rule can be read in two ways. The first one says: “if I know this and this "
"then I can deduce this”. For instance, if I have a proof of A and a proof of "
"B then I have a proof of A ∧ B. This is forward reasoning from premises to "
"conclusion. The other way says: “to prove this I have to prove this and "
"this”. For instance, to prove A ∧ B, I have to prove A and I have to prove "
"B. This is backward reasoning from conclusion to premises. We say that the "
"conclusion is the *goal* to prove and premises are the *subgoals*. The "
"tactics implement *backward reasoning*. When applied to a goal, a tactic "
"replaces this goal with the subgoals it generates. We say that a tactic "
"reduces a goal to its subgoal(s)."
msgstr ""

#: ../../proof-engine/tactics.rst:20
msgid ""
"Each (sub)goal is denoted with a number. The current goal is numbered 1. By "
"default, a tactic is applied to the current goal, but one can address a "
"particular goal in the list by writing n:tactic which means “apply tactic "
"tactic to goal number n”. We can show the list of subgoals by typing Show "
"(see Section :ref:`requestinginformation`)."
msgstr ""

#: ../../proof-engine/tactics.rst:26
msgid ""
"Since not every rule applies to a given statement, not every tactic can be "
"used to reduce a given goal. In other words, before applying a tactic to a "
"given goal, the system checks that some *preconditions* are satisfied. If it "
"is not the case, the tactic raises an error message."
msgstr ""

#: ../../proof-engine/tactics.rst:31
msgid ""
"Tactics are built from atomic tactics and tactic expressions (which extends "
"the folklore notion of tactical) to combine those atomic tactics. This "
"chapter is devoted to atomic tactics. The tactic language will be described "
"in Chapter :ref:`ltac`."
msgstr ""

#: ../../proof-engine/tactics.rst:39
msgid "Invocation of tactics"
msgstr ""

#: ../../proof-engine/tactics.rst:41
msgid ""
"A tactic is applied as an ordinary command. It may be preceded by a goal "
"selector (see Section :ref:`ltac-semantics`). If no selector is specified, "
"the default selector is used."
msgstr ""

#: ../../proof-engine/tactics.rst:54
msgid ""
"This option controls the default selector – used when no selector is "
"specified when applying a tactic – is set to the chosen value. The initial "
"value is 1, hence the tactics are, by default, applied to the first goal. "
"Using value ``all`` will make is so that tactics are, by default, applied to "
"every goal simultaneously. Then, to apply a tactic tac to the first goal "
"only, you can write ``1:tac``. Although more selectors are available, only "
"``all`` or a single natural number are valid default goal selectors."
msgstr ""

#: ../../proof-engine/tactics.rst:65
msgid "Bindings list"
msgstr ""

#: ../../proof-engine/tactics.rst:67
msgid ""
"Tactics that take a term as argument may also support a bindings list, so as "
"to instantiate some parameters of the term by name or position. The general "
"form of a term equipped with a bindings list is ``term with bindings_list`` "
"where ``bindings_list`` may be of two different forms:"
msgstr ""

#: ../../proof-engine/tactics.rst:78
msgid ""
"In a bindings list of the form :n:`{* (ref:= term)}`, :n:`ref` is either an :"
"n:`@ident` or a :n:`@num`. The references are determined according to the "
"type of ``term``. If :n:`ref` is an identifier, this identifier has to be "
"bound in the type of ``term`` and the binding provides the tactic with an "
"instance for the parameter of this name. If :n:`ref` is some number ``n``, "
"this number denotes the ``n``-th non dependent premise of the ``term``, as "
"determined by the type of ``term``."
msgstr ""

#: ../../proof-engine/tactics.rst:88
msgid ""
"A bindings list can also be a simple list of terms :n:`{* term}`. In that "
"case the references to which these terms correspond are determined by the "
"tactic. In case of :tacn:`induction`, :tacn:`destruct`, :tacn:`elim` and :"
"tacn:`case`, the terms have to provide instances for all the dependent "
"products in the type of term while in the case of :tacn:`apply`, or of :tacn:"
"`constructor` and its variants, only instances for the dependent products "
"that are not bound in the conclusion of the type are required."
msgstr ""

#: ../../proof-engine/tactics.rst:102
msgid "Occurrence sets and occurrence clauses"
msgstr ""

#: ../../proof-engine/tactics.rst:104
msgid ""
"An occurrence clause is a modifier to some tactics that obeys the following "
"syntax:"
msgstr ""

#: ../../proof-engine/tactics.rst:115
msgid ""
"The role of an occurrence clause is to select a set of occurrences of a term "
"in a goal. In the first case, the :n:`@ident {? at {* num}}` parts indicate "
"that occurrences have to be selected in the hypotheses named :token:`ident`. "
"If no numbers are given for hypothesis :token:`ident`, then all the "
"occurrences of :token:`term` in the hypothesis are selected. If numbers are "
"given, they refer to occurrences of :token:`term` when the term is printed "
"using option :flag:`Printing All`, counting from left to right. In "
"particular, occurrences of :token:`term` in implicit arguments (see :ref:"
"`ImplicitArguments`) or coercions (see :ref:`Coercions`) are counted."
msgstr ""

#: ../../proof-engine/tactics.rst:126
msgid ""
"If a minus sign is given between ``at`` and the list of occurrences, it "
"negates the condition so that the clause denotes all the occurrences except "
"the ones explicitly mentioned after the minus sign."
msgstr ""

#: ../../proof-engine/tactics.rst:130
msgid ""
"As an exception to the left-to-right order, the occurrences in the return "
"subexpression of a match are considered *before* the occurrences in the "
"matched term."
msgstr ""

#: ../../proof-engine/tactics.rst:134
msgid ""
"In the second case, the ``*`` on the left of ``|-`` means that all "
"occurrences of term are selected in every hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:137
msgid ""
"In the first and second case, if ``*`` is mentioned on the right of ``|-``, "
"the occurrences of the conclusion of the goal have to be selected. If some "
"numbers are given, then only the occurrences denoted by these numbers are "
"selected. If no numbers are given, all occurrences of :token:`term` in the "
"goal are selected."
msgstr ""

#: ../../proof-engine/tactics.rst:142
msgid ""
"Finally, the last notation is an abbreviation for ``* |- *``. Note also that "
"``|-`` is optional in the first case when no ``*`` is given."
msgstr ""

#: ../../proof-engine/tactics.rst:145
msgid ""
"Here are some tactics that understand occurrence clauses: :tacn:`set`, :tacn:"
"`remember`, :tacn:`induction`, :tacn:`destruct`."
msgstr ""

#: ../../proof-engine/tactics.rst:151
msgid ""
":ref:`Managingthelocalcontext`, :ref:`caseanalysisandinduction`, :ref:"
"`printing_constructions_full`."
msgstr ""

#: ../../proof-engine/tactics.rst:158
msgid "Applying theorems"
msgstr ""

#: ../../proof-engine/tactics.rst:163
msgid ""
"This tactic applies to any goal. It gives directly the exact proof term of "
"the goal. Let ``T`` be our goal, let ``p`` be a term of type ``U`` then "
"``exact p`` succeeds iff ``T`` and ``U`` are convertible (see :ref:"
"`Conversion-rules`)."
msgstr ""

#: ../../proof-engine/tactics.rst:174
msgid ""
"This tactic behaves like :tacn:`exact` but is able to handle terms and goals "
"with existential variables."
msgstr ""

#: ../../proof-engine/tactics.rst:180
msgid ""
"This tactic looks in the local context for a hypothesis whose type is "
"convertible to the goal. If it is the case, the subgoal is proved. "
"Otherwise, it fails."
msgstr ""

#: ../../proof-engine/tactics.rst:190
msgid ""
"This tactic behaves like :tacn:`assumption` but is able to handle goals with "
"existential variables."
msgstr ""

#: ../../proof-engine/tactics.rst:196
msgid ""
"This tactic applies to any goal. It behaves like :tacn:`exact` with a big "
"difference: the user can leave some holes (denoted by ``_`` or :n:`(_ : "
"@type)`) in the term. :tacn:`refine` will generate as many subgoals as there "
"are holes in the term. The type of holes must be either synthesized by the "
"system or declared by an explicit cast like ``(_ : nat -> Prop)``. Any "
"subgoal that occurs in other subgoals is automatically shelved, as if "
"calling :tacn:`shelve_unifiable`. This low-level tactic can be useful to "
"advanced users."
msgstr ""

#: ../../proof-engine/tactics.rst:226
msgid ""
"The tactic :tacn:`refine` does not know what to do with the term you gave."
msgstr ""

#: ../../proof-engine/tactics.rst:230
msgid ""
"The term you gave is not a valid proof (not easy to debug in general). This "
"message may also occur in higher-level tactics that call :tacn:`refine` "
"internally."
msgstr ""

#: ../../proof-engine/tactics.rst:237
msgid ""
"There is a hole in the term you gave whose type cannot be inferred. Put a "
"cast around it."
msgstr ""

#: ../../proof-engine/tactics.rst:243
msgid ""
"This tactic behaves like refine, but it does not shelve any subgoal. It does "
"not perform any beta-reduction either."
msgstr ""

#: ../../proof-engine/tactics.rst:249
msgid ""
"This tactic behaves like :tacn:`refine` except it performs type checking "
"without resolution of typeclasses."
msgstr ""

#: ../../proof-engine/tactics.rst:255
msgid ""
"This tactic behaves like :tacn:`simple refine` except it performs type "
"checking without resolution of typeclasses."
msgstr ""

#: ../../proof-engine/tactics.rst:261
msgid ""
"This tactic applies to any goal. The argument term is a term well-formed in "
"the local context. The tactic :tacn:`apply` tries to match the current goal "
"against the conclusion of the type of :token:`term`. If it succeeds, then "
"the tactic returns as many subgoals as the number of non-dependent premises "
"of the type of term. If the conclusion of the type of :token:`term` does not "
"match the goal *and* the conclusion is an inductive type isomorphic to a "
"tuple type, then each component of the tuple is recursively matched to the "
"goal in the left-to-right order."
msgstr ""

#: ../../proof-engine/tactics.rst:270
msgid ""
"The tactic :tacn:`apply` relies on first-order unification with dependent "
"types unless the conclusion of the type of :token:`term` is of the form :n:"
"`P (t__1 ... t__n)` with ``P`` to be instantiated. In the latter case, the "
"behavior depends on the form of the goal. If the goal is of the form :n:"
"`(fun x => Q) u__1 ... u__n` and the :n:`t__i` and :n:`u__i` unify, then :g:"
"`P` is taken to be :g:`(fun x => Q)`. Otherwise, :tacn:`apply` tries to "
"define :g:`P` by abstracting over :g:`t_1 ... t__n` in the goal. See :tacn:"
"`pattern` to transform the goal so that it gets the form :n:`(fun x => Q) "
"u__1 ... u__n`."
msgstr ""

#: ../../proof-engine/tactics.rst:282
msgid ""
"The :tacn:`apply` tactic failed to match the conclusion of :token:`term` and "
"the current goal. You can help the :tacn:`apply` tactic by transforming your "
"goal with the :tacn:`change` or :tacn:`pattern` tactics."
msgstr ""

#: ../../proof-engine/tactics.rst:289
msgid ""
"This occurs when some instantiations of the premises of :token:`term` are "
"not deducible from the unification. This is the case, for instance, when you "
"want to apply a transitivity property. In this case, you have to use one of "
"the variants below:"
msgstr ""

#: ../../proof-engine/tactics.rst:295
msgid ""
"Provides apply with explicit instantiations for all dependent premises of "
"the type of term that do not occur in the conclusion and consequently cannot "
"be found by unification. Notice that the collection :n:`{+ @term}` must be "
"given according to the order of these dependent premises of the type of term."
msgstr ""

#: ../../proof-engine/tactics.rst:305
msgid ""
"This also provides apply with values for instantiating premises. Here, "
"variables are referred by names and non-dependent products by increasing "
"numbers (see :ref:`bindings list <bindingslist>`)."
msgstr ""

#: ../../proof-engine/tactics.rst:311
msgid ""
"This is a shortcut for :n:`apply @term__1; [.. | ... ; [ .. | apply "
"@term__n] ... ]`, i.e. for the successive applications of :n:`@term`:sub:`i"
"+1` on the last subgoal generated by :n:`apply @term__i` , starting from the "
"application of :n:`@term__1`."
msgstr ""

#: ../../proof-engine/tactics.rst:318
msgid ""
"The tactic :tacn:`eapply` behaves like :tacn:`apply` but it does not fail "
"when no instantiations are deducible for some variables in the premises. "
"Rather, it turns these variables into existential variables which are "
"variables still to instantiate (see :ref:`Existential-Variables`). The "
"instantiation is intended to be found later in the proof."
msgstr ""

#: ../../proof-engine/tactics.rst:326
msgid ""
"This behaves like :tacn:`apply` but it reasons modulo conversion only on "
"subterms that contain no variables to instantiate. For instance, the "
"following example does not succeed because it would require the conversion "
"of ``id ?foo`` and :g:`O`."
msgstr ""

#: ../../proof-engine/tactics.rst:340
msgid ""
"Because it reasons modulo a limited amount of conversion, :tacn:`simple "
"apply` fails quicker than :tacn:`apply` and it is then well-suited for uses "
"in user-defined tactics that backtrack often. Moreover, it does not traverse "
"tuples as :tacn:`apply` does."
msgstr ""

#: ../../proof-engine/tactics.rst:349
msgid ""
"This summarizes the different syntaxes for :tacn:`apply` and :tacn:`eapply`."
msgstr ""

#: ../../proof-engine/tactics.rst:354
msgid ""
"This tactic applies to any goal, say :g:`G`. The argument term has to be "
"well-formed in the current context, its type being reducible to a non-"
"dependent product :g:`A -> B` with :g:`B` possibly containing products. Then "
"it generates two subgoals :g:`B->G` and :g:`A`. Applying ``lapply H`` "
"(where :g:`H` has type :g:`A->B` and :g:`B` does not start with a product) "
"does the same as giving the sequence ``cut B. 2:apply H.`` where ``cut`` is "
"described below."
msgstr ""

#: ../../proof-engine/tactics.rst:366
msgid "Assume we have a transitive relation ``R`` on ``nat``:"
msgstr ""

#: ../../proof-engine/tactics.rst:380
msgid "Consider the goal ``(R n p)`` provable using the transitivity of ``R``:"
msgstr ""

#: ../../proof-engine/tactics.rst:386
msgid ""
"The direct application of ``Rtrans`` with ``apply`` fails because no value "
"for ``y`` in ``Rtrans`` is found by ``apply``:"
msgstr ""

#: ../../proof-engine/tactics.rst:393
msgid "A solution is to ``apply (Rtrans n m p)`` or ``(Rtrans n m)``."
msgstr ""

#: ../../proof-engine/tactics.rst:399
msgid ""
"Note that ``n`` can be inferred from the goal, so the following would work "
"too."
msgstr ""

#: ../../proof-engine/tactics.rst:406
msgid ""
"More elegantly, ``apply Rtrans with (y:=m)`` allows only mentioning the "
"unknown m:"
msgstr ""

#: ../../proof-engine/tactics.rst:413
msgid "Another solution is to mention the proof of ``(R x y)`` in ``Rtrans``"
msgstr ""

#: ../../proof-engine/tactics.rst:419
msgid "... or the proof of ``(R y z)``."
msgstr ""

#: ../../proof-engine/tactics.rst:425
msgid ""
"On the opposite, one can use ``eapply`` which postpones the problem of "
"finding ``m``. Then one can apply the hypotheses ``Rnm`` and ``Rmp``. This "
"instantiates the existential variable and completes the proof."
msgstr ""

#: ../../proof-engine/tactics.rst:438
msgid ""
"When the conclusion of the type of the term to ``apply`` is an inductive "
"type isomorphic to a tuple type and ``apply`` looks recursively whether a "
"component of the tuple matches the goal, it excludes components whose "
"statement would result in applying an universal lemma of the form ``forall "
"A, ... -> A``. Excluding this kind of lemma can be avoided by setting the "
"following option:"
msgstr ""

#: ../../proof-engine/tactics.rst:447
msgid ""
"This option, which preserves compatibility with versions of Coq prior to 8.4 "
"is also available for :n:`apply @term in @ident` (see :tacn:`apply ... in`)."
msgstr ""

#: ../../proof-engine/tactics.rst:453
msgid ""
"This tactic applies to any goal. The argument :token:`term` is a term well-"
"formed in the local context and the argument :token:`ident` is an hypothesis "
"of the context. The tactic :n:`apply @term in @ident` tries to match the "
"conclusion of the type of :token:`ident` against a non-dependent premise of "
"the type of :token:`term`, trying them from right to left. If it succeeds, "
"the statement of hypothesis :token:`ident` is replaced by the conclusion of "
"the type of :token:`term`. The tactic also returns as many subgoals as the "
"number of other non-dependent premises in the type of :token:`term` and of "
"the non-dependent premises of the type of :token:`ident`. If the conclusion "
"of the type of :token:`term` does not match the goal *and* the conclusion is "
"an inductive type isomorphic to a tuple type, then the tuple is "
"(recursively) decomposed and the first component of the tuple of which a non-"
"dependent premise matches the conclusion of the type of :token:`ident`. "
"Tuples are decomposed in a width-first left-to-right order (for instance if "
"the type of :g:`H1` is :g:`A <-> B` and the type of :g:`H2` is :g:`A` then :"
"g:`apply H1 in H2` transforms the type of :g:`H2` into :g:`B`). The tactic :"
"tacn:`apply` relies on first-order pattern matching with dependent types."
msgstr ""

#: ../../proof-engine/tactics.rst:475
msgid "This happens if the type of :token:`term` has no non-dependent premise."
msgstr ""

#: ../../proof-engine/tactics.rst:479
msgid ""
"This happens if the conclusion of :token:`ident` does not match any of the "
"non-dependent premises of the type of :token:`term`."
msgstr ""

#: ../../proof-engine/tactics.rst:484
msgid "This applies each :token:`term` in sequence in :token:`ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:488
msgid ""
"This does the same but uses the bindings in each :n:`(@ident := @term)` to "
"instantiate the parameters of the corresponding type of :token:`term` (see :"
"ref:`bindings list <bindingslist>`)."
msgstr ""

#: ../../proof-engine/tactics.rst:494
msgid ""
"This works as :tacn:`apply ... in` but turns unresolved bindings into "
"existential variables, if any, instead of failing."
msgstr ""

#: ../../proof-engine/tactics.rst:500
msgid ""
"This works as :tacn:`apply ... in` then applies the :token:`intro_pattern` "
"to the hypothesis :token:`ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:505
msgid ""
"This behaves like :tacn:`apply ... in` but it reasons modulo conversion only "
"on subterms that contain no variables to instantiate. For instance, if :g:"
"`id := fun x:nat => x` and :g:`H: forall y, id y = y -> True` and :g:`H0 : O "
"= O` then :g:`simple apply H in H0` does not succeed because it would "
"require the conversion of :g:`id ?x` and :g:`O` where :g:`?x` is an "
"existential variable to instantiate. Tactic :n:`simple apply @term in "
"@ident` does not either traverse tuples as :n:`apply @term in @ident` does."
msgstr ""

#: ../../proof-engine/tactics.rst:517
msgid ""
"This summarizes the different syntactic variants of :n:`apply @term in "
"@ident` and :n:`eapply @term in @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:523
msgid ""
"This tactic applies to a goal such that its conclusion is an inductive type "
"(say :g:`I`). The argument :token:`num` must be less or equal to the numbers "
"of constructor(s) of :g:`I`. Let :n:`c__i` be the i-th constructor of :g:"
"`I`, then :g:`constructor i` is equivalent to :n:`intros; apply c__i`."
msgstr ""

#: ../../proof-engine/tactics.rst:537
msgid ""
"This tries :g:`constructor 1` then :g:`constructor 2`, ..., then :g:"
"`constructor n` where ``n`` is the number of constructors of the head of the "
"goal."
msgstr ""

#: ../../proof-engine/tactics.rst:543
msgid ""
"Let ``c`` be the i-th constructor of :g:`I`, then :n:`constructor i with "
"@bindings_list` is equivalent to :n:`intros; apply c with @bindings_list`."
msgstr ""

#: ../../proof-engine/tactics.rst:549
msgid ""
"The terms in the :token:`bindings_list` are checked in the context where "
"constructor is executed and not in the context where :tacn:`apply` is "
"executed (the introductions are not taken into account)."
msgstr ""

#: ../../proof-engine/tactics.rst:556
msgid ""
"This applies only if :g:`I` has a single constructor. It is then equivalent "
"to :n:`constructor 1 {? with @bindings_list }`. It is typically used in the "
"case of a conjunction :math:`A \\wedge B`."
msgstr ""

#: ../../proof-engine/tactics.rst:563
msgid ""
"This applies only if :g:`I` has a single constructor. It is then equivalent "
"to :n:`intros; constructor 1 with @bindings_list.` It is typically used in "
"the case of an existential quantification :math:`\\exists x, P(x).`"
msgstr ""

#: ../../proof-engine/tactics.rst:569
msgid "This iteratively applies :n:`exists @bindings_list`."
msgstr ""

#: ../../proof-engine/tactics.rst:578
msgid ""
"These tactics apply only if :g:`I` has two constructors, for instance in the "
"case of a disjunction :math:`A \\vee B`. Then, they are respectively "
"equivalent to :n:`constructor 1 {? with @bindings_list }` and :n:"
"`constructor 2 {? with @bindings_list }`."
msgstr ""

#: ../../proof-engine/tactics.rst:593
msgid ""
"These tactics and their variants behave like :tacn:`constructor`, :tacn:"
"`exists`, :tacn:`split`, :tacn:`left`, :tacn:`right` and their variants but "
"they introduce existential variables instead of failing when the "
"instantiation of a variable cannot be found (cf. :tacn:`eapply` and :tacn:"
"`apply`)."
msgstr ""

#: ../../proof-engine/tactics.rst:603
msgid "Managing the local context"
msgstr ""

#: ../../proof-engine/tactics.rst:608
msgid ""
"This tactic applies to a goal that is either a product or starts with a let-"
"binder. If the goal is a product, the tactic implements the \"Lam\" rule "
"given in :ref:`Typing-rules` [1]_. If the goal starts with a let-binder, "
"then the tactic implements a mix of the \"Let\" and \"Conv\"."
msgstr ""

#: ../../proof-engine/tactics.rst:613
msgid ""
"If the current goal is a dependent product :g:`forall x:T, U` (resp :g:`let "
"x:=t in U`) then :tacn:`intro` puts :g:`x:T` (resp :g:`x:=t`) in the local "
"context. The new subgoal is :g:`U`."
msgstr ""

#: ../../proof-engine/tactics.rst:617
msgid ""
"If the goal is a non-dependent product :math:`T \\rightarrow U`, then it "
"puts in the local context either :g:`Hn:T` (if :g:`T` is of type :g:`Set` "
"or :g:`Prop`) or :g:`Xn:T` (if the type of :g:`T` is :g:`Type`). The "
"optional index ``n`` is such that ``Hn`` or ``Xn`` is a fresh identifier. In "
"both cases, the new subgoal is :g:`U`."
msgstr ""

#: ../../proof-engine/tactics.rst:623
msgid ""
"If the goal is neither a product nor starting with a let definition, the "
"tactic :tacn:`intro` applies the tactic :tacn:`hnf` until the tactic :tacn:"
"`intro` can be applied or the goal is not head-reducible."
msgstr ""

#: ../../proof-engine/tactics.rst:632
msgid ""
"This applies :tacn:`intro` but forces :token:`ident` to be the name of the "
"introduced hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:640
msgid ""
"If a name used by intro hides the base name of a global constant then the "
"latter can still be referred to by a qualified name (see :ref:`Qualified-"
"names`)."
msgstr ""

#: ../../proof-engine/tactics.rst:647
msgid ""
"This repeats :tacn:`intro` until it meets the head-constant. It never "
"reduces head-constants and it never fails."
msgstr ""

#: ../../proof-engine/tactics.rst:652
msgid ""
"This is equivalent to the composed tactic :n:`intro @ident; ... ; intro "
"@ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:656
msgid ""
"This repeats intro until it meets a premise of the goal having the form :n:"
"`(@ident : @type)` and discharges the variable named :token:`ident` of the "
"current goal."
msgstr ""

#: ../../proof-engine/tactics.rst:665
msgid ""
"This repeats :tacn:`intro` until the :token:`num`\\-th non-dependent product."
msgstr ""

#: ../../proof-engine/tactics.rst:670
msgid ""
"On the subgoal :g:`forall x y : nat, x = y -> y = x` the tactic :n:`intros "
"until 1` is equivalent to :n:`intros x y H`, as :g:`x = y -> y = x` is the "
"first non-dependent product."
msgstr ""

#: ../../proof-engine/tactics.rst:674
msgid ""
"On the subgoal :g:`forall x y z : nat, x = y -> y = x` the tactic :n:`intros "
"until 1` is equivalent to :n:`intros x y z` as the product on :g:`z` can be "
"rewritten as a non-dependent product: :g:`forall x y : nat, nat -> x = y -> "
"y = x`."
msgstr ""

#: ../../proof-engine/tactics.rst:681
msgid ""
"This happens when :token:`num` is 0 or is greater than the number of non-"
"dependent products of the goal."
msgstr ""

#: ../../proof-engine/tactics.rst:689
msgid ""
"These tactics apply :n:`intro {? @ident__1}` and move the freshly introduced "
"hypothesis respectively after the hypothesis :n:`@ident__2`, before the "
"hypothesis :n:`@ident__2`, at the top of the local context, or at the bottom "
"of the local context. All hypotheses on which the new hypothesis depends are "
"moved too so as to respect the order of dependencies between hypotheses. It "
"is equivalent to :n:`intro {? @ident__1 }` followed by the appropriate call "
"to :tacn:`move ... after ...`, :tacn:`move ... before ...`, :tacn:`move ... "
"at top`, or :tacn:`move ... at bottom`."
msgstr ""

#: ../../proof-engine/tactics.rst:701
msgid ":n:`intro at bottom` is a synonym for :n:`intro` with no argument."
msgstr ""

#: ../../proof-engine/tactics.rst:709
msgid ""
"This extension of the tactic :n:`intros` allows to apply tactics on the fly "
"on the variables or hypotheses which have been introduced. An *introduction "
"pattern list* :n:`@intro_pattern_list` is a list of introduction patterns "
"possibly containing the filling introduction patterns `*` and `**`. An "
"*introduction pattern* is either:"
msgstr ""

#: ../../proof-engine/tactics.rst:715
msgid "a *naming introduction pattern*, i.e. either one of:"
msgstr ""

#: ../../proof-engine/tactics.rst:717
msgid "the pattern :n:`?`"
msgstr ""

#: ../../proof-engine/tactics.rst:719
msgid "the pattern :n:`?ident`"
msgstr ""

#: ../../proof-engine/tactics.rst:721
msgid "an identifier"
msgstr ""

#: ../../proof-engine/tactics.rst:723
msgid "an *action introduction pattern* which itself classifies into:"
msgstr ""

#: ../../proof-engine/tactics.rst:725
msgid "a *disjunctive/conjunctive introduction pattern*, i.e. either one of"
msgstr ""

#: ../../proof-engine/tactics.rst:727
msgid ""
"a disjunction of lists of patterns :n:`[@intro_pattern_list | ... | "
"@intro_pattern_list]`"
msgstr ""

#: ../../proof-engine/tactics.rst:730
msgid "a conjunction of patterns: :n:`({+, p})`"
msgstr ""

#: ../../proof-engine/tactics.rst:732
msgid ""
"a list of patterns :n:`({+& p})` for sequence of right-associative binary "
"constructs"
msgstr ""

#: ../../proof-engine/tactics.rst:736
msgid "an *equality introduction pattern*, i.e. either one of:"
msgstr ""

#: ../../proof-engine/tactics.rst:738
msgid "a pattern for decomposing an equality: :n:`[= {+ p}]`"
msgstr ""

#: ../../proof-engine/tactics.rst:739
msgid "the rewriting orientations: :n:`->` or :n:`<-`"
msgstr ""

#: ../../proof-engine/tactics.rst:741
msgid ""
"the on-the-fly application of lemmas: :n:`p{+ %term}` where :n:`p` itself is "
"not a pattern for on-the-fly application of lemmas (note: syntax is in "
"experimental stage)"
msgstr ""

#: ../../proof-engine/tactics.rst:745
msgid "the wildcard: :n:`_`"
msgstr ""

#: ../../proof-engine/tactics.rst:748
msgid ""
"Assuming a goal of type :g:`Q → P` (non-dependent product), or of type :math:"
"`\\forall`:g:`x:T, P` (dependent product), the behavior of :n:`intros p` is "
"defined inductively over the structure of the introduction pattern :n:`p`:"
msgstr ""

#: ../../proof-engine/tactics.rst:753
msgid ""
"Introduction on :n:`?` performs the introduction, and lets Coq choose a "
"fresh name for the variable;"
msgstr ""

#: ../../proof-engine/tactics.rst:756
msgid ""
"Introduction on :n:`?@ident` performs the introduction, and lets Coq choose "
"a fresh name for the variable based on :n:`@ident`;"
msgstr ""

#: ../../proof-engine/tactics.rst:759
msgid "Introduction on :n:`@ident` behaves as described in :tacn:`intro`"
msgstr ""

#: ../../proof-engine/tactics.rst:761
msgid ""
"Introduction over a disjunction of list of patterns :n:`[@intro_pattern_list "
"| ... | @intro_pattern_list ]` expects the product to be over an inductive "
"type whose number of constructors is `n` (or more generally over a type of "
"conclusion an inductive type built from `n` constructors, e.g. :g:`C -> A\\/"
"B` with `n=2` since :g:`A\\/B` has `2` constructors): it destructs the "
"introduced hypothesis as :n:`destruct` (see :tacn:`destruct`) would and "
"applies on each generated subgoal the corresponding tactic;"
msgstr ""

#: ../../proof-engine/tactics.rst:770
msgid ""
"The introduction patterns in :n:`@intro_pattern_list` are expected to "
"consume no more than the number of arguments of the `i`-th constructor. If "
"it consumes less, then Coq completes the pattern so that all the arguments "
"of the constructors of the inductive type are introduced (for instance, the "
"list of patterns :n:`[ | ] H` applied on goal :g:`forall x:nat, x=0 -> 0=x` "
"behaves the same as the list of patterns :n:`[ | ? ] H`);"
msgstr ""

#: ../../proof-engine/tactics.rst:777
msgid ""
"Introduction over a conjunction of patterns :n:`({+, p})` expects the goal "
"to be a product over an inductive type :g:`I` with a single constructor that "
"itself has at least `n` arguments: It performs a case analysis over the "
"hypothesis, as :n:`destruct` would, and applies the patterns :n:`{+ p}` to "
"the arguments of the constructor of :g:`I` (observe that :n:`({+ p})` is an "
"alternative notation for :n:`[{+ p}]`);"
msgstr ""

#: ../../proof-engine/tactics.rst:784
msgid ""
"Introduction via :n:`({+& p})` is a shortcut for introduction via :n:`(p,"
"( ... ,( ..., p ) ... ))`; it expects the hypothesis to be a sequence of "
"right-associative binary inductive constructors such as :g:`conj` or :g:"
"`ex_intro`; for instance, a hypothesis with type :g:`A /\\(exists x, B /\\ "
"C /\\ D)` can be introduced via pattern :n:`(a & x & b & c & d)`;"
msgstr ""

#: ../../proof-engine/tactics.rst:791
msgid ""
"If the product is over an equality type, then a pattern of the form :n:`[= "
"{+ p}]` applies either :tacn:`injection` or :tacn:`discriminate` instead of :"
"tacn:`destruct`; if :tacn:`injection` is applicable, the patterns :n:`{+, p}"
"` are used on the hypotheses generated by :tacn:`injection`; if the number "
"of patterns is smaller than the number of hypotheses generated, the pattern :"
"n:`?` is used to complete the list."
msgstr ""

#: ../../proof-engine/tactics.rst:798
msgid ""
"Introduction over ``->`` (respectively over ``<-``) expects the hypothesis "
"to be an equality and the right-hand-side (respectively the left-hand-side) "
"is replaced by the left-hand-side (respectively the right-hand-side) in the "
"conclusion of the goal; the hypothesis itself is erased; if the term to "
"substitute is a variable, it is substituted also in the context of goal and "
"the variable is removed too."
msgstr ""

#: ../../proof-engine/tactics.rst:805
msgid ""
"Introduction over a pattern :n:`p{+ %term}` first applies :n:`{+ term}` on "
"the hypothesis to be introduced (as in :n:`apply {+, term}`) prior to the "
"application of the introduction pattern :n:`p`;"
msgstr ""

#: ../../proof-engine/tactics.rst:809
msgid ""
"Introduction on the wildcard depends on whether the product is dependent or "
"not: in the non-dependent case, it erases the corresponding hypothesis (i.e. "
"it behaves as an :tacn:`intro` followed by a :tacn:`clear`) while in the "
"dependent case, it succeeds and erases the variable only if the wildcard is "
"part of a more complex list of introduction patterns that also erases the "
"hypotheses depending on this variable;"
msgstr ""

#: ../../proof-engine/tactics.rst:816
msgid ""
"Introduction over :n:`*` introduces all forthcoming quantified variables "
"appearing in a row; introduction over :n:`**` introduces all forthcoming "
"quantified variables or hypotheses until the goal is not any more a "
"quantification or an implication."
msgstr ""

#: ../../proof-engine/tactics.rst:830
msgid ""
":n:`intros {+ p}` is not equivalent to :n:`intros p; ... ; intros p` for the "
"following reason: If one of the :n:`p` is a wildcard pattern, it might "
"succeed in the first case because the further hypotheses it depends on are "
"eventually erased too while it might fail in the second case because of "
"dependencies in hypotheses which are not yet introduced (and a fortiori not "
"yet erased)."
msgstr ""

#: ../../proof-engine/tactics.rst:839
msgid ""
"In :n:`intros @intro_pattern_list`, if the last introduction pattern is a "
"disjunctive or conjunctive pattern :n:`[{+| @intro_pattern_list}]`, the "
"completion of :n:`@intro_pattern_list` so that all the arguments of the i-th "
"constructors of the corresponding inductive type are introduced can be "
"controlled with the following option:"
msgstr ""

#: ../../proof-engine/tactics.rst:847
msgid ""
"Force completion, if needed, when the last introduction pattern is a "
"disjunctive or conjunctive pattern (on by default)."
msgstr ""

#: ../../proof-engine/tactics.rst:853
msgid ""
"This tactic erases the hypothesis named :n:`@ident` in the local context of "
"the current goal. As a consequence, :n:`@ident` is no more displayed and no "
"more usable in the proof development."
msgstr ""

#: ../../proof-engine/tactics.rst:868
msgid "This is equivalent to :n:`clear @ident. ... clear @ident.`"
msgstr ""

#: ../../proof-engine/tactics.rst:872
msgid ""
"This variant clears all the hypotheses except the ones depending in the "
"hypotheses named :n:`{+ @ident}` and in the goal."
msgstr ""

#: ../../proof-engine/tactics.rst:877
msgid ""
"This variants clears all the hypotheses except the ones the goal depends on."
msgstr ""

#: ../../proof-engine/tactics.rst:881
msgid ""
"This clears the hypothesis :token:`ident` and all the hypotheses that depend "
"on it."
msgstr ""

#: ../../proof-engine/tactics.rst:887
msgid ""
"This tactic expects :n:`{+ @ident}` to be local definitions and clears their "
"respective bodies. In other words, it turns the given definitions into "
"assumptions."
msgstr ""

#: ../../proof-engine/tactics.rst:897
msgid ""
"This applies to any goal with variables :n:`{+ @ident}`. It moves the "
"hypotheses (possibly defined) to the goal, if this respects dependencies. "
"This tactic is the inverse of :tacn:`intro`."
msgstr ""

#: ../../proof-engine/tactics.rst:910
msgid ""
"This moves to the goal the hypothesis :token:`ident` and all the hypotheses "
"that depend on it."
msgstr ""

#: ../../proof-engine/tactics.rst:916
msgid ""
"This moves the hypothesis named :n:`@ident__1` in the local context after "
"the hypothesis named :n:`@ident__2`, where “after” is in reference to the "
"direction of the move. The proof term is not changed."
msgstr ""

#: ../../proof-engine/tactics.rst:920
msgid ""
"If :n:`@ident__1` comes before :n:`@ident__2` in the order of dependencies, "
"then all the hypotheses between :n:`@ident__1` and :n:`@ident__2` that "
"(possibly indirectly) depend on :n:`@ident__1` are moved too, and all of "
"them are thus moved after :n:`@ident__2` in the order of dependencies."
msgstr ""

#: ../../proof-engine/tactics.rst:925
msgid ""
"If :n:`@ident__1` comes after :n:`@ident__2` in the order of dependencies, "
"then all the hypotheses between :n:`@ident__1` and :n:`@ident__2` that "
"(possibly indirectly) occur in the type of :n:`@ident__1` are moved too, and "
"all of them are thus moved before :n:`@ident__2` in the order of "
"dependencies."
msgstr ""

#: ../../proof-engine/tactics.rst:934
msgid ""
"This moves :n:`@ident__1` towards and just before the hypothesis named :n:"
"`@ident__2`.  As for :tacn:`move ... after ...`, dependencies over :n:"
"`@ident__1` (when :n:`@ident__1` comes before :n:`@ident__2` in the order of "
"dependencies) or in the type of :n:`@ident__1` (when :n:`@ident__1` comes "
"after :n:`@ident__2` in the order of dependencies) are moved too."
msgstr ""

#: ../../proof-engine/tactics.rst:944
msgid ""
"This moves :token:`ident` at the top of the local context (at the beginning "
"of the context)."
msgstr ""

#: ../../proof-engine/tactics.rst:950
msgid ""
"This moves :token:`ident` at the bottom of the local context (at the end of "
"the context)."
msgstr ""

#: ../../proof-engine/tactics.rst:979
msgid ""
"This renames hypothesis :n:`@ident__1` into :n:`@ident__2` in the current "
"context. The name of the hypothesis in the proof-term, however, is left "
"unchanged."
msgstr ""

#: ../../proof-engine/tactics.rst:985
msgid ""
"This renames the variables :n:`@ident__i` into :n:`@ident__j` in parallel. "
"In particular, the target identifiers may contain identifiers that exist in "
"the source context, as long as the latter are also renamed by the same "
"tactic."
msgstr ""

#: ../../proof-engine/tactics.rst:999
msgid ""
"This replaces :token:`term` by :token:`ident` in the conclusion of the "
"current goal and adds the new definition :n:`@ident := @term` to the local "
"context."
msgstr ""

#: ../../proof-engine/tactics.rst:1003
msgid ""
"If :token:`term` has holes (i.e. subexpressions of the form “`_`”), the "
"tactic first checks that all subterms matching the pattern are compatible "
"before doing the replacement using the leftmost subterm matching the pattern."
msgstr ""

#: ../../proof-engine/tactics.rst:1013
msgid ""
"This notation allows specifying which occurrences of :token:`term` have to "
"be substituted in the context. The :n:`in @goal_occurrences` clause is an "
"occurrence clause whose syntax and behavior are described in :ref:`goal "
"occurences <occurencessets>`."
msgstr ""

#: ../../proof-engine/tactics.rst:1020
msgid ""
"This is equivalent to :n:`set (@ident := fun @binders => @term) {? in "
"@goal_occurrences }`."
msgstr ""

#: ../../proof-engine/tactics.rst:1024
msgid ""
"This behaves as :n:`set (@ident := @term) {? in @goal_occurrences }` but :"
"token:`ident` is generated by Coq."
msgstr ""

#: ../../proof-engine/tactics.rst:1031
msgid ""
"While the different variants of :tacn:`set` expect that no existential "
"variables are generated by the tactic, :tacn:`eset` removes this constraint. "
"In practice, this is relevant only when :tacn:`eset` is used as a synonym "
"of :tacn:`epose`, i.e. when the :token:`term` does not occur in the goal."
msgstr ""

#: ../../proof-engine/tactics.rst:1040
msgid ""
"This behaves as :n:`set (@ident__1 := @term) in *`, using a logical "
"(Leibniz’s) equality instead of a local definition. If :n:`@ident__2` is "
"provided, it will be the name of the new equation."
msgstr ""

#: ../../proof-engine/tactics.rst:1046
msgid ""
"This is a more general form of :tacn:`remember` that remembers the "
"occurrences of :token:`term` specified by an occurrence set."
msgstr ""

#: ../../proof-engine/tactics.rst:1052
msgid ""
"While the different variants of :tacn:`remember` expect that no existential "
"variables are generated by the tactic, :tacn:`eremember` removes this "
"constraint."
msgstr ""

#: ../../proof-engine/tactics.rst:1059
msgid ""
"This adds the local definition :n:`@ident := @term` to the current context "
"without performing any replacement in the goal or in the hypotheses. It is "
"equivalent to :n:`set (@ident := @term) in |-`."
msgstr ""

#: ../../proof-engine/tactics.rst:1065
msgid "This is equivalent to :n:`pose (@ident := fun @binders => @term)`."
msgstr ""

#: ../../proof-engine/tactics.rst:1069
msgid ""
"This behaves as :n:`pose (@ident := @term)` but :token:`ident` is generated "
"by Coq."
msgstr ""

#: ../../proof-engine/tactics.rst:1076
msgid ""
"While the different variants of :tacn:`pose` expect that no existential "
"variables are generated by the tactic, :tacn:`epose` removes this constraint."
msgstr ""

#: ../../proof-engine/tactics.rst:1083
msgid ""
"This tactic recursively decomposes a complex proposition in order to obtain "
"atomic ones."
msgstr ""

#: ../../proof-engine/tactics.rst:1097
msgid ""
":tacn:`decompose` does not work on right-hand sides of implications or "
"products."
msgstr ""

#: ../../proof-engine/tactics.rst:1102
msgid "This decomposes sum types (like :g:`or`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1106
msgid ""
"This decomposes record types (inductive types with one constructor, like :g:"
"`and` and :g:`exists` and those defined with the :cmd:`Record` command."
msgstr ""

#: ../../proof-engine/tactics.rst:1114
msgid "Controlling the proof flow"
msgstr ""

#: ../../proof-engine/tactics.rst:1119
msgid ""
"This tactic applies to any goal. :n:`assert (H : U)` adds a new hypothesis "
"of name :n:`H` asserting :g:`U` to the current goal and opens a new subgoal :"
"g:`U` [2]_. The subgoal :g:`U` comes first in the list of subgoals remaining "
"to prove."
msgstr ""

#: ../../proof-engine/tactics.rst:1126
msgid ""
"Arises when the argument form is neither of type :g:`Prop`, :g:`Set` nor :g:"
"`Type`."
msgstr ""

#: ../../proof-engine/tactics.rst:1131
msgid ""
"This behaves as :n:`assert (@ident : form)` but :n:`@ident` is generated by "
"Coq."
msgstr ""

#: ../../proof-engine/tactics.rst:1136
msgid ""
"This tactic behaves like :n:`assert` but applies tactic to solve the "
"subgoals generated by assert."
msgstr ""

#: ../../proof-engine/tactics.rst:1144
msgid ""
"If :n:`intro_pattern` is a naming introduction pattern (see :tacn:`intro`), "
"the hypothesis is named after this introduction pattern (in particular, if :"
"n:`intro_pattern` is :n:`@ident`, the tactic behaves like :n:`assert "
"(@ident : form)`). If :n:`intro_pattern` is an action introduction pattern, "
"the tactic behaves like :n:`assert form` followed by the action done by this "
"introduction pattern."
msgstr ""

#: ../../proof-engine/tactics.rst:1153
msgid "This combines the two previous variants of :n:`assert`."
msgstr ""

#: ../../proof-engine/tactics.rst:1157
msgid ""
"This behaves as :n:`assert (@ident : type) by exact @term` where :g:`type` "
"is the type of :g:`term`. This is deprecated in favor of :n:`pose proof`. If "
"the head of term is :n:`@ident`, the tactic behaves as :n:`specialize @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:1168
msgid ""
"While the different variants of :n:`assert` expect that no existential "
"variables are generated by the tactic, :n:`eassert` removes this constraint. "
"This allows not to specify the asserted statement completeley before "
"starting to prove it."
msgstr ""

#: ../../proof-engine/tactics.rst:1176
msgid ""
"This tactic behaves like :n:`assert T {? as intro_pattern} by exact @term` "
"where :g:`T` is the type of :g:`term`. In particular, :n:`pose proof @term "
"as @ident` behaves as :n:`assert (@ident := @term)` and :n:`pose proof @term "
"as intro_pattern` is the same as applying the intro_pattern to :n:`@term`."
msgstr ""

#: ../../proof-engine/tactics.rst:1184
msgid ""
"While :n:`pose proof` expects that no existential variables are generated by "
"the tactic, :n:`epose proof` removes this constraint."
msgstr ""

#: ../../proof-engine/tactics.rst:1190
msgid ""
"This adds a new hypothesis of name :n:`@ident` asserting :n:`form` to the "
"goal the tactic :n:`enough` is applied to. A new subgoal stating :n:`form` "
"is inserted after the initial goal rather than before it as :n:`assert` "
"would do."
msgstr ""

#: ../../proof-engine/tactics.rst:1196
msgid ""
"This behaves like :n:`enough (@ident : form)` with the name :n:`@ident` of "
"the hypothesis generated by Coq."
msgstr ""

#: ../../proof-engine/tactics.rst:1201
msgid ""
"This behaves like :n:`enough form` using :n:`intro_pattern` to name or "
"destruct the new hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:1208
msgid ""
"This behaves as above but with :n:`tactic` expected to solve the initial "
"goal after the extra assumption :n:`form` is added and possibly destructed. "
"If the :n:`as intro_pattern` clause generates more than one subgoal, :n:"
"`tactic` is applied to all of them."
msgstr ""

#: ../../proof-engine/tactics.rst:1220
msgid ""
"While the different variants of :n:`enough` expect that no existential "
"variables are generated by the tactic, :n:`eenough` removes this constraint."
msgstr ""

#: ../../proof-engine/tactics.rst:1226
msgid ""
"This tactic applies to any goal. It implements the non-dependent case of the "
"“App” rule given in :ref:`typing-rules`. (This is Modus Ponens inference "
"rule.) :n:`cut U` transforms the current goal :g:`T` into the two following "
"subgoals: :g:`U -> T` and :g:`U`. The subgoal :g:`U -> T` comes first in the "
"list of remaining subgoal to prove."
msgstr ""

#: ../../proof-engine/tactics.rst:1236
msgid ""
"The tactic :n:`specialize` works on local hypothesis :n:`@ident`. The "
"premises of this hypothesis (either universal quantifications or non-"
"dependent implications) are instantiated by concrete terms coming either "
"from arguments :n:`{* @term}` or from a :ref:`bindings list <bindingslist>`. "
"In the first form the application to :n:`{* @term}`  can be partial. The "
"first form is equivalent to :n:`assert (@ident := @ident {* @term})`. In the "
"second form, instantiation elements can also be partial. In this case the "
"uninstantiated arguments are inferred by unification if possible or left "
"quantified in the hypothesis otherwise. With the :n:`as` clause, the local "
"hypothesis :n:`@ident` is left unchanged and instead, the modified "
"hypothesis is introduced as specified by the :n:`intro_pattern`. The name :n:"
"`@ident` can also refer to a global lemma or hypothesis. In this case, for "
"compatibility reasons, the behavior of :n:`specialize` is close to that of :"
"n:`generalize`: the instantiated statement becomes an additional premise of "
"the goal. The :n:`as` clause is especially useful in this case to "
"immediately introduce the instantiated statement as a local hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:1259
msgid ""
"This tactic applies to any goal. It generalizes the conclusion with respect "
"to some term."
msgstr ""

#: ../../proof-engine/tactics.rst:1274
msgid ""
"If the goal is :g:`G` and :g:`t` is a subterm of type :g:`T` in the goal, "
"then :n:`generalize t` replaces the goal by :g:`forall (x:T), G′` where :g:`G"
"′` is obtained from :g:`G` by replacing all occurrences of :g:`t` by :g:`x`. "
"The name of the variable (here :g:`n`) is chosen based on :g:`T`."
msgstr ""

#: ../../proof-engine/tactics.rst:1281
msgid ""
"This is equivalent to :n:`generalize @term; ... ; generalize @term`. Note "
"that the sequence of term :sub:`i` 's are processed from n to 1."
msgstr ""

#: ../../proof-engine/tactics.rst:1286
msgid ""
"This is equivalent to :n:`generalize @term` but it generalizes only over the "
"specified occurrences of :n:`@term` (counting from left to right on the "
"expression printed using option :flag:`Printing All`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1292
msgid ""
"This is equivalent to :n:`generalize @term` but it uses :n:`@ident` to name "
"the generalized hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:1297
msgid ""
"This is the most general form of :n:`generalize` that combines the previous "
"behaviors."
msgstr ""

#: ../../proof-engine/tactics.rst:1302
msgid ""
"This generalizes term but also *all* hypotheses that depend on :n:`@term`. "
"It clears the generalized hypotheses."
msgstr ""

#: ../../proof-engine/tactics.rst:1308
msgid ""
"The :n:`evar` tactic creates a new local definition named :n:`@ident` with "
"type :n:`@term` in the context. The body of this binding is a fresh "
"existential variable."
msgstr ""

#: ../../proof-engine/tactics.rst:1315
msgid ""
"The instantiate tactic refines (see :tacn:`refine`) an existential variable :"
"n:`@ident` with the term :n:`@term`. It is equivalent to only [ident]: :n:"
"`refine @term` (preferred alternative)."
msgstr ""

#: ../../proof-engine/tactics.rst:1319
msgid ""
"To be able to refer to an existential variable by name, the user must have "
"given the name explicitly (see :ref:`Existential-Variables`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1322
msgid ""
"When you are referring to hypotheses which you did not name explicitly, be "
"aware that Coq may make a different decision on how to name the variable in "
"the current goal and in the context of the existential variable. This can "
"lead to surprising behaviors."
msgstr ""

#: ../../proof-engine/tactics.rst:1329
msgid ""
"This variant allows to refer to an existential variable which was not named "
"by the user. The :n:`@num` argument is the position of the existential "
"variable from right to left in the goal. Because this variant is not robust "
"to slight changes in the goal, its use is strongly discouraged."
msgstr ""

#: ../../proof-engine/tactics.rst:1338
msgid ""
"These allow to refer respectively to existential variables occurring in a "
"hypothesis or in the body or the type of a local definition."
msgstr ""

#: ../../proof-engine/tactics.rst:1343
msgid ""
"Without argument, the instantiate tactic tries to solve as many existential "
"variables as possible, using information gathered from other tactics in the "
"same tactical. This is automatically done after each complete tactic (i.e. "
"after a dot in proof mode), but not, for example, between each tactic when "
"they are sequenced by semicolons."
msgstr ""

#: ../../proof-engine/tactics.rst:1352
msgid ""
"The admit tactic allows temporarily skipping a subgoal so as to progress "
"further in the rest of the proof. A proof containing admitted goals cannot "
"be closed with :g:`Qed` but only with :g:`Admitted`."
msgstr ""

#: ../../proof-engine/tactics.rst:1358
msgid "Synonym of :n:`admit`."
msgstr ""

#: ../../proof-engine/tactics.rst:1363
msgid ""
"This tactic applies to any goal. The argument term is any proposition :g:`P` "
"of type :g:`Prop`. This tactic applies False elimination, that is it deduces "
"the current goal from False, and generates as subgoals :g:`∼P` and :g:`P`. "
"It is very useful in proofs by cases, where some cases are impossible. In "
"most cases, :g:`P` or :g:`∼P` is one of the hypotheses of the local context."
msgstr ""

#: ../../proof-engine/tactics.rst:1373
msgid ""
"This tactic applies to any goal. The contradiction tactic attempts to find "
"in the current context (after all intros) a hypothesis that is equivalent to "
"an empty inductive type (e.g. :g:`False`), to the negation of a singleton "
"inductive type (e.g. :g:`True` or :g:`x=x`), or two contradictory hypotheses."
msgstr ""

#: ../../proof-engine/tactics.rst:1383
msgid "The proof of False is searched in the hypothesis named :n:`@ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:1388
msgid ""
"This tactic allows manipulating negated hypothesis and goals. The name :n:"
"`@ident` should correspond to a hypothesis. With :n:`contradict H`, the "
"current goal and context is transformed in the following way:"
msgstr ""

#: ../../proof-engine/tactics.rst:1392
msgid "H:¬A ⊢ B becomes ⊢ A"
msgstr ""

#: ../../proof-engine/tactics.rst:1393
msgid "H:¬A ⊢ ¬B becomes H: B ⊢ A"
msgstr ""

#: ../../proof-engine/tactics.rst:1394
msgid "H: A ⊢ B becomes ⊢ ¬A"
msgstr ""

#: ../../proof-engine/tactics.rst:1395
msgid "H: A ⊢ ¬B becomes H: B ⊢ ¬A"
msgstr ""

#: ../../proof-engine/tactics.rst:1400
msgid ""
"This tactic implements the “ex falso quodlibet” logical principle: an "
"elimination of False is performed on the current goal, and the user is then "
"required to prove that False is indeed provable in the current context. This "
"tactic is a macro for :n:`elimtype False`."
msgstr ""

#: ../../proof-engine/tactics.rst:1408
msgid "Case analysis and induction"
msgstr ""

#: ../../proof-engine/tactics.rst:1410
msgid ""
"The tactics presented in this section implement induction or case analysis "
"on inductive or co-inductive objects (see :ref:`inductive-definitions`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1416
msgid ""
"This tactic applies to any goal. The argument :token:`term` must be of "
"inductive or co-inductive type and the tactic generates subgoals, one for "
"each possible form of :token:`term`, i.e. one for each constructor of the "
"inductive or co-inductive type. Unlike :tacn:`induction`, no induction "
"hypothesis is generated by :tacn:`destruct`."
msgstr ""

#: ../../proof-engine/tactics.rst:1424
msgid ""
"If :token:`ident` denotes a quantified variable of the conclusion of the "
"goal, then :n:`destruct @ident` behaves as :n:`intros until @ident; destruct "
"@ident`. If :token:`ident` is not anymore dependent in the goal after "
"application of :tacn:`destruct`, it is erased (to avoid erasure, use "
"parentheses, as in :n:`destruct (@ident)`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1430
msgid ""
"If :token:`ident` is a hypothesis of the context, and :token:`ident` is not "
"anymore dependent in the goal after application of :tacn:`destruct`, it is "
"erased (to avoid erasure, use parentheses, as in :n:`destruct (@ident)`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1437
msgid ""
":n:`destruct @num` behaves as :n:`intros until @num` followed by destruct "
"applied to the last introduced hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:1441
msgid ""
"For destruction of a numeral, use syntax :n:`destruct (@num)` (not very "
"interesting anyway)."
msgstr ""

#: ../../proof-engine/tactics.rst:1446
msgid ""
"The argument of :tacn:`destruct` can also be a pattern of which holes are "
"denoted by “_”. In this case, the tactic checks that all subterms matching "
"the pattern in the conclusion and the hypotheses are compatible and performs "
"case analysis using this subterm."
msgstr ""

#: ../../proof-engine/tactics.rst:1453
msgid "This is a shortcut for :n:`destruct @term; ...; destruct @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:1457
msgid ""
"This behaves as :n:`destruct @term` but uses the names in :token:"
"`disj_conj_intro_pattern` to name the variables introduced in the context. "
"The :token:`disj_conj_intro_pattern` must have the form :n:`[p11 ... p1n "
"| ... | pm1 ... pmn ]` with ``m`` being the number of constructors of the "
"type of :token:`term`. Each variable introduced by :tacn:`destruct` in the "
"context of the ``i``-th goal gets its name from the list :n:`pi1 ... pin` in "
"order. If there are not enough names, :tacn:`destruct` invents names for the "
"remaining variables to introduce. More generally, the :n:`pij` can be any "
"introduction pattern (see :tacn:`intros`). This provides a concise notation "
"for chaining destruction of a hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:1472
msgid ""
"This behaves as :n:`destruct @term` but adds an equation between :token:"
"`term` and the value that it takes in each of the possible cases. The name "
"of the equation is specified by :token:`naming_intro_pattern` (see :tacn:"
"`intros`), in particular ``?`` can be used to let Coq generate a fresh name."
msgstr ""

#: ../../proof-engine/tactics.rst:1480
msgid ""
"This behaves like :n:`destruct @term` providing explicit instances for the "
"dependent premises of the type of :token:`term`."
msgstr ""

#: ../../proof-engine/tactics.rst:1486
msgid ""
"This tactic behaves like :n:`destruct @term` except that it does not fail if "
"the instance of a dependent premises of the type of :token:`term` is not "
"inferable. Instead, the unresolved instances are left as existential "
"variables to be inferred later, in the same way as :tacn:`eapply` does."
msgstr ""

#: ../../proof-engine/tactics.rst:1494
msgid ""
"This is synonym of :n:`induction @term using @term {? with @bindings_list }`."
msgstr ""

#: ../../proof-engine/tactics.rst:1498
msgid ""
"This syntax is used for selecting which occurrences of :token:`term` the "
"case analysis has to be done on. The :n:`in @goal_occurrences` clause is an "
"occurrence clause whose syntax and behavior is described in :ref:`occurences "
"sets <occurencessets>`."
msgstr ""

#: ../../proof-engine/tactics.rst:1506
msgid ""
"These are the general forms of :tacn:`destruct` and :tacn:`edestruct`. They "
"combine the effects of the ``with``, ``as``, ``eqn:``, ``using``, and ``in`` "
"clauses."
msgstr ""

#: ../../proof-engine/tactics.rst:1513
msgid ""
"The tactic :n:`case` is a more basic tactic to perform case analysis without "
"recursion. It behaves as :n:`elim @term` but using a case-analysis "
"elimination principle and not a recursive one."
msgstr ""

#: ../../proof-engine/tactics.rst:1519
msgid "Analogous to :n:`elim @term with @bindings_list` above."
msgstr ""

#: ../../proof-engine/tactics.rst:1524
msgid ""
"In case the type of :n:`@term` has dependent premises, or dependent premises "
"whose values are not inferable from the :n:`with @bindings_list` clause, :n:"
"`ecase` turns them into existential variables to be resolved later on."
msgstr ""

#: ../../proof-engine/tactics.rst:1531
msgid ""
"This tactic behaves as :n:`intros until @ident; case @ident` when :n:"
"`@ident` is a quantified variable of the goal."
msgstr ""

#: ../../proof-engine/tactics.rst:1536
msgid ""
"This tactic behaves as :n:`intros until @num; case @ident` where :n:`@ident` "
"is the name given by :n:`intros until @num` to the :n:`@num` -th non-"
"dependent premise of the goal."
msgstr ""

#: ../../proof-engine/tactics.rst:1542
msgid ""
"The tactic :n:`case_eq` is a variant of the :n:`case` tactic that allows to "
"perform case analysis on a term without completely forgetting its original "
"form. This is done by generating equalities between the original form of the "
"term and the outcomes of the case analysis."
msgstr ""

#: ../../proof-engine/tactics.rst:1550
msgid ""
"This tactic applies to any goal. The argument :n:`@term` must be of "
"inductive type and the tactic :n:`induction` generates subgoals, one for "
"each possible form of :n:`@term`, i.e. one for each constructor of the "
"inductive type."
msgstr ""

#: ../../proof-engine/tactics.rst:1555
msgid ""
"If the argument is dependent in either the conclusion or some hypotheses of "
"the goal, the argument is replaced by the appropriate constructor form in "
"each of the resulting subgoals and induction hypotheses are added to the "
"local context using names whose prefix is **IH**."
msgstr ""

#: ../../proof-engine/tactics.rst:1561
msgid "There are particular cases:"
msgstr ""

#: ../../proof-engine/tactics.rst:1563
msgid ""
"If term is an identifier :n:`@ident` denoting a quantified variable of the "
"conclusion of the goal, then inductionident behaves as :n:`intros until "
"@ident; induction @ident`. If :n:`@ident` is not anymore dependent in the "
"goal after application of :n:`induction`, it is erased (to avoid erasure, "
"use parentheses, as in :n:`induction (@ident)`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1568
msgid ""
"If :n:`@term` is a :n:`@num`, then :n:`induction @num` behaves as :n:`intros "
"until @num` followed by :n:`induction` applied to the last introduced "
"hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:1573
msgid ""
"For simple induction on a numeral, use syntax induction (num) (not very "
"interesting anyway)."
msgstr ""

#: ../../proof-engine/tactics.rst:1576
msgid ""
"In case term is a hypothesis :n:`@ident` of the context, and :n:`@ident` is "
"not anymore dependent in the goal after application of :n:`induction`, it is "
"erased (to avoid erasure, use parentheses, as in :n:`induction (@ident)`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1580
msgid ""
"The argument :n:`@term` can also be a pattern of which holes are denoted by "
"“_”. In this case, the tactic checks that all subterms matching the pattern "
"in the conclusion and the hypotheses are compatible and performs induction "
"using this subterm."
msgstr ""

#: ../../proof-engine/tactics.rst:1597
msgid "Use in this case the variant :tacn:`elim ... with` below."
msgstr ""

#: ../../proof-engine/tactics.rst:1601
msgid ""
"This behaves as :tacn:`induction` but uses the names in :n:"
"`@disj_conj_intro_pattern` to name the variables introduced in the context. "
"The :n:`@disj_conj_intro_pattern` must typically be of the form :n:`[ p` :"
"sub:`11` :n:`... p` :sub:`1n` :n:`| ... | p`:sub:`m1` :n:`... p`:sub:`mn` :n:"
"`]` with :n:`m` being the number of constructors of the type of :n:`@term`. "
"Each variable introduced by induction in the context of the i-th goal gets "
"its name from the list :n:`p`:sub:`i1` :n:`... p`:sub:`in` in order. If "
"there are not enough names, induction invents names for the remaining "
"variables to introduce. More generally, the :n:`p`:sub:`ij` can be any "
"disjunctive/conjunctive introduction pattern (see :tacn:`intros ...`). For "
"instance, for an inductive type with  one constructor, the pattern notation :"
"n:`(p`:sub:`1` :n:`, ... , p`:sub:`n` :n:`)` can be used instead of :n:`[ p`:"
"sub:`1` :n:`... p`:sub:`n` :n:`]`."
msgstr ""

#: ../../proof-engine/tactics.rst:1617
msgid ""
"This behaves like :tacn:`induction` providing explicit instances for the "
"premises of the type of :n:`term` (see :ref:`bindings list <bindingslist>`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1623
msgid ""
"This tactic behaves like :tacn:`induction` except that it does not fail if "
"some dependent premise of the type of :n:`@term` is not inferable. Instead, "
"the unresolved premises are posed as existential variables to be inferred "
"later, in the same way as :tacn:`eapply` does."
msgstr ""

#: ../../proof-engine/tactics.rst:1631
msgid ""
"This behaves as :tacn:`induction`  but using :n:`@term` as induction scheme. "
"It does not expect the conclusion of the type of the first :n:`@term` to be "
"inductive."
msgstr ""

#: ../../proof-engine/tactics.rst:1637
msgid ""
"This behaves as :tacn:`induction ... using ...` but also providing instances "
"for the premises of the type of the second :n:`@term`."
msgstr ""

#: ../../proof-engine/tactics.rst:1642
msgid ""
"This syntax is used for the case :n:`@qualid` denotes an induction principle "
"with complex predicates as the induction principles generated by "
"``Function`` or ``Functional Scheme`` may be."
msgstr ""

#: ../../proof-engine/tactics.rst:1648
msgid ""
"This syntax is used for selecting which occurrences of :n:`@term` the "
"induction has to be carried on. The :n:`in @goal_occurrences` clause is an "
"occurrence clause whose syntax and behavior is described in :ref:`occurences "
"sets <occurencessets>`. If variables or hypotheses not mentioning :n:`@term` "
"in their type are listed in :n:`@goal_occurrences`, those are generalized as "
"well in the statement to prove."
msgstr ""

#: ../../proof-engine/tactics.rst:1667
msgid ""
"These are the most general forms of ``induction`` and ``einduction``. It "
"combines the effects of the with, as, using, and in clauses."
msgstr ""

#: ../../proof-engine/tactics.rst:1673
msgid ""
"This is a more basic induction tactic. Again, the type of the argument :n:"
"`@term` must be an inductive type. Then, according to the type of the goal, "
"the tactic ``elim`` chooses the appropriate destructor and applies it as the "
"tactic :tacn:`apply` would do. For instance, if the proof context contains :"
"g:`n:nat` and the current goal is :g:`T` of type :g:`Prop`, then :n:`elim n` "
"is equivalent to :n:`apply nat_ind with (n:=n)`. The tactic ``elim`` does "
"not modify the context of the goal, neither introduces the induction loading "
"into the context of hypotheses. More generally, :n:`elim @term` also works "
"when the type of :n:`@term` is a statement with premises and whose "
"conclusion is inductive. In that case the tactic performs induction on the "
"conclusion of the type of :n:`@term` and leaves the non-dependent premises "
"of the type as subgoals. In the case of dependent products, the tactic tries "
"to find an instance for which the elimination lemma applies and fails "
"otherwise."
msgstr ""

#: ../../proof-engine/tactics.rst:1691
msgid ""
"Allows to give explicit instances to the premises of the type of :n:`@term` "
"(see :ref:`bindings list <bindingslist>`)."
msgstr ""

#: ../../proof-engine/tactics.rst:1697
msgid ""
"In case the type of :n:`@term` has dependent premises, this turns them into "
"existential variables to be resolved later on."
msgstr ""

#: ../../proof-engine/tactics.rst:1703
msgid ""
"Allows the user to give explicitly an induction principle :n:`@term` that is "
"not the standard one for the underlying inductive type of :n:`@term`. The :n:"
"`@bindings_list` clause allows instantiating premises of the type of :n:"
"`@term`."
msgstr ""

#: ../../proof-engine/tactics.rst:1711
msgid ""
"These are the most general forms of ``elim`` and ``eelim``. It combines the "
"effects of the ``using`` clause and of the two uses of the ``with`` clause."
msgstr ""

#: ../../proof-engine/tactics.rst:1717
msgid ""
"The argument :n:`form` must be inductively defined. :n:`elimtype I` is "
"equivalent to :n:`cut I. intro Hn; elim Hn; clear Hn.` Therefore the "
"hypothesis :g:`Hn` will not appear in the context(s) of the subgoal(s). "
"Conversely, if :g:`t` is a :n:`@term` of (inductive) type :g:`I` that does "
"not occur in the goal, then :n:`elim t` is equivalent to :n:`elimtype I; 2:"
"exact t.`"
msgstr ""

#: ../../proof-engine/tactics.rst:1727
msgid ""
"This tactic behaves as :n:`intros until @ident; elim @ident` when :n:"
"`@ident` is a quantified variable of the goal."
msgstr ""

#: ../../proof-engine/tactics.rst:1732
msgid ""
"This tactic behaves as :n:`intros until @num; elim @ident` where :n:`@ident` "
"is the name given by :n:`intros until @num` to the :n:`@num`-th non-"
"dependent premise of the goal."
msgstr ""

#: ../../proof-engine/tactics.rst:1739
msgid ""
"This tactic is deprecated and should be replaced by :n:`induction @ident; "
"induction @ident` (or :n:`induction @ident ; destruct @ident` depending on "
"the exact needs)."
msgstr ""

#: ../../proof-engine/tactics.rst:1745
msgid ""
"This tactic is deprecated and should be replaced by :n:`induction num1; "
"induction num3` where :n:`num3` is the result of :n:`num2 - num1`"
msgstr ""

#: ../../proof-engine/tactics.rst:1752
msgid ""
"The *experimental* tactic dependent induction performs induction- inversion "
"on an instantiated inductive predicate. One needs to first require the Coq."
"Program.Equality module to use this tactic. The tactic is based on the "
"BasicElim tactic by Conor McBride :cite:`DBLP:conf/types/McBride00` and the "
"work of Cristina Cornes around inversion :cite:`DBLP:conf/types/CornesT95`. "
"From an instantiated inductive predicate and a goal, it generates an "
"equivalent goal where the hypothesis has been generalized over its indexes "
"which are then constrained by equalities to be the right instances. This "
"permits to state lemmas without resorting to manually adding these "
"equalities and still get enough information in the proofs."
msgstr ""

#: ../../proof-engine/tactics.rst:1771
msgid ""
"Here we did not get any information on the indexes to help fulfill this "
"proof. The problem is that, when we use the ``induction`` tactic, we lose "
"information on the hypothesis instance, notably that the second argument is "
"1 here. Dependent induction solves this problem by adding the corresponding "
"equality to the context."
msgstr ""

#: ../../proof-engine/tactics.rst:1783
msgid ""
"The subgoal is cleaned up as the tactic tries to automatically simplify the "
"subgoals with respect to the generated equalities. In this enriched context, "
"it becomes possible to solve this subgoal."
msgstr ""

#: ../../proof-engine/tactics.rst:1791
msgid "Now we are in a contradictory context and the proof can be solved."
msgstr ""

#: ../../proof-engine/tactics.rst:1797
msgid ""
"This technique works with any inductive predicate. In fact, the ``dependent "
"induction`` tactic is just a wrapper around the ``induction`` tactic. One "
"can make its own variant by just writing a new tactic based on the "
"definition found in ``Coq.Program.Equality``."
msgstr ""

#: ../../proof-engine/tactics.rst:1804
msgid ""
"This performs dependent induction on the hypothesis :n:`@ident` but first "
"generalizes the goal by the given variables so that they are universally "
"quantified in the goal. This is generally what one wants to do with the "
"variables that are inside some constructors in the induction hypothesis. The "
"other ones need not be further generalized."
msgstr ""

#: ../../proof-engine/tactics.rst:1813
msgid ""
"This performs the generalization of the instance :n:`@ident` but uses "
"``destruct`` instead of induction on the generalized hypothesis. This gives "
"results equivalent to ``inversion`` or ``dependent inversion`` if the "
"hypothesis is dependent."
msgstr ""

#: ../../proof-engine/tactics.rst:1818
msgid ""
"See also the larger example of :tacn:`dependent induction` and an "
"explanation of the underlying technique."
msgstr ""

#: ../../proof-engine/tactics.rst:1824
msgid ""
"The tactic functional induction performs case analysis and induction "
"following the definition of a function. It makes use of a principle "
"generated by ``Function`` (see :ref:`advanced-recursive-functions`) or "
"``Functional Scheme`` (see :ref:`functional-scheme`). Note that this tactic "
"is only available after a ``Require Import FunInd``."
msgstr ""

#: ../../proof-engine/tactics.rst:1842
msgid ""
":n:`(@qualid {+ @term})` must be a correct full application of :n:`@qualid`. "
"In particular, the rules for implicit arguments are the same as usual. For "
"example use :n:`@qualid` if you want to write implicit arguments explicitly."
msgstr ""

#: ../../proof-engine/tactics.rst:1848
msgid ""
"Parentheses around :n:`@qualid {+ @term}` are not mandatory and can be "
"skipped."
msgstr ""

#: ../../proof-engine/tactics.rst:1851
msgid ""
":n:`functional induction (f x1 x2 x3)` is actually a wrapper for :n:"
"`induction x1, x2, x3, (f x1 x2 x3) using @qualid` followed by a cleaning "
"phase, where :n:`@qualid` is the induction principle registered for :g:`f` "
"(by the ``Function`` (see :ref:`advanced-recursive-functions`) or "
"``Functional Scheme`` (see :ref:`functional-scheme`) command) corresponding "
"to the sort of the goal. Therefore ``functional induction`` may fail if the "
"induction scheme :n:`@qualid` is not defined. See also :ref:`advanced-"
"recursive-functions` for the function terms accepted by ``Function``."
msgstr ""

#: ../../proof-engine/tactics.rst:1862
msgid ""
"There is a difference between obtaining an induction scheme for a function "
"by using :g:`Function` (see :ref:`advanced-recursive-functions`) and by "
"using :g:`Functional Scheme` after a normal definition using :g:`Fixpoint` "
"or :g:`Definition`. See :ref:`advanced-recursive-functions` for details."
msgstr ""

#: ../../proof-engine/tactics.rst:1868
msgid ""
":ref:`advanced-recursive-functions`, :ref:`functional-scheme` and :tacn:"
"`inversion`"
msgstr ""

#: ../../proof-engine/tactics.rst:1875
msgid ""
"Similarly to :tacn:`induction` and :tacn:`elim`, this allows giving "
"explicitly the name of the introduced variables, the induction principle, "
"and the values of dependent premises of the elimination scheme, including "
"*predicates* for mutual induction when :n:`@qualid` is part of a mutually "
"recursive definition."
msgstr ""

#: ../../proof-engine/tactics.rst:1884
msgid ""
"This tactic proves any goal from an assumption stating that two structurally "
"different :n:`@terms` of an inductive set are equal. For example, from :g:"
"`(S (S O))=(S O)` we can derive by absurdity any proposition."
msgstr ""

#: ../../proof-engine/tactics.rst:1889
msgid ""
"The argument :n:`@term` is assumed to be a proof of a statement of "
"conclusion :n:`@term = @term` with the two terms being elements of an "
"inductive set. To build the proof, the tactic traverses the normal forms "
"[3]_ of the terms looking for a couple of subterms :g:`u` and :g:`w` (:g:`u` "
"subterm of the normal form of :n:`@term` and :g:`w` subterm of the normal "
"form of :n:`@term`), placed at the same positions and whose head symbols are "
"two different constructors. If such a couple of subterms exists, then the "
"proof of the current goal is completed, otherwise the tactic fails."
msgstr ""

#: ../../proof-engine/tactics.rst:1899
msgid ""
"The syntax :n:`discriminate @ident` can be used to refer to a hypothesis "
"quantified in the goal. In this case, the quantified hypothesis whose name "
"is :n:`@ident` is first introduced in the local context using :n:`intros "
"until @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:1909
msgid ""
"This does the same thing as :n:`intros until @num` followed by :n:"
"`discriminate @ident` where :n:`@ident` is the identifier for the last "
"introduced hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:1915
msgid ""
"This does the same thing as :n:`discriminate @term` but using the given "
"bindings to instantiate parameters or hypotheses of :n:`@term`."
msgstr ""

#: ../../proof-engine/tactics.rst:1922
msgid ""
"This works the same as ``discriminate`` but if the type of :n:`@term`, or "
"the type of the hypothesis referred to by :n:`@num`, has uninstantiated "
"parameters, these parameters are left as existential variables."
msgstr ""

#: ../../proof-engine/tactics.rst:1928
msgid ""
"This behaves like :n:`discriminate @ident` if ident is the name of an "
"hypothesis to which ``discriminate`` is applicable; if the current goal is "
"of the form :n:`@term <> @term`, this behaves as :n:`intro @ident; "
"discriminate @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:1938
msgid ""
"The injection tactic exploits the property that constructors of inductive "
"types are injective, i.e. that if :g:`c` is a constructor of an inductive "
"type and :g:`c t`:sub:`1` and :g:`c t`:sub:`2` are equal then :g:`t`:sub:`1` "
"and :g:`t`:sub:`2` are equal too."
msgstr ""

#: ../../proof-engine/tactics.rst:1943
msgid ""
"If :n:`@term` is a proof of a statement of conclusion :n:`@term = @term`, "
"then :tacn:`injection` applies the injectivity of constructors as deep as "
"possible to derive the equality of all the subterms of :n:`@term` and :n:"
"`@term` at positions where the terms start to differ. For example, from :g:"
"`(S p, S n) = (q, S (S m))` we may derive :g:`S p = q` and :g:`n = S m`. For "
"this tactic to work, the terms should be typed with an inductive type and "
"they should be neither convertible, nor having a different head constructor. "
"If these conditions are satisfied, the tactic derives the equality of all "
"the subterms at positions where they differ and adds them as antecedents to "
"the conclusion of the current goal."
msgstr ""

#: ../../proof-engine/tactics.rst:1956
msgid "Consider the following goal:"
msgstr ""

#: ../../proof-engine/tactics.rst:1971
msgid ""
"Beware that injection yields an equality in a sigma type whenever the "
"injected object has a dependent type :g:`P` with its two instances in "
"different types :g:`(P t`:sub:`1` :g:`... t`:sub:`n` :g:`)` and :g:`(P u`:"
"sub:`1` :g:`... u`:sub:`n` :sub:`)`. If :g:`t`:sub:`1` and :g:`u`:sub:`1` "
"are the same and have for type an inductive type for which a decidable "
"equality has been declared using the command :cmd:`Scheme Equality` (see :"
"ref:`proofschemes-induction-principles`), the use of a sigma type is avoided."
msgstr ""

#: ../../proof-engine/tactics.rst:1981
msgid ""
"If some quantified hypothesis of the goal is named :n:`@ident`, then :n:"
"`injection @ident` first introduces the hypothesis in the local context "
"using :n:`intros until @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:1992
msgid ""
"This does the same thing as :n:`intros until @num` followed by :n:`injection "
"@ident` where :n:`@ident` is the identifier for the last introduced "
"hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:1998
msgid ""
"This does the same as :n:`injection @term` but using the given bindings to "
"instantiate parameters or hypotheses of :n:`@term`."
msgstr ""

#: ../../proof-engine/tactics.rst:2005
msgid ""
"This works the same as :n:`injection` but if the type of :n:`@term`, or the "
"type of the hypothesis referred to by :n:`@num`, has uninstantiated "
"parameters, these parameters are left as existential variables."
msgstr ""

#: ../../proof-engine/tactics.rst:2011
msgid ""
"If the current goal is of the form :n:`@term <> @term` , this behaves as :n:"
"`intro @ident; injection @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:2023
msgid ""
"These variants apply :n:`intros {+ @intro_pattern}` after the call to :tacn:"
"`injection` or :tacn:`einjection` so that all equalities generated are moved "
"in the context of hypotheses. The number of :n:`@intro_pattern` must not "
"exceed the number of equalities newly generated. If it is smaller, fresh "
"names are automatically generated to adjust the list of :n:`@intro_pattern` "
"to the number of new equalities. The original equality is erased if it "
"corresponds to a hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:2033
msgid ""
"This option ensure that :n:`injection @term` erases the original hypothesis "
"and leaves the generated equalities in the context rather than putting them "
"as antecedents of the current goal, as if giving :n:`injection @term as` "
"(with an empty list of names). This option is off by default."
msgstr ""

#: ../../proof-engine/tactics.rst:2040
msgid ""
"By default, :tacn:`injection` only creates new equalities between :n:"
"`@terms` whose type is in sort :g:`Type` or :g:`Set`, thus implementing a "
"special behavior for objects that are proofs of a statement in :g:`Prop`. "
"This option controls this behavior."
msgstr ""

#: ../../proof-engine/tactics.rst:2048
msgid ""
"Let the type of :n:`@ident` in the local context be :g:`(I t)`, where :g:`I` "
"is a (co)inductive predicate. Then, ``inversion`` applied to :n:`@ident` "
"derives for each possible constructor :g:`c i` of :g:`(I t)`, all the "
"necessary conditions that should hold for the instance :g:`(I t)` to be "
"proved by :g:`c i`."
msgstr ""

#: ../../proof-engine/tactics.rst:2055
msgid ""
"If :n:`@ident` does not denote a hypothesis in the local context but refers "
"to a hypothesis quantified in the goal, then the latter is first introduced "
"in the local context using :n:`intros until @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:2060
msgid ""
"As ``inversion`` proofs may be large in size, we recommend the user to stock "
"the lemmas whenever the same instance needs to be inverted several times. "
"See :ref:`derive-inversion`."
msgstr ""

#: ../../proof-engine/tactics.rst:2065
msgid ""
"Part of the behavior of the ``inversion`` tactic is to generate equalities "
"between expressions that appeared in the hypothesis that is being processed. "
"By default, no equalities are generated if they relate two proofs (i.e. "
"equalities between :n:`@terms` whose type is in sort :g:`Prop`). This "
"behavior can be turned off by using the option :flag`Keep Proof Equalities`."
msgstr ""

#: ../../proof-engine/tactics.rst:2074
msgid ""
"This does the same thing as :n:`intros until @num` then :n:`inversion "
"@ident` where :n:`@ident` is the identifier for the last introduced "
"hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:2079
msgid ""
"This behaves as :n:`inversion` and then erases :n:`@ident` from the context."
msgstr ""

#: ../../proof-engine/tactics.rst:2083
msgid ""
"This generally behaves as inversion but using names in :n:`@intro_pattern` "
"for naming hypotheses. The :n:`@intro_pattern` must have the form :n:`[p`:"
"sub:`11` :n:`... p`:sub:`1n` :n:`| ... | p`:sub:`m1` :n:`... p`:sub:`mn` :n:"
"`]` with `m` being the number of constructors of the type of :n:`@ident`. Be "
"careful that the list must be of length `m` even if ``inversion`` discards "
"some cases (which is precisely one of its roles): for the discarded cases, "
"just use an empty list (i.e. `n = 0`).The arguments of the i-th constructor "
"and the equalities that ``inversion`` introduces in the context of the goal "
"corresponding to the i-th constructor, if it exists, get their names from "
"the list :n:`p`:sub:`i1` :n:`... p`:sub:`in` in order. If there are not "
"enough names, ``inversion`` invents names for the remaining variables to "
"introduce. In case an equation splits into several equations (because "
"``inversion`` applies ``injection`` on the equalities it generates), the "
"corresponding name :n:`p`:sub:`ij` in the list must be replaced by a sublist "
"of the form :n:`[p`:sub:`ij1` :n:`... p`:sub:`ijq` :n:`]` (or, "
"equivalently, :n:`(p`:sub:`ij1` :n:`, ..., p`:sub:`ijq` :n:`)`) where `q` is "
"the number of subequalities obtained from splitting the original equation. "
"Here is an example. The ``inversion ... as`` variant of ``inversion`` "
"generally behaves in a slightly more expectable way than ``inversion`` (no "
"artificial duplication of some hypotheses referring to other hypotheses). To "
"take benefit of these improvements, it is enough to use ``inversion ... as "
"[]``, letting the names being finally chosen by Coq."
msgstr ""

#: ../../proof-engine/tactics.rst:2118
msgid ""
"This allows naming the hypotheses introduced by :n:`inversion @num` in the "
"context."
msgstr ""

#: ../../proof-engine/tactics.rst:2123
msgid ""
"This allows naming the hypotheses introduced by ``inversion_clear`` in the "
"context. Notice that hypothesis names can be provided as if ``inversion`` "
"were called, even though the ``inversion_clear`` will eventually erase the "
"hypotheses."
msgstr ""

#: ../../proof-engine/tactics.rst:2130
msgid ""
"Let :n:`{+ @ident}` be identifiers in the local context. This tactic behaves "
"as generalizing :n:`{+ @ident}`, and then performing ``inversion``."
msgstr ""

#: ../../proof-engine/tactics.rst:2135
msgid ""
"This allows naming the hypotheses introduced in the context by :n:`inversion "
"@ident in {+ @ident}`."
msgstr ""

#: ../../proof-engine/tactics.rst:2140
msgid ""
"Let :n:`{+ @ident}` be identifiers in the local context. This tactic behaves "
"as generalizing :n:`{+ @ident}`, and then performing ``inversion_clear``."
msgstr ""

#: ../../proof-engine/tactics.rst:2145
msgid ""
"This allows naming the hypotheses introduced in the context by :n:"
"`inversion_clear @ident in {+ @ident}`."
msgstr ""

#: ../../proof-engine/tactics.rst:2151
msgid ""
"That must be used when :n:`@ident` appears in the current goal. It acts like "
"``inversion`` and then substitutes :n:`@ident` for the corresponding :n:"
"`@@term` in the goal."
msgstr ""

#: ../../proof-engine/tactics.rst:2157
msgid ""
"This allows naming the hypotheses introduced in the context by :n:`dependent "
"inversion @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:2162
msgid ""
"Like ``dependent inversion``, except that :n:`@ident` is cleared from the "
"local context."
msgstr ""

#: ../../proof-engine/tactics.rst:2167
msgid ""
"This allows naming the hypotheses introduced in the context by :n:`dependent "
"inversion_clear @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:2173
msgid ""
"This variant allows you to specify the generalization of the goal. It is "
"useful when the system fails to generalize the goal automatically. If :n:"
"`@ident` has type :g:`(I t)` and :g:`I` has type :math:`\\forall` :g:`(x:T), "
"s`, then :n:`@term` must be of type :g:`I:`:math:`\\forall` :g:`(x:T), I x -"
"> s'` where :g:`s'` is the type of the goal."
msgstr ""

#: ../../proof-engine/tactics.rst:2181
msgid ""
"This allows naming the hypotheses introduced in the context by :n:`dependent "
"inversion @ident with @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:2186
msgid ""
"Like :tacn:`dependent inversion ... with ...` with but clears :n:`@ident` "
"from the local context."
msgstr ""

#: ../../proof-engine/tactics.rst:2191
msgid ""
"This allows naming the hypotheses introduced in the context by :n:`dependent "
"inversion_clear @ident with @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:2197
msgid ""
"It is a very primitive inversion tactic that derives all the necessary "
"equalities but it does not simplify the constraints as ``inversion`` does."
msgstr ""

#: ../../proof-engine/tactics.rst:2202
msgid ""
"This allows naming the hypotheses introduced in the context by ``simple "
"inversion``."
msgstr ""

#: ../../proof-engine/tactics.rst:2207
msgid ""
"Let :n:`@ident` have type :g:`(I t)` (:g:`I` an inductive predicate) in the "
"local context, and :n:`@ident` be a (dependent) inversion lemma. Then, this "
"tactic refines the current goal with the specified lemma."
msgstr ""

#: ../../proof-engine/tactics.rst:2213
msgid ""
"This tactic behaves as generalizing :n:`{+ @ident}`, then doing :n:"
"`inversion @ident using @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:2218
msgid ""
"This tactic turns equalities of dependent pairs (e.g., :g:`existT P x p = "
"existT P y q`, frequently left over by inversion on a dependent type family) "
"into pairs of equalities (e.g., a hypothesis :g:`H : x = y` and a hypothesis "
"of type :g:`rew H in p = q`); these hypotheses can subsequently be "
"simplified using :tacn:`subst`, without ever invoking any kind of axiom "
"asserting uniqueness of identity proofs. If you want to explicitly specify "
"the hypothesis to be inverted, or name the generated hypotheses, you can "
"invoke :n:`induction H as [H1 H2] using eq_sigT_rect.` This tactic also "
"works for :g:`sig`, :g:`sigT2`, and :g:`sig2`, and there are similar :g:"
"`eq_sig` :g:`***_rect` induction lemmas."
msgstr ""

#: ../../proof-engine/tactics.rst:2232
msgid "*Non-dependent inversion*."
msgstr ""

#: ../../proof-engine/tactics.rst:2234
msgid ""
"Let us consider the relation Le over natural numbers and the following "
"variables:"
msgstr ""

#: ../../proof-engine/tactics.rst:2245 ../../proof-engine/tactics.rst:2282
msgid "Let us consider the following goal:"
msgstr ""

#: ../../proof-engine/tactics.rst:2256
msgid ""
"To prove the goal, we may need to reason by cases on H and to derive that m "
"is necessarily of the form (S m 0 ) for certain m 0 and that (Le n m 0 ). "
"Deriving these conditions corresponds to proving that the only possible "
"constructor of (Le (S n) m) isLeS and that we can invert the-> in the type "
"of LeS. This inversion is possible because Le is the smallest set closed by "
"the constructors LeO and LeS."
msgstr ""

#: ../../proof-engine/tactics.rst:2267
msgid ""
"Note that m has been substituted in the goal for (S m0) and that the "
"hypothesis (Le n m0) has been added to the context."
msgstr ""

#: ../../proof-engine/tactics.rst:2270
msgid ""
"Sometimes it is interesting to have the equality m=(S m0) in the context to "
"use it after. In that case we can use inversion that does not clear the "
"equalities:"
msgstr ""

#: ../../proof-engine/tactics.rst:2280
msgid "*Dependent inversion.*"
msgstr ""

#: ../../proof-engine/tactics.rst:2298
msgid ""
"As H occurs in the goal, we may want to reason by cases on its structure and "
"so, we would like inversion tactics to substitute H by the corresponding "
"@term in constructor form. Neither :tacn:`inversion` nor :n:"
"`inversion_clear` do such a substitution. To have such a behavior we use the "
"dependent inversion tactics:"
msgstr ""

#: ../../proof-engine/tactics.rst:2308
msgid "Note that H has been substituted by (LeS n m0 l) andm by (S m0)."
msgstr ""

#: ../../proof-engine/tactics.rst:2312
msgid "*Using inversion_sigma.*"
msgstr ""

#: ../../proof-engine/tactics.rst:2314
msgid ""
"Let us consider the following inductive type of length-indexed lists, and a "
"lemma about inverting equality of cons:"
msgstr ""

#: ../../proof-engine/tactics.rst:2332
msgid "After performing inversion, we are left with an equality of existTs:"
msgstr ""

#: ../../proof-engine/tactics.rst:2338
msgid "We can turn this equality into a usable form with inversion_sigma:"
msgstr ""

#: ../../proof-engine/tactics.rst:2344
msgid ""
"To finish cleaning up the proof, we will need to use the fact that that all "
"proofs of n = n for n a nat are eq_refl:"
msgstr ""

#: ../../proof-engine/tactics.rst:2353
msgid "Finally, we can finish the proof:"
msgstr ""

#: ../../proof-engine/tactics.rst:2363
msgid ""
"This tactic is a primitive tactic to start a proof by induction. In general, "
"it is easier to rely on higher-level induction tactics such as the ones "
"described in :tacn:`induction`."
msgstr ""

#: ../../proof-engine/tactics.rst:2367
msgid ""
"In the syntax of the tactic, the identifier :n:`@ident` is the name given to "
"the induction hypothesis. The natural number :n:`@num` tells on which "
"premise of the current goal the induction acts, starting from 1, counting "
"both dependent and non dependent products, but skipping local definitions. "
"Especially, the current lemma must be composed of at least :n:`@num` "
"products."
msgstr ""

#: ../../proof-engine/tactics.rst:2374
msgid ""
"Like in a fix expression, the induction hypotheses have to be used on "
"structurally smaller arguments. The verification that inductive proof "
"arguments are correct is done only at the time of registering the lemma in "
"the environment. To know if the use of induction hypotheses is correct at "
"some time of the interactive development of a proof, use the command "
"``Guarded`` (see Section :ref:`requestinginformation`)."
msgstr ""

#: ../../proof-engine/tactics.rst:2383
msgid ""
"This starts a proof by mutual induction. The statements to be simultaneously "
"proved are respectively :g:`forall binder ... binder, type`. The "
"identifiers :n:`@ident` are the names of the induction hypotheses. The "
"identifiers :n:`@ident` are the respective names of the premises on which "
"the induction is performed in the statements to be simultaneously proved (if "
"not given, the system tries to guess itself what they are)."
msgstr ""

#: ../../proof-engine/tactics.rst:2393
msgid ""
"This tactic starts a proof by coinduction. The identifier :n:`@ident` is the "
"name given to the coinduction hypothesis. Like in a cofix expression, the "
"use of induction hypotheses have to guarded by a constructor. The "
"verification that the use of co-inductive hypotheses is correct is done only "
"at the time of registering the lemma in the environment. To know if the use "
"of coinduction hypotheses is correct at some time of the interactive "
"development of a proof, use the command ``Guarded`` (see Section :ref:"
"`requestinginformation`)."
msgstr ""

#: ../../proof-engine/tactics.rst:2404
msgid ""
"This starts a proof by mutual coinduction. The statements to be "
"simultaneously proved are respectively :g:`forall binder ... binder, type` "
"The identifiers :n:`@ident` are the names of the coinduction hypotheses."
msgstr ""

#: ../../proof-engine/tactics.rst:2411
msgid "Rewriting expressions"
msgstr ""

#: ../../proof-engine/tactics.rst:2413
msgid ""
"These tactics use the equality :g:`eq:forall A:Type, A->A->Prop` defined in "
"file ``Logic.v`` (see :ref:`coq-library-logic`). The notation for :g:`eq T t "
"u` is simply :g:`t=u` dropping the implicit type of :g:`t` and :g:`u`."
msgstr ""

#: ../../proof-engine/tactics.rst:2420
msgid ""
"This tactic applies to any goal. The type of :token:`term` must have the form"
msgstr ""

#: ../../proof-engine/tactics.rst:2422
msgid ""
"``forall (x``:sub:`1` ``:A``:sub:`1` ``) ... (x``:sub:`n` ``:A``:sub:`n` "
"``). eq term``:sub:`1` ``term``:sub:`2` ``.``"
msgstr ""

#: ../../proof-engine/tactics.rst:2424
msgid "where :g:`eq` is the Leibniz equality or a registered setoid equality."
msgstr ""

#: ../../proof-engine/tactics.rst:2426
msgid ""
"Then :n:`rewrite @term` finds the first subterm matching `term`\\ :sub:`1` "
"in the goal, resulting in instances `term`:sub:`1`' and `term`:sub:`2`' and "
"then replaces every occurrence of `term`:subscript:`1`' by `term`:subscript:"
"`2`'. Hence, some of the variables :g:`x`\\ :sub:`i` are solved by "
"unification, and some of the types :g:`A`\\ :sub:`1`:g:`, ..., A`\\ :sub:`n` "
"become new subgoals."
msgstr ""

#: ../../proof-engine/tactics.rst:2439
msgid "Is equivalent to :n:`rewrite @term`"
msgstr ""

#: ../../proof-engine/tactics.rst:2443
msgid ""
"Uses the equality :n:`@term`:sub:`1` :n:`= @term` :sub:`2` from right to left"
msgstr ""

#: ../../proof-engine/tactics.rst:2447
msgid ""
"Analogous to :n:`rewrite @term` but rewriting is done following clause "
"(similarly to :ref:`performing computations <performingcomputations>`). For "
"instance:"
msgstr ""

#: ../../proof-engine/tactics.rst:2450
msgid ""
":n:`rewrite H in H`:sub:`1` will rewrite `H` in the hypothesis `H`:sub:`1` "
"instead of the current goal."
msgstr ""

#: ../../proof-engine/tactics.rst:2452
msgid ""
":n:`rewrite H in H`:sub:`1` :g:`at 1, H`:sub:`2` :g:`at - 2 |- *` means :n:"
"`rewrite H; rewrite H in H`:sub:`1` :g:`at 1; rewrite H in H`:sub:`2` :g:`at "
"- 2.` In particular a failure will happen if any of these three simpler "
"tactics fails."
msgstr ""

#: ../../proof-engine/tactics.rst:2456
msgid ""
":n:`rewrite H in * |-` will do :n:`rewrite H in H`:sub:`i` for all "
"hypotheses :g:`H`:sub:`i` different from :g:`H`. A success will happen as "
"soon as at least one of these simpler tactics succeeds."
msgstr ""

#: ../../proof-engine/tactics.rst:2459
msgid ""
":n:`rewrite H in *` is a combination of :n:`rewrite H` and :n:`rewrite H in "
"* |-` that succeeds if at least one of these two tactics succeeds."
msgstr ""

#: ../../proof-engine/tactics.rst:2462
msgid ""
"Orientation :g:`->` or :g:`<-` can be inserted before the :token:`term` to "
"rewrite."
msgstr ""

#: ../../proof-engine/tactics.rst:2466
msgid ""
"Rewrite only the given occurrences of :token:`term`. Occurrences are "
"specified from left to right as for pattern (:tacn:`pattern`). The rewrite "
"is always performed using setoid rewriting, even for Leibniz’s equality, so "
"one has to ``Import Setoid`` to use this variant."
msgstr ""

#: ../../proof-engine/tactics.rst:2473
msgid ""
"Use tactic to completely solve the side-conditions arising from the :tacn:"
"`rewrite`."
msgstr ""

#: ../../proof-engine/tactics.rst:2478
msgid ""
"Is equivalent to the `n` successive tactics :n:`{+; rewrite @term}`, each "
"one working on the first subgoal generated by the previous one. Orientation :"
"g:`->` or :g:`<-` can be inserted before each :token:`term` to rewrite.  One "
"unique clause can be added at the end after the keyword in; it will then "
"affect all rewrite operations."
msgstr ""

#: ../../proof-engine/tactics.rst:2484
msgid ""
"In all forms of rewrite described above, a :token:`term` to rewrite can be "
"immediately prefixed by one of the following modifiers:"
msgstr ""

#: ../../proof-engine/tactics.rst:2487
msgid ""
"`?` : the tactic :n:`rewrite ?@term` performs the rewrite of :token:`term` "
"as many times as possible (perhaps zero time). This form never fails."
msgstr ""

#: ../../proof-engine/tactics.rst:2489
msgid ""
":n:`@num?` : works similarly, except that it will do at most :token:`num` "
"rewrites."
msgstr ""

#: ../../proof-engine/tactics.rst:2490
msgid ""
"`!` : works as `?`, except that at least one rewrite should succeed, "
"otherwise the tactic fails."
msgstr ""

#: ../../proof-engine/tactics.rst:2492
msgid ""
":n:`@num!` (or simply :n:`@num`) : precisely :token:`num` rewrites of :token:"
"`term` will be done, leading to failure if these :token:`num` rewrites are "
"not possible."
msgstr ""

#: ../../proof-engine/tactics.rst:2498
msgid ""
"This tactic works as :n:`rewrite @term` but turning unresolved bindings into "
"existential variables, if any, instead of failing. It has the same variants "
"as :tacn:`rewrite` has."
msgstr ""

#: ../../proof-engine/tactics.rst:2505
msgid ""
"This tactic applies to any goal. It replaces all free occurrences of :n:"
"`@term` in the current goal with :n:`@term’` and generates an equality :n:"
"`@term = @term’` as a subgoal. This equality is automatically solved if it "
"occurs among the assumptions, or if its symmetric form occurs. It is "
"equivalent to :n:`cut @term = @term’; [intro H`:sub:`n` :n:`; rewrite <- H`:"
"sub:`n` :n:`; clear H`:sub:`n`:n:`|| assumption || symmetry; try "
"assumption]`."
msgstr ""

#: ../../proof-engine/tactics.rst:2515
msgid ""
"This acts as :n:`replace @term with @term’` but applies :token:`tactic` to "
"solve the generated subgoal :n:`@term = @term’`."
msgstr ""

#: ../../proof-engine/tactics.rst:2520
msgid ""
"Replaces :n:`@term` with :n:`@term’` using the first assumption whose type "
"has the form :n:`@term = @term’` or :n:`@term’ = @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:2525
msgid ""
"Replaces :n:`@term` with :n:`@term’` using the first assumption whose type "
"has the form :n:`@term = @term’`"
msgstr ""

#: ../../proof-engine/tactics.rst:2530
msgid ""
"Replaces :n:`@term` with :n:`@term’` using the first assumption whose type "
"has the form :n:`@term’ = @term`"
msgstr ""

#: ../../proof-engine/tactics.rst:2537
msgid ""
"Acts as before but the replacements take place in the specified clause (see :"
"ref:`performingcomputations`) and not only in the conclusion of the goal. "
"The clause argument must not contain any ``type of`` nor ``value of``."
msgstr ""

#: ../../proof-engine/tactics.rst:2544
msgid ""
"This tactic is deprecated. It can be replaced by :n:`enough (@term = @term’) "
"as <-`."
msgstr ""

#: ../../proof-engine/tactics.rst:2548
msgid ""
"This tactic is deprecated. It can be replaced by :n:`enough (@term = @term’) "
"as ->`."
msgstr ""

#: ../../proof-engine/tactics.rst:2554
msgid ""
"This tactic applies to a goal that has :n:`@ident` in its context and (at "
"least) one hypothesis, say :g:`H`, of type :n:`@ident = t` or :n:`t = "
"@ident` with :n:`@ident` not occurring in :g:`t`. Then it replaces :n:"
"`@ident` by :g:`t` everywhere in the goal (in the hypotheses and in the "
"conclusion) and clears :n:`@ident` and :g:`H` from the context."
msgstr ""

#: ../../proof-engine/tactics.rst:2560
msgid ""
"If :n:`@ident` is a local definition of the form :n:`@ident := t`, it is "
"also unfolded and cleared."
msgstr ""

#: ../../proof-engine/tactics.rst:2564
msgid ""
"When several hypotheses have the form :n:`@ident = t` or :n:`t = @ident`, "
"the first one is used."
msgstr ""

#: ../../proof-engine/tactics.rst:2567
msgid ""
"If :g:`H` is itself dependent in the goal, it is replaced by the proof of "
"reflexivity of equality."
msgstr ""

#: ../../proof-engine/tactics.rst:2572
msgid ""
"This is equivalent to :n:`subst @ident`:sub:`1`:n:`; ...; subst @ident`:sub:"
"`n`."
msgstr ""

#: ../../proof-engine/tactics.rst:2576
msgid ""
"This applies subst repeatedly from top to bottom to all identifiers of the "
"context for which an equality of the form :n:`@ident = t` or :n:`t = @ident` "
"or :n:`@ident := t` exists, with :n:`@ident` not occurring in ``t``."
msgstr ""

#: ../../proof-engine/tactics.rst:2582
msgid ""
"This option controls the behavior of :tacn:`subst`. When it is activated (it "
"is by default), :tacn:`subst` also deals with the following corner cases:"
msgstr ""

#: ../../proof-engine/tactics.rst:2585
msgid ""
"A context with ordered hypotheses :n:`@ident`:sub:`1` :n:`= @ident`:sub:`2` "
"and :n:`@ident`:sub:`1` :n:`= t`, or :n:`t′ = @ident`:sub:`1`` with `t′` not "
"a variable, and no other hypotheses of the form :n:`@ident`:sub:`2` :n:`= u` "
"or :n:`u = @ident`:sub:`2`; without the option, a second call to subst would "
"be necessary to replace :n:`@ident`:sub:`2` by `t` or `t′` respectively."
msgstr ""

#: ../../proof-engine/tactics.rst:2591
msgid ""
"The presence of a recursive equation which without the option would be a "
"cause of failure of :tacn:`subst`."
msgstr ""

#: ../../proof-engine/tactics.rst:2593
msgid ""
"A context with cyclic dependencies as with hypotheses :n:`@ident`:sub:`1` :n:"
"`= f @ident`:sub:`2` and :n:`@ident`:sub:`2` :n:`= g @ident`:sub:`1` which "
"without the option would be a cause of failure of :tacn:`subst`."
msgstr ""

#: ../../proof-engine/tactics.rst:2597
msgid ""
"Additionally, it prevents a local definition such as :n:`@ident := t` to be "
"unfolded which otherwise it would exceptionally unfold in configurations "
"containing hypotheses of the form :n:`@ident = u`, or :n:`u′ = @ident` with "
"`u′` not a variable. Finally, it preserves the initial order of hypotheses, "
"which without the option it may break. default."
msgstr ""

#: ../../proof-engine/tactics.rst:2608
msgid ""
"This tactic is for chaining rewriting steps. It assumes a goal of the form :"
"n:`R @term @term` where ``R`` is a binary relation and relies on a database "
"of lemmas of the form :g:`forall x y z, R x y -> eq x z -> R z y` where `eq` "
"is typically a setoid equality. The application of :n:`stepl @term` then "
"replaces the goal by :n:`R @term @term` and adds a new goal stating :n:`eq "
"@term @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:2617
msgid "Adds :n:`@term` to the database used by :tacn:`stepl`."
msgstr ""

#: ../../proof-engine/tactics.rst:2619
msgid ""
"This tactic is especially useful for parametric setoids which are not "
"accepted as regular setoids for :tacn:`rewrite` and :tacn:`setoid_replace` "
"(see :ref:`Generalizedrewriting`)."
msgstr ""

#: ../../proof-engine/tactics.rst:2625
msgid ""
"This applies :n:`stepl @term` then applies :token:`tactic` to the second "
"goal."
msgstr ""

#: ../../proof-engine/tactics.rst:2630
msgid ""
"This behaves as :tacn:`stepl` but on the right-hand-side of the binary "
"relation. Lemmas are expected to be of the form :g:`forall x y z, R x y -> "
"eq y z -> R x z`."
msgstr ""

#: ../../proof-engine/tactics.rst:2636
msgid "Adds :n:`@term` to the database used by :tacn:`stepr`."
msgstr ""

#: ../../proof-engine/tactics.rst:2642
msgid ""
"This tactic applies to any goal. It implements the rule ``Conv`` given in :"
"ref:`subtyping-rules`. :g:`change U` replaces the current goal `T` with `U` "
"providing that `U` is well-formed and that `T` and `U` are convertible."
msgstr ""

#: ../../proof-engine/tactics.rst:2651
msgid ""
"This replaces the occurrences of :n:`@term` by :n:`@term’` in the current "
"goal. The term :n:`@term` and :n:`@term’` must be convertible."
msgstr ""

#: ../../proof-engine/tactics.rst:2656
msgid ""
"This replaces the occurrences numbered :n:`{+ @num}` of :n:`@term` by :n:"
"`@term’` in the current goal. The terms :n:`@term` and :n:`@term’` must be "
"convertible."
msgstr ""

#: ../../proof-engine/tactics.rst:2663
msgid ""
"This applies the :tacn:`change` tactic not to the goal but to the "
"hypothesis :n:`@ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:2665
msgid ":ref:`Performing computations <performingcomputations>`"
msgstr ""

#: ../../proof-engine/tactics.rst:2670
msgid "Performing computations"
msgstr ""

#: ../../proof-engine/tactics.rst:2672
msgid ""
"This set of tactics implements different specialized usages of the tactic :"
"tacn:`change`."
msgstr ""

#: ../../proof-engine/tactics.rst:2675
msgid ""
"All conversion tactics (including :tacn:`change`) can be parameterized by "
"the parts of the goal where the conversion can occur. This is done using "
"*goal clauses* which consists in a list of hypotheses and, optionally, of a "
"reference to the conclusion of the goal. For defined hypothesis it is "
"possible to specify if the conversion should occur on the type part, the "
"body part or both (default)."
msgstr ""

#: ../../proof-engine/tactics.rst:2682
msgid ""
"Goal clauses are written after a conversion tactic (tactics :tacn:`set`, :"
"tacn:`rewrite`, :tacn:`replace` and :tacn:`autorewrite` also use goal "
"clauses) and are introduced by the keyword `in`. If no goal clause is "
"provided, the default is to perform the conversion only in the conclusion."
msgstr ""

#: ../../proof-engine/tactics.rst:2688
msgid ""
"The syntax and description of the various goal clauses is the following:"
msgstr ""

#: ../../proof-engine/tactics.rst:2691
msgid ":n:`in {+ @ident} |-`  only in hypotheses :n:`{+ @ident}`"
msgstr ""

#: ../../proof-engine/tactics.rst:2692
msgid ""
":n:`in {+ @ident} |- *` in hypotheses :n:`{+ @ident}` and in the conclusion"
msgstr ""

#: ../../proof-engine/tactics.rst:2694
msgid ":n:`in * |-` in every hypothesis"
msgstr ""

#: ../../proof-engine/tactics.rst:2695
msgid ":n:`in *` (equivalent to in :n:`* |- *`) everywhere"
msgstr ""

#: ../../proof-engine/tactics.rst:2696
msgid ""
":n:`in (type of @ident) (value of @ident) ... |-` in type part of :n:"
"`@ident`, in the value part of :n:`@ident`, etc."
msgstr ""

#: ../../proof-engine/tactics.rst:2699
msgid ""
"For backward compatibility, the notation :n:`in {+ @ident}` performs the "
"conversion in hypotheses :n:`{+ @ident}`."
msgstr ""

#: ../../proof-engine/tactics.rst:2709
msgid ""
"These parameterized reduction tactics apply to any goal and perform the "
"normalization of the goal according to the specified flags. In "
"correspondence with the kinds of reduction considered in Coq namely :math:`"
"\\beta` (reduction of functional application), :math:`\\delta` (unfolding of "
"transparent constants, see :ref:`vernac-controlling-the-reduction-"
"strategies`), :math:`\\iota` (reduction of pattern matching over a "
"constructed term, and unfolding of :g:`fix` and :g:`cofix` expressions) and :"
"math:`\\zeta` (contraction of local definitions), the flags are either "
"``beta``, ``delta``, ``match``, ``fix``, ``cofix``, ``iota`` or ``zeta``. "
"The ``iota`` flag is a shorthand for ``match``, ``fix`` and ``cofix``. The "
"``delta`` flag itself can be refined into :n:`delta {+ @qualid}` or :n:"
"`delta -{+ @qualid}`, restricting in the first case the constants to unfold "
"to the constants listed, and restricting in the second case the constant to "
"unfold to all but the ones explicitly mentioned. Notice that the ``delta`` "
"flag does not apply to variables bound by a let-in construction inside the :"
"n:`@term` itself (use here the ``zeta`` flag). In any cases, opaque "
"constants are not unfolded (see :ref:`vernac-controlling-the-reduction-"
"strategies`)."
msgstr ""

#: ../../proof-engine/tactics.rst:2727
msgid ""
"Normalization according to the flags is done by first evaluating the head of "
"the expression into a *weak-head* normal form, i.e. until the evaluation is "
"blocked by a variable (or an opaque constant, or an axiom), as e.g. in :g:`x "
"u1 ... un` , or :g:`match x with ... end`, or :g:`(fix f x {struct x} :"
"= ...) x`, or is a constructed form (a :math:`\\lambda`-expression, a "
"constructor, a cofixpoint, an inductive type, a product type, a sort), or is "
"a redex that the flags prevent to reduce. Once a weak-head normal form is "
"obtained, subterms are recursively reduced using the same strategy."
msgstr ""

#: ../../proof-engine/tactics.rst:2737
msgid ""
"Reduction to weak-head normal form can be done using two strategies: *lazy* "
"(``lazy`` tactic), or *call-by-value* (``cbv`` tactic). The lazy strategy is "
"a call-by-need strategy, with sharing of reductions: the arguments of a "
"function call are weakly evaluated only when necessary, and if an argument "
"is used several times then it is weakly computed only once. This reduction "
"is efficient for reducing expressions with dead code. For instance, the "
"proofs of a proposition :g:`exists x. P(x)` reduce to a pair of a witness :g:"
"`t`, and a proof that :g:`t` satisfies the predicate :g:`P`. Most of the "
"time, :g:`t` may be computed without computing the proof of :g:`P(t)`, "
"thanks to the lazy strategy."
msgstr ""

#: ../../proof-engine/tactics.rst:2748
msgid ""
"The call-by-value strategy is the one used in ML languages: the arguments of "
"a function call are systematically weakly evaluated first. Despite the lazy "
"strategy always performs fewer reductions than the call-by-value strategy, "
"the latter is generally more efficient for evaluating purely computational "
"expressions (i.e. with little dead code)."
msgstr ""

#: ../../proof-engine/tactics.rst:2757
msgid "These are synonyms for ``cbv beta delta iota zeta``."
msgstr ""

#: ../../proof-engine/tactics.rst:2761
msgid "This is a synonym for ``lazy beta delta iota zeta``."
msgstr ""

#: ../../proof-engine/tactics.rst:2766
msgid "These are synonyms of :n:`cbv beta delta {+ @qualid} iota zeta`."
msgstr ""

#: ../../proof-engine/tactics.rst:2771
msgid "These are synonyms of :n:`cbv beta delta -{+ @qualid} iota zeta`."
msgstr ""

#: ../../proof-engine/tactics.rst:2776
msgid ""
"These are respectively synonyms of :n:`lazy beta delta {+ @qualid} iota "
"zeta` and :n:`lazy beta delta -{+ @qualid} iota zeta`."
msgstr ""

#: ../../proof-engine/tactics.rst:2782
msgid ""
"This tactic evaluates the goal using the optimized call-by-value evaluation "
"bytecode-based virtual machine described in :cite:`CompiledStrongReduction`. "
"This algorithm is dramatically more efficient than the algorithm used for "
"the ``cbv`` tactic, but it cannot be fine-tuned. It is specially interesting "
"for full evaluation of algebraic objects. This includes the case of "
"reflection-based tactics."
msgstr ""

#: ../../proof-engine/tactics.rst:2792
msgid ""
"This tactic evaluates the goal by compilation to Objective Caml as described "
"in :cite:`FullReduction`. If Coq is running in native code, it can be "
"typically two to five times faster than ``vm_compute``. Note however that "
"the compilation cost is higher, so it is worth using only for intensive "
"computations."
msgstr ""

#: ../../proof-engine/tactics.rst:2800
msgid ""
"On Linux, if you have the ``perf`` profiler installed, this option makes it "
"possible to profile ``native_compute`` evaluations."
msgstr ""

#: ../../proof-engine/tactics.rst:2806
msgid ""
"This option specifies the profile output; the default is "
"``native_compute_profile.data``. The actual filename used will contain extra "
"characters to avoid overwriting an existing file; that filename is reported "
"to the user. That means you can individually profile multiple uses of "
"``native_compute`` in a script. From the Linux command line, run ``perf "
"report`` on the profile file to see the results. Consult the ``perf`` "
"documentation for more details."
msgstr ""

#: ../../proof-engine/tactics.rst:2817
msgid ""
"This option makes :tacn:`cbv` (and its derivative :tacn:`compute`) print "
"information about the constants it encounters and the unfolding decisions it "
"makes."
msgstr ""

#: ../../proof-engine/tactics.rst:2824
msgid "This tactic applies to a goal that has the form::"
msgstr ""

#: ../../proof-engine/tactics.rst:2828
msgid ""
"with :g:`T` :math:`\\beta`:math:`\\iota`:math:`\\zeta`-reducing to :g:`c t`:"
"sub:`1` :g:`... t`:sub:`n` and :g:`c` a constant. If :g:`c` is transparent "
"then it replaces :g:`c` with its definition (say :g:`t`) and then reduces :g:"
"`(t t`:sub:`1` :g:`... t`:sub:`n` :g:`)` according to :math:`\\beta`:math:`"
"\\iota`:math:`\\zeta`-reduction rules."
msgstr ""

#: ../../proof-engine/tactics.rst:2842
msgid ""
"This tactic applies to any goal. It replaces the current goal with its head "
"normal form according to the :math:`\\beta`:math:`\\delta`:math:`\\iota`:"
"math:`\\zeta`-reduction rules, i.e. it reduces the head of the goal until it "
"becomes a product or an irreducible term. All inner :math:`\\beta`:math:`"
"\\iota`-redexes are also reduced."
msgstr ""

#: ../../proof-engine/tactics.rst:2847
msgid ""
"Example: The term :g:`fun n : nat => S n + S n` is not reduced by :n:`hnf`."
msgstr ""

#: ../../proof-engine/tactics.rst:2850
msgid ""
"The :math:`\\delta` rule only applies to transparent constants (see :ref:"
"`vernac-controlling-the-reduction-strategies` on transparency and opacity)."
msgstr ""

#: ../../proof-engine/tactics.rst:2858
msgid ""
"These tactics apply to any goal. They try to reduce a term to something "
"still readable instead of fully normalizing it. They perform a sort of "
"strong normalization with two key differences:"
msgstr ""

#: ../../proof-engine/tactics.rst:2862
msgid ""
"They unfold a constant if and only if it leads to a :math:`\\iota`-"
"reduction, i.e. reducing a match or unfolding a fixpoint."
msgstr ""

#: ../../proof-engine/tactics.rst:2864
msgid ""
"While reducing a constant unfolding to (co)fixpoints, the tactics use the "
"name of the constant the (co)fixpoint comes from instead of the (co)fixpoint "
"definition in recursive calls."
msgstr ""

#: ../../proof-engine/tactics.rst:2868
msgid ""
"The ``cbn`` tactic is claimed to be a more principled, faster and more "
"predictable replacement for ``simpl``."
msgstr ""

#: ../../proof-engine/tactics.rst:2871
msgid ""
"The ``cbn`` tactic accepts the same flags as ``cbv`` and ``lazy``. The "
"behavior of both ``simpl`` and ``cbn`` can be tuned using the Arguments "
"vernacular command as follows:"
msgstr ""

#: ../../proof-engine/tactics.rst:2875
msgid "A constant can be marked to be never unfolded by ``cbn`` or ``simpl``:"
msgstr ""

#: ../../proof-engine/tactics.rst:2883
msgid ""
"After that command an expression like :g:`(minus (S x) y)` is left untouched "
"by the tactics ``cbn`` and ``simpl``."
msgstr ""

#: ../../proof-engine/tactics.rst:2886
msgid ""
"A constant can be marked to be unfolded only if applied to enough arguments. "
"The number of arguments required can be specified using the ``/`` symbol in "
"the argument list of the :cmd:`Arguments` vernacular command."
msgstr ""

#: ../../proof-engine/tactics.rst:2898
msgid ""
"After that command the expression :g:`(f \\o g)` is left untouched by "
"``simpl`` while :g:`((f \\o g) t)` is reduced to :g:`(f (g t))`. The same "
"mechanism can be used to make a constant volatile, i.e. always unfolded."
msgstr ""

#: ../../proof-engine/tactics.rst:2910
msgid ""
"A constant can be marked to be unfolded only if an entire set of arguments "
"evaluates to a constructor. The ``!`` symbol can be used to mark such "
"arguments."
msgstr ""

#: ../../proof-engine/tactics.rst:2920
msgid ""
"After that command, the expression :g:`(minus (S x) y)` is left untouched by "
"``simpl``, while :g:`(minus (S x) (S y))` is reduced to :g:`(minus x y)`."
msgstr ""

#: ../../proof-engine/tactics.rst:2923
msgid ""
"A special heuristic to determine if a constant has to be unfolded can be "
"activated with the following command:"
msgstr ""

#: ../../proof-engine/tactics.rst:2932
msgid ""
"The heuristic avoids to perform a simplification step that would expose a "
"match construct in head position. For example the expression :g:`(minus (S "
"(S x)) (S y))` is simplified to :g:`(minus (S x) y)` even if an extra "
"simplification is possible."
msgstr ""

#: ../../proof-engine/tactics.rst:2937
msgid ""
"In detail, the tactic ``simpl`` first applies :math:`\\beta`:math:`\\iota`-"
"reduction. Then, it expands transparent constants and tries to reduce "
"further using :math:`\\beta`:math:`\\iota`- reduction. But, when no :math:`"
"\\iota` rule is applied after unfolding then :math:`\\delta`-reductions are "
"not applied. For instance trying to use ``simpl`` on :g:`(plus n O) = n` "
"changes nothing."
msgstr ""

#: ../../proof-engine/tactics.rst:2943
msgid ""
"Notice that only transparent constants whose name can be reused in the "
"recursive calls are possibly unfolded by ``simpl``. For instance a constant "
"defined by :g:`plus' := plus` is possibly unfolded and reused in the "
"recursive calls, but a constant such as :g:`succ := plus (S O)` is never "
"unfolded. This is the main difference between ``simpl`` and ``cbn``. The "
"tactic ``cbn`` reduces whenever it will be able to reuse it or not: :g:`succ "
"t` is reduced to :g:`S t`."
msgstr ""

#: ../../proof-engine/tactics.rst:2954
msgid ""
"These are respectively synonyms of :n:`cbn beta delta {+ @qualid} iota zeta` "
"and :n:`cbn beta delta -{+ @qualid} iota zeta` (see :tacn:`cbn`)."
msgstr ""

#: ../../proof-engine/tactics.rst:2959
msgid ""
"This applies ``simpl`` only to the subterms matching :n:`@pattern` in the "
"current goal."
msgstr ""

#: ../../proof-engine/tactics.rst:2964
msgid ""
"This applies ``simpl`` only to the :n:`{+ @num}` occurrences of the subterms "
"matching :n:`@pattern` in the current goal."
msgstr ""

#: ../../proof-engine/tactics.rst:2972
msgid ""
"This applies ``simpl`` only to the applicative subterms whose head "
"occurrence is the unfoldable constant :n:`@qualid` (the constant can be "
"referred to by its notation using :n:`@string` if such a notation exists)."
msgstr ""

#: ../../proof-engine/tactics.rst:2979
msgid ""
"This applies ``simpl`` only to the :n:`{+ @num}` applicative subterms whose "
"head occurrence is :n:`@qualid` (or :n:`@string`)."
msgstr ""

#: ../../proof-engine/tactics.rst:2984
msgid ""
"This option makes :tacn:`cbn` print various debugging information. ``RAKAM`` "
"is the Refolding Algebraic Krivine Abstract Machine."
msgstr ""

#: ../../proof-engine/tactics.rst:2990
msgid ""
"This tactic applies to any goal. The argument qualid must denote a defined "
"transparent constant or local definition (see :ref:`gallina-definitions` "
"and :ref:`vernac-controlling-the-reduction-strategies`). The tactic "
"``unfold`` applies the :math:`\\delta` rule to each occurrence of the "
"constant to which :n:`@qualid` refers in the current goal and then replaces "
"it with its :math:`\\beta`:math:`\\iota`-normal form."
msgstr ""

#: ../../proof-engine/tactics.rst:3001
msgid ""
"Replaces :n:`@qualid` in hypothesis :n:`@ident` with its definition and "
"replaces the hypothesis with its :math:`\\beta`:math:`\\iota` normal form."
msgstr ""

#: ../../proof-engine/tactics.rst:3006
msgid ""
"Replaces *simultaneously* :n:`{+, @qualid}` with their definitions and "
"replaces the current goal with its :math:`\\beta`:math:`\\iota` normal form."
msgstr ""

#: ../../proof-engine/tactics.rst:3011
msgid ""
"The lists :n:`{+, @num}` specify the occurrences of :n:`@qualid` to be "
"unfolded. Occurrences are located from left to right."
msgstr ""

#: ../../proof-engine/tactics.rst:3020
msgid ""
"If :n:`@string` denotes the discriminating symbol of a notation (e.g. \"+\") "
"or an expression defining a notation (e.g. `\"_ + _\"`), and this notation "
"refers to an unfoldable constant, then the tactic unfolds it."
msgstr ""

#: ../../proof-engine/tactics.rst:3026
msgid ""
"This is variant of :n:`unfold @string` where :n:`@string` gets its "
"interpretation from the scope bound to the delimiting key :n:`key` instead "
"of its default interpretation (see :ref:"
"`Localinterpretationrulesfornotations`)."
msgstr ""

#: ../../proof-engine/tactics.rst:3031
msgid ""
"This is the most general form, where :n:`qualid_or_string` is either a :n:"
"`@qualid` or a :n:`@string` referring to a notation."
msgstr ""

#: ../../proof-engine/tactics.rst:3037
msgid ""
"This tactic applies to any goal. The term :n:`@term` is reduced using the "
"``red`` tactic. Every occurrence of the resulting :n:`@term` in the goal is "
"then replaced by :n:`@term`."
msgstr ""

#: ../../proof-engine/tactics.rst:3043
msgid "Equivalent to :n:`fold @term ; ... ; fold @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:3048
msgid ""
"This command applies to any goal. The argument :n:`@term` must be a free "
"subterm of the current goal. The command pattern performs :math:`\\beta`-"
"expansion (the inverse of :math:`\\beta`-reduction) of the current goal "
"(say :g:`T`) by"
msgstr ""

#: ../../proof-engine/tactics.rst:3052
msgid "replacing all occurrences of :n:`@term` in :g:`T` with a fresh variable"
msgstr ""

#: ../../proof-engine/tactics.rst:3053
msgid "abstracting this variable"
msgstr ""

#: ../../proof-engine/tactics.rst:3054
msgid "applying the abstracted goal to :n:`@term`"
msgstr ""

#: ../../proof-engine/tactics.rst:3056
msgid ""
"For instance, if the current goal :g:`T` is expressible as :math:`\\varphi`:"
"g:`(t)` where the notation captures all the instances of :g:`t` in :math:`"
"\\varphi`:g:`(t)`, then :n:`pattern t` transforms it into :g:`(fun x:A =>` :"
"math:`\\varphi`:g:`(x)) t`. This tactic can be used, for instance, when the "
"tactic ``apply`` fails on matching."
msgstr ""

#: ../../proof-engine/tactics.rst:3064
msgid ""
"Only the occurrences :n:`{+ @num}` of :n:`@term` are considered for :math:`"
"\\beta`-expansion. Occurrences are located from left to right."
msgstr ""

#: ../../proof-engine/tactics.rst:3069
msgid ""
"All occurrences except the occurrences of indexes :n:`{+ @num }` of :n:"
"`@term` are considered for :math:`\\beta`-expansion. Occurrences are located "
"from left to right."
msgstr ""

#: ../../proof-engine/tactics.rst:3075
msgid ""
"Starting from a goal :math:`\\varphi`:g:`(t`:sub:`1` :g:`... t`:sub:`m`:g:"
"`)`, the tactic :n:`pattern t`:sub:`1`:n:`, ..., t`:sub:`m` generates the "
"equivalent goal :g:`(fun (x`:sub:`1`:g:`:A`:sub:`1`:g:`) ... (x`:sub:`m` :g:"
"`:A`:sub:`m` :g:`) =>`:math:`\\varphi`:g:`(x`:sub:`1` :g:`... x`:sub:`m` :g:"
"`)) t`:sub:`1` :g:`... t`:sub:`m`. If :g:`t`:sub:`i` occurs in one of the "
"generated types :g:`A`:sub:`j` these occurrences will also be considered and "
"possibly abstracted."
msgstr ""

#: ../../proof-engine/tactics.rst:3084
msgid ""
"This behaves as above but processing only the occurrences :n:`{+ @num}` of :"
"n:`@term` starting from :n:`@term`."
msgstr ""

#: ../../proof-engine/tactics.rst:3089
msgid "This is the most general syntax that combines the different variants."
msgstr ""

#: ../../proof-engine/tactics.rst:3092
msgid "Conversion tactics applied to hypotheses"
msgstr ""

#: ../../proof-engine/tactics.rst:3096
msgid ""
"Applies the conversion tactic :n:`conv_tactic` to the hypotheses :n:`{+ "
"@ident}`. The tactic :n:`conv_tactic` is any of the conversion tactics "
"listed in this section."
msgstr ""

#: ../../proof-engine/tactics.rst:3100
msgid ""
"If :n:`@ident` is a local definition, then :n:`@ident` can be replaced by "
"(type of :n:`@ident`) to address not the body but the type of the local "
"definition."
msgstr ""

#: ../../proof-engine/tactics.rst:3104
msgid "Example: :n:`unfold not in (type of H1) (type of H3)`."
msgstr ""

#: ../../proof-engine/tactics.rst:3112
msgid "Automation"
msgstr ""

#: ../../proof-engine/tactics.rst:3117
msgid ""
"This tactic implements a Prolog-like resolution procedure to solve the "
"current goal. It first tries to solve the goal using the assumption tactic, "
"then it reduces the goal to an atomic one using intros and introduces the "
"newly generated hypotheses as hints. Then it looks at the list of tactics "
"associated to the head symbol of the goal and tries to apply one of them "
"(starting from the tactics with lower cost). This process is recursively "
"applied to the generated subgoals."
msgstr ""

#: ../../proof-engine/tactics.rst:3125
msgid ""
"By default, auto only uses the hypotheses of the current goal and the hints "
"of the database named core."
msgstr ""

#: ../../proof-engine/tactics.rst:3130
msgid ""
"Forces the search depth to be :n:`@num`. The maximal search depth is `5` by "
"default."
msgstr ""

#: ../../proof-engine/tactics.rst:3135
msgid ""
"Uses the hint databases :n:`{+ @ident}` in addition to the database core. "
"See :ref:`The Hints Databases for auto and eauto "
"<thehintsdatabasesforautoandeauto>` for the list of pre-defined databases "
"and the way to create or extend a database."
msgstr ""

#: ../../proof-engine/tactics.rst:3141
msgid ""
"Uses all existing hint databases. See :ref:`The Hints Databases for auto and "
"eauto <thehintsdatabasesforautoandeauto>`"
msgstr ""

#: ../../proof-engine/tactics.rst:3146
msgid ""
"Uses :n:`{+ @lemma}` in addition to hints (can be combined with the with :n:"
"`@ident` option).  If :n:`@lemma` is an inductive type, it is the collection "
"of its constructors which is added as hints."
msgstr ""

#: ../../proof-engine/tactics.rst:3152
msgid ""
"Behaves like auto but shows the tactics it uses to solve the goal. This "
"variant is very useful for getting a better understanding of automation, or "
"to know what lemmas/assumptions were used."
msgstr ""

#: ../../proof-engine/tactics.rst:3159
msgid ""
"Behaves like :tacn:`auto` but shows the tactics it tries to solve the goal, "
"including failing paths."
msgstr ""

#: ../../proof-engine/tactics.rst:3164
msgid "This is the most general form, combining the various options."
msgstr ""

#: ../../proof-engine/tactics.rst:3169
msgid ""
"This tactic is a restriction of auto that is not recursive and tries only "
"hints that cost `0`. Typically it solves trivial equalities like :g:`X=X`."
msgstr ""

#: ../../proof-engine/tactics.rst:3183
msgid ""
":tacn:`auto` either solves completely the goal or else leaves it intact. :"
"tacn:`auto` and :tacn:`trivial` never fail."
msgstr ""

#: ../../proof-engine/tactics.rst:3186
msgid ""
"The following options enable printing of informative or debug information "
"for the :tacn:`auto` and :tacn:`trivial` tactics:"
msgstr ""

#: ../../proof-engine/tactics.rst:3195 ../../proof-engine/tactics.rst:3227
msgid ""
":ref:`The Hints Databases for auto and eauto "
"<thehintsdatabasesforautoandeauto>`"
msgstr ""

#: ../../proof-engine/tactics.rst:3200
msgid ""
"This tactic generalizes :tacn:`auto`. While :tacn:`auto` does not try "
"resolution hints which would leave existential variables in the goal, :tacn:"
"`eauto` does try them (informally speaking, it usessimple :tacn:`eapply` "
"where :tacn:`auto` uses simple :tacn:`apply`). As a consequence, :tacn:"
"`eauto` can solve such a goal:"
msgstr ""

#: ../../proof-engine/tactics.rst:3214
msgid "Note that ``ex_intro`` should be declared as a hint."
msgstr ""

#: ../../proof-engine/tactics.rst:3219
msgid "The various options for eauto are the same as for auto."
msgstr ""

#: ../../proof-engine/tactics.rst:3221
msgid ":tacn:`eauto` also obeys the following options:"
msgstr ""

#: ../../proof-engine/tactics.rst:3234
msgid ""
"This tactic unfolds constants that were declared through a ``Hint Unfold`` "
"in the given databases."
msgstr ""

#: ../../proof-engine/tactics.rst:3239
msgid "Performs the unfolding in the given clause."
msgstr ""

#: ../../proof-engine/tactics.rst:3243
msgid "Uses the unfold hints declared in all the hint databases."
msgstr ""

#: ../../proof-engine/tactics.rst:3248
msgid ""
"This tactic [4]_ carries out rewritings according to the rewriting rule "
"bases :n:`{+ @ident}`."
msgstr ""

#: ../../proof-engine/tactics.rst:3251
msgid ""
"Each rewriting rule from the base :n:`@ident` is applied to the main subgoal "
"until it fails. Once all the rules have been processed, if the main subgoal "
"has progressed (e.g., if it is distinct from the initial main goal) then the "
"rules of this base are processed again. If the main subgoal has not "
"progressed then the next base is processed. For the bases, the behavior is "
"exactly similar to the processing of the rewriting rules."
msgstr ""

#: ../../proof-engine/tactics.rst:3258
msgid ""
"The rewriting rule bases are built with the ``Hint Rewrite vernacular`` "
"command."
msgstr ""

#: ../../proof-engine/tactics.rst:3263
msgid "This tactic may loop if you build non terminating rewriting systems."
msgstr ""

#: ../../proof-engine/tactics.rst:3267
msgid ""
"Performs, in the same way, all the rewritings of the bases :n:`{+ @ident}` "
"applying tactic to the main subgoal after each rewriting step."
msgstr ""

#: ../../proof-engine/tactics.rst:3272
msgid "Performs all the rewritings in hypothesis :n:`@qualid`."
msgstr ""

#: ../../proof-engine/tactics.rst:3276
msgid ""
"Performs all the rewritings in hypothesis :n:`@qualid` applying :n:`@tactic` "
"to the main subgoal after each rewriting step."
msgstr ""

#: ../../proof-engine/tactics.rst:3281
msgid ""
"Performs all the rewriting in the clause :n:`@clause`. The clause argument "
"must not contain any ``type of`` nor ``value of``."
msgstr ""

#: ../../proof-engine/tactics.rst:3286
msgid ""
":ref:`Hint-Rewrite <hintrewrite>` for feeding the database of lemmas used "
"by :tacn:`autorewrite` and :tacn:`autorewrite` for examples showing the use "
"of this tactic."
msgstr ""

#: ../../proof-engine/tactics.rst:3292
msgid ""
"This tactic tries to solve the current goal by a number of standard closing "
"steps. In particular, it tries to close the current goal using the closing "
"tactics :tacn:`trivial`, :tacn:`reflexivity`, :tacn:`symmetry`, :tacn:"
"`contradiction` and :tacn:`inversion` of hypothesis. If this fails, it tries "
"introducing variables and splitting and-hypotheses, using the closing "
"tactics afterwards, and splitting the goal using :tacn:`split` and recursing."
msgstr ""

#: ../../proof-engine/tactics.rst:3300
msgid ""
"This tactic solves goals that belong to many common classes; in particular, "
"many cases of unsatisfiable hypotheses, and simple equality goals are "
"usually solved by this tactic."
msgstr ""

#: ../../proof-engine/tactics.rst:3306
msgid ""
"Run :n:`@tactic` followed by :tacn:`easy`. This is a notation for :n:"
"`@tactic; easy`."
msgstr ""

#: ../../proof-engine/tactics.rst:3309
msgid "Controlling automation"
msgstr ""

#: ../../proof-engine/tactics.rst:3314
msgid "The hints databases for auto and eauto"
msgstr ""

#: ../../proof-engine/tactics.rst:3316
msgid ""
"The hints for :tacn:`auto` and :tacn:`eauto` are stored in databases. Each "
"database maps head symbols to a list of hints."
msgstr ""

#: ../../proof-engine/tactics.rst:3321
msgid ""
"Use this command to display the hints associated to the head symbol :n:"
"`@ident` (see :ref:`Print Hint <printhint>`). Each hint has a cost that is a "
"nonnegative integer, and an optional pattern. The hints with lower cost are "
"tried first. A hint is tried by :tacn:`auto` when the conclusion of the "
"current goal matches its pattern or when it has no pattern."
msgstr ""

#: ../../proof-engine/tactics.rst:3329
msgid "Creating Hint databases"
msgstr ""

#: ../../proof-engine/tactics.rst:3331
msgid ""
"One can optionally declare a hint database using the command :cmd:`Create "
"HintDb`. If a hint is added to an unknown database, it will be automatically "
"created."
msgstr ""

#: ../../proof-engine/tactics.rst:3337
msgid ""
"This command creates a new database named :n:`@ident`. The database is "
"implemented by a Discrimination Tree (DT) that serves as an index of all the "
"lemmas. The DT can use transparency information to decide if a constant "
"should be indexed or not (c.f. :ref:`The hints databases for auto and eauto "
"<thehintsdatabasesforautoandeauto>`), making the retrieval more efficient. "
"The legacy implementation (the default one for new databases) uses the DT "
"only on goals without existentials (i.e., :tacn:`auto` goals), for non-"
"Immediate hints and does not make use of transparency hints, putting more "
"work on the unification that is run after retrieval (it keeps a list of the "
"lemmas in case the DT is not used). The new implementation enabled by the "
"discriminated option makes use of DTs in all cases and takes transparency "
"information into account. However, the order in which hints are retrieved "
"from the DT may differ from the order in which they were inserted, making "
"this implementation observationally different from the legacy one."
msgstr ""

#: ../../proof-engine/tactics.rst:3353
msgid "The general command to add a hint to some databases :n:`{+ @ident}` is"
msgstr ""

#: ../../proof-engine/tactics.rst:3359
msgid "No database name is given: the hint is registered in the core database."
msgstr ""

#: ../../proof-engine/tactics.rst:3363
msgid ""
"This is used to declare hints that must not be exported to the other modules "
"that require and import the current module. Inside a section, the option "
"Local is useless since hints do not survive anyway to the closure of "
"sections."
msgstr ""

#: ../../proof-engine/tactics.rst:3370
msgid "Idem for the core database."
msgstr ""

#: ../../proof-engine/tactics.rst:3375
msgid ""
"This command adds :n:`simple apply @term` to the hint list with the head "
"symbol of the type of :n:`@term`. The cost of that hint is the number of "
"subgoals generated by :n:`simple apply @term` or :n:`@num` if specified. The "
"associated :n:`@pattern` is inferred from the conclusion of the type of :n:"
"`@term` or the given :n:`@pattern` if specified. In case the inferred type "
"of :n:`@term` does not start with a product the tactic added in the hint "
"list is :n:`exact @term`. In case this type can however be reduced to a type "
"starting with a product, the tactic :n:`simple apply @term` is also stored "
"in the hints list. If the inferred type of :n:`@term` contains a dependent "
"quantification on a variable which occurs only in the premisses of the type "
"and not in its conclusion, no instance could be inferred for the variable by "
"unification with the goal. In this case, the hint is added to the hint list "
"of :tacn:`eauto` instead of the hint list of auto and a warning is printed. "
"A typical example of a hint that is used only by :tacn:`eauto` is a "
"transitivity lemma."
msgstr ""

#: ../../proof-engine/tactics.rst:3393
msgid ""
"The head symbol of the type of :n:`@term` is a bound variable such that this "
"tactic cannot be associated to a constant."
msgstr ""

#: ../../proof-engine/tactics.rst:3398
msgid "Adds each :n:`Hint Resolve @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:3402
msgid ""
"Adds the left-to-right implication of an equivalence as a hint (informally "
"the hint will be used as :n:`apply <- @term`, although as mentionned before, "
"the tactic actually used is a restricted version of :tacn:`apply`)."
msgstr ""

#: ../../proof-engine/tactics.rst:3409
msgid "Adds the right-to-left implication of an equivalence  as a hint."
msgstr ""

#: ../../proof-engine/tactics.rst:3414
msgid ""
"This command adds :n:`simple apply @term; trivial` to the hint list "
"associated with the head symbol of the type of :n:`@ident` in the given "
"database. This tactic will fail if all the subgoals generated by :n:`simple "
"apply @term` are not solved immediately by the :tacn:`trivial` tactic (which "
"only tries tactics with cost 0).This command is useful for theorems such as "
"the symmetry of equality or :g:`n+1=m+1 -> n=m` that we may like to "
"introduce with a limited use in order to avoid useless proof-search. The "
"cost of this tactic (which never generates subgoals) is always 1, so that it "
"is not used by :tacn:`trivial` itself."
msgstr ""

#: ../../proof-engine/tactics.rst:3428
msgid "Adds each :n:`Hint Immediate @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:3433
msgid ""
"If :n:`@ident` is an inductive type, this command adds all its constructors "
"as hints of type ``Resolve``. Then, when the conclusion of current goal has "
"the form :n:`(@ident ...)`, :tacn:`auto` will try to apply each constructor."
msgstr ""

#: ../../proof-engine/tactics.rst:3441
msgid "Adds each :n:`Hint Constructors @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:3446
msgid ""
"This adds the tactic :n:`unfold @qualid` to the hint list that will only be "
"used when the head constant of the goal is :n:`@ident`. Its cost is 4."
msgstr ""

#: ../../proof-engine/tactics.rst:3452
msgid "Adds each :n:`Hint Unfold @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:3457
msgid ""
"This adds a transparency hint to the database, making :n:`@qualid` a "
"transparent or opaque constant during resolution. This information is used "
"during unification of the goal with any lemma in the database and inside the "
"discrimination network to relax or constrain it in the case of discriminated "
"databases."
msgstr ""

#: ../../proof-engine/tactics.rst:3465
msgid "Declares each :n:`@ident` as a transparent or opaque constant."
msgstr ""

#: ../../proof-engine/tactics.rst:3470
msgid ""
"This hint type is to extend :tacn:`auto` with tactics other than :tacn:"
"`apply` and :tacn:`unfold`. For that, we must specify a cost, an optional :n:"
"`@pattern` and a :n:`@tactic` to execute."
msgstr ""

#: ../../proof-engine/tactics.rst:3480
msgid ""
"Now, when the head of the goal is a disequality, ``auto`` will try "
"discriminate if it does not manage to solve the goal with hints with a cost "
"less than 4."
msgstr ""

#: ../../proof-engine/tactics.rst:3484
msgid ""
"One can even use some sub-patterns of the pattern in the tactic script. A "
"sub-pattern is a question mark followed by an identifier, like ``?X1`` or ``?"
"X2``. Here is an example:"
msgstr ""

#: ../../proof-engine/tactics.rst:3501
msgid ""
"These hints currently only apply to typeclass proof search and the :tacn:"
"`typeclasses eauto` tactic."
msgstr ""

#: ../../proof-engine/tactics.rst:3504
msgid ""
"This command can be used to cut the proof-search tree according to a regular "
"expression matching paths to be cut. The grammar for regular expressions is "
"the following. Beware, there is no operator precedence during parsing, one "
"can check with :cmd:`Print HintDb` to verify the current cut expression:"
msgstr ""

#: ../../proof-engine/tactics.rst:3519
msgid ""
"The `emp` regexp does not match any search path while `eps` matches the "
"empty path. During proof search, the path of successive successful hints on "
"a search branch is recorded, as a list of identifiers for the hints (note "
"that Hint Extern’s do not have an associated identifier). Before applying "
"any hint :n:`@ident` the current path `p` extended with :n:`@ident` is "
"matched against the current cut expression `c` associated to the hint "
"database. If matching succeeds, the hint is *not* applied. The semantics of "
"``Hint Cut e`` is to set the cut expression to ``c | e``, the initial cut "
"expression being `emp`."
msgstr ""

#: ../../proof-engine/tactics.rst:3532
msgid ""
"This sets an optional mode of use of the identifier :n:`@qualid`. When proof-"
"search faces a goal that ends in an application of :n:`@qualid` to "
"arguments :n:`@term ... @term`, the mode tells if the hints associated to :n:"
"`@qualid` can be applied or not. A mode specification is a list of n ``+``, "
"``!`` or ``-`` items that specify if an argument of the identifier is to be "
"treated as an input (``+``), if its head only is an input (``!``) or an "
"output (``-``) of the identifier. For a mode to match a list of arguments, "
"input terms and input heads *must not* contain existential variables or be "
"existential variables respectively, while outputs can be any term. Multiple "
"modes can be declared for a single identifier, in that case only one mode "
"needs to match the arguments for the hints to be applied.The head of a term "
"is understood here as the applicative head, or the match or projection "
"scrutinee’s head, recursively, casts being ignored. ``Hint Mode`` is "
"especially useful for typeclasses, when one does not want to support default "
"instances and avoid ambiguity in general. Setting a parameter of a class as "
"an input forces proof-search to be driven by that index of the class, with "
"``!`` giving more flexibility by allowing existentials to still appear "
"deeper in the index but not at its head."
msgstr ""

#: ../../proof-engine/tactics.rst:3553
msgid ""
"One can use an ``Extern`` hint with no pattern to do pattern matching on "
"hypotheses using ``match goal`` with inside the tactic."
msgstr ""

#: ../../proof-engine/tactics.rst:3558
msgid "Hint databases defined in the Coq standard library"
msgstr ""

#: ../../proof-engine/tactics.rst:3560
msgid ""
"Several hint databases are defined in the Coq standard library. The actual "
"content of a database is the collection of hints declared to belong to this "
"database in each of the various modules currently loaded. Especially, "
"requiring new modules may extend the database. At Coq startup, only the core "
"database is nonempty and can be used."
msgstr ""

#: ../../proof-engine/tactics.rst:0
msgid "core"
msgstr ""

#: ../../proof-engine/tactics.rst:3566
msgid ""
"This special database is automatically used by ``auto``, except when pseudo-"
"database ``nocore`` is given to ``auto``. The core database contains only "
"basic lemmas about negation, conjunction, and so on. Most of the hints in "
"this database come from the Init and Logic directories."
msgstr ""

#: ../../proof-engine/tactics.rst:0
msgid "arith"
msgstr ""

#: ../../proof-engine/tactics.rst:3571
msgid ""
"This database contains all lemmas about Peano’s arithmetic proved in the "
"directories Init and Arith."
msgstr ""

#: ../../proof-engine/tactics.rst:0
msgid "zarith"
msgstr ""

#: ../../proof-engine/tactics.rst:3574
msgid ""
"contains lemmas about binary signed integers from the directories theories/"
"ZArith. When required, the module Omega also extends the database zarith "
"with a high-cost hint that calls ``omega`` on equations and inequalities in "
"``nat`` or ``Z``."
msgstr ""

#: ../../proof-engine/tactics.rst:0
msgid "bool"
msgstr ""

#: ../../proof-engine/tactics.rst:3579
msgid "contains lemmas about booleans, mostly from directory theories/Bool."
msgstr ""

#: ../../proof-engine/tactics.rst:0
msgid "datatypes"
msgstr ""

#: ../../proof-engine/tactics.rst:3581
msgid ""
"is for lemmas about lists, streams and so on that are mainly proved in the "
"Lists subdirectory."
msgstr ""

#: ../../proof-engine/tactics.rst:0
msgid "sets"
msgstr ""

#: ../../proof-engine/tactics.rst:3584
msgid ""
"contains lemmas about sets and relations from the directories Sets and "
"Relations."
msgstr ""

#: ../../proof-engine/tactics.rst:0
msgid "typeclass_instances"
msgstr ""

#: ../../proof-engine/tactics.rst:3587
msgid ""
"contains all the typeclass instances declared in the environment, including "
"those used for ``setoid_rewrite``, from the Classes directory."
msgstr ""

#: ../../proof-engine/tactics.rst:3591
msgid ""
"You are advised not to put your own hints in the core database, but use one "
"or several databases specific to your development."
msgstr ""

#: ../../proof-engine/tactics.rst:3598
msgid ""
"This command removes the hints associated to terms :n:`{+ @term}` in "
"databases :n:`{+ @ident}`."
msgstr ""

#: ../../proof-engine/tactics.rst:3605
msgid ""
"This command displays all hints that apply to the current goal. It fails if "
"no proof is being edited, while the two variants can be used at every moment."
msgstr ""

#: ../../proof-engine/tactics.rst:3609 ../../proof-engine/tactics.rst:3640
msgid "**Variants:**"
msgstr ""

#: ../../proof-engine/tactics.rst:3614
msgid ""
"This command displays only tactics associated with :n:`@ident` in the hints "
"list. This is independent of the goal being edited, so this command will not "
"fail if no goal is being edited."
msgstr ""

#: ../../proof-engine/tactics.rst:3620
msgid "This command displays all declared hints."
msgstr ""

#: ../../proof-engine/tactics.rst:3624
msgid "This command displays all hints from database :n:`@ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:3630
msgid ""
"This vernacular command adds the terms :n:`{+ @term}` (their types must be "
"equalities) in the rewriting bases :n:`{+ @ident}` with the default "
"orientation (left to right). Notice that the rewriting bases are distinct "
"from the ``auto`` hint bases and thatauto does not take them into account."
msgstr ""

#: ../../proof-engine/tactics.rst:3635
msgid ""
"This command is synchronous with the section mechanism (see :ref:`section-"
"mechanism`): when closing a section, all aliases created by ``Hint Rewrite`` "
"in that section are lost. Conversely, when loading a module, all ``Hint "
"Rewrite`` declarations at the global level of that module are loaded."
msgstr ""

#: ../../proof-engine/tactics.rst:3644
msgid ""
"This is strictly equivalent to the command above (we only make explicit the "
"orientation which otherwise defaults to ->)."
msgstr ""

#: ../../proof-engine/tactics.rst:3649
msgid ""
"Adds the rewriting rules :n:`{+ @term}` with a right-to-left orientation in "
"the bases :n:`{+ @ident}`."
msgstr ""

#: ../../proof-engine/tactics.rst:3654
msgid ""
"When the rewriting rules :n:`{+ @term}` in :n:`{+ @ident}` will be used, the "
"tactic ``tactic`` will be applied to the generated subgoals, the main "
"subgoal excluded."
msgstr ""

#: ../../proof-engine/tactics.rst:3660
msgid "This command displays all rewrite hints contained in :n:`@ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:3663
msgid "Hint locality"
msgstr ""

#: ../../proof-engine/tactics.rst:3665
msgid ""
"Hints provided by the ``Hint`` commands are erased when closing a section. "
"Conversely, all hints of a module ``A`` that are not defined inside a "
"section (and not defined with option ``Local``) become available when the "
"module ``A`` is imported (using e.g. ``Require Import A.``)."
msgstr ""

#: ../../proof-engine/tactics.rst:3670
msgid ""
"As of today, hints only have a binary behavior regarding locality, as "
"described above: either they disappear at the end of a section scope, or "
"they remain global forever. This causes a scalability issue, because hints "
"coming from an unrelated part of the code may badly influence another "
"development. It can be mitigated to some extent thanks to the :cmd:`Remove "
"Hints` command, but this is a mere workaround and has some limitations (for "
"instance, external hints cannot be removed)."
msgstr ""

#: ../../proof-engine/tactics.rst:3679
msgid ""
"A proper way to fix this issue is to bind the hints to their module scope, "
"as for most of the other objects Coq uses. Hints should only be made "
"available when the module they are defined in is imported, not just "
"required. It is very difficult to change the historical behavior, as it "
"would break a lot of scripts. We propose a smooth transitional path by "
"providing the :opt:`Loose Hint Behavior` option which accepts three flags "
"allowing for a fine-grained handling of non-imported hints."
msgstr ""

#: ../../proof-engine/tactics.rst:3690
msgid ""
"This option accepts three values, which control the behavior of hints w.r."
"t. :cmd:`Import`:"
msgstr ""

#: ../../proof-engine/tactics.rst:3693
msgid ""
"\"Lax\": this is the default, and corresponds to the historical behavior, "
"that is, hints defined outside of a section have a global scope."
msgstr ""

#: ../../proof-engine/tactics.rst:3696
msgid ""
"\"Warn\": outputs a warning when a non-imported hint is used. Note that this "
"is an over-approximation, because a hint may be triggered by a run that will "
"eventually fail and backtrack, resulting in the hint not being actually "
"useful for the proof."
msgstr ""

#: ../../proof-engine/tactics.rst:3701
msgid ""
"\"Strict\": changes the behavior of an unloaded hint to a immediate fail "
"tactic, allowing to emulate an import-scoped hint mechanism."
msgstr ""

#: ../../proof-engine/tactics.rst:3707
msgid "Setting implicit automation tactics"
msgstr ""

#: ../../proof-engine/tactics.rst:3711
msgid ""
"This command may be used to start a proof. It defines a default tactic to be "
"used each time a tactic command ``tactic``:sub:`1` is ended by ``...``. In "
"this case the tactic command typed by the user is equivalent to ``tactic``:"
"sub:`1` ``;tactic``."
msgstr ""

#: ../../proof-engine/tactics.rst:3716
msgid ":cmd:`Proof` in :ref:`proof-editing-mode`."
msgstr ""

#: ../../proof-engine/tactics.rst:3721 ../../proof-engine/tactics.rst:3725
msgid ""
"Combines in a single line ``Proof with`` and ``Proof using``, see :ref:"
"`proof-editing-mode`"
msgstr ""

#: ../../proof-engine/tactics.rst:3729
msgid ""
"This command declares a tactic to be used to solve implicit arguments that "
"Coq does not know how to solve by unification. It is used every time the "
"term argument of a tactic has one of its holes not fully resolved."
msgstr ""

#: ../../proof-engine/tactics.rst:3745
msgid ""
"The tactic ``exists (n // m)`` did not fail. The hole was solved by "
"``assumption`` so that it behaved as ``exists (quo n m H)``."
msgstr ""

#: ../../proof-engine/tactics.rst:3751
msgid "Decision procedures"
msgstr ""

#: ../../proof-engine/tactics.rst:3756
msgid ""
"This tactic implements a decision procedure for intuitionistic propositional "
"calculus based on the contraction-free sequent calculi LJT* of Roy Dyckhoff :"
"cite:`Dyc92`. Note that :tacn:`tauto` succeeds on any instance of an "
"intuitionistic tautological proposition. :tacn:`tauto` unfolds negations and "
"logical equivalence but does not unfold any other definition."
msgstr ""

#: ../../proof-engine/tactics.rst:3762
msgid ""
"The following goal can be proved by :tacn:`tauto` whereas :tacn:`auto` would "
"fail:"
msgstr ""

#: ../../proof-engine/tactics.rst:3773
msgid ""
"Moreover, if it has nothing else to do, :tacn:`tauto` performs "
"introductions. Therefore, the use of :tacn:`intros` in the previous proof is "
"unnecessary. :tacn:`tauto` can for instance for:"
msgstr ""

#: ../../proof-engine/tactics.rst:3785
msgid ""
"In contrast, :tacn:`tauto` cannot solve the following goal :g:`Goal forall "
"(A:Prop) (P:nat -> Prop), A \\/ (forall x:nat, ~ A -> P x) ->` :g:`forall x:"
"nat, ~ ~ (A \\/ P x).` because :g:`(forall x:nat, ~ A -> P x)` cannot be "
"treated as atomic and an instantiation of `x` is necessary."
msgstr ""

#: ../../proof-engine/tactics.rst:3794
msgid ""
"While :tacn:`tauto` recognizes inductively defined connectives isomorphic to "
"the standard connectives ``and``, ``prod``, ``or``, ``sum``, ``False``, "
"``Empty_set``, ``unit``, ``True``, :tacn:`dtauto` also recognizes all "
"inductive types with one constructor and no indices, i.e. record-style "
"connectives."
msgstr ""

#: ../../proof-engine/tactics.rst:3802
msgid ""
"The tactic :tacn:`intuition` takes advantage of the search-tree built by the "
"decision procedure involved in the tactic :tacn:`tauto`. It uses this "
"information to generate a set of subgoals equivalent to the original one "
"(but simpler than it) and applies the tactic :n:`@tactic` to them :cite:"
"`Mun94`. If this tactic fails on some goals then :tacn:`intuition` fails. In "
"fact, :tacn:`tauto` is simply :g:`intuition fail`."
msgstr ""

#: ../../proof-engine/tactics.rst:3809
msgid "For instance, the tactic :g:`intuition auto` applied to the goal"
msgstr ""

#: ../../proof-engine/tactics.rst:3816
msgid "internally replaces it by the equivalent one: ::"
msgstr ""

#: ../../proof-engine/tactics.rst:3822
msgid "and then uses :tacn:`auto` which completes the proof."
msgstr ""

#: ../../proof-engine/tactics.rst:3824
msgid ""
"Originally due to César Muñoz, these tactics (:tacn:`tauto` and :tacn:"
"`intuition`) have been completely re-engineered by David Delahaye using "
"mainly the tactic language (see :ref:`ltac`). The code is now much shorter "
"and a significant increase in performance has been noticed. The general "
"behavior with respect to dependent types, unfolding and introductions has "
"slightly changed to get clearer semantics. This may lead to some "
"incompatibilities."
msgstr ""

#: ../../proof-engine/tactics.rst:3834
msgid "Is equivalent to :g:`intuition auto with *`."
msgstr ""

#: ../../proof-engine/tactics.rst:3839
msgid ""
"While :tacn:`intuition` recognizes inductively defined connectives "
"isomorphic to the standard connectives ``and``, ``prod``, ``or``, ``sum``, "
"``False``, ``Empty_set``, ``unit``, ``True``, :tacn:`dintuition` also "
"recognizes all inductive types with one constructor and no indices, i.e. "
"record-style connectives."
msgstr ""

#: ../../proof-engine/tactics.rst:3846
msgid ""
"Controls whether :tacn:`intuition` unfolds inner negations which do not need "
"to be unfolded. This option is on by default."
msgstr ""

#: ../../proof-engine/tactics.rst:3852
msgid ""
"The :tacn:`rtauto` tactic solves propositional tautologies similarly to "
"what :tacn:`tauto` does. The main difference is that the proof term is built "
"using a reflection scheme applied to a sequent calculus proof of the goal.  "
"The search procedure is also implemented using a different technique."
msgstr ""

#: ../../proof-engine/tactics.rst:3857
msgid ""
"Users should be aware that this difference may result in faster proof-search "
"but slower proof-checking, and :tacn:`rtauto` might not solve goals that :"
"tacn:`tauto` would be able to solve (e.g. goals involving universal "
"quantifiers)."
msgstr ""

#: ../../proof-engine/tactics.rst:3862
msgid ""
"Note that this tactic is only available after a ``Require Import Rtauto``."
msgstr ""

#: ../../proof-engine/tactics.rst:3867
msgid ""
"The tactic :tacn:`firstorder` is an experimental extension of :tacn:`tauto` "
"to first- order reasoning, written by Pierre Corbineau. It is not restricted "
"to usual logical connectives but instead may reason about any first-order "
"class inductive definition."
msgstr ""

#: ../../proof-engine/tactics.rst:3875
msgid ""
"The default tactic used by :tacn:`firstorder` when no rule applies is :g:"
"`auto with *`, it can be reset locally or globally using this option."
msgstr ""

#: ../../proof-engine/tactics.rst:3880
msgid ""
"Prints the default tactic used by :tacn:`firstorder` when no rule applies."
msgstr ""

#: ../../proof-engine/tactics.rst:3884
msgid ""
"Tries to solve the goal with :n:`@tactic` when no logical rule may apply."
msgstr ""

#: ../../proof-engine/tactics.rst:3888
msgid ""
"Adds lemmas :n:`{+ @qualid}` to the proof-search environment. If :n:"
"`@qualid` refers to an inductive type, it is the collection of its "
"constructors which are added to the proof-search environment."
msgstr ""

#: ../../proof-engine/tactics.rst:3894
msgid ""
"Adds lemmas from :tacn:`auto` hint bases :n:`{+ @ident}` to the proof-search "
"environment."
msgstr ""

#: ../../proof-engine/tactics.rst:3899
msgid ""
"This combines the effects of the different variants of :tacn:`firstorder`."
msgstr ""

#: ../../proof-engine/tactics.rst:3904
msgid "This option controls the proof-search depth bound."
msgstr ""

#: ../../proof-engine/tactics.rst:3909
msgid ""
"The tactic :tacn:`congruence`, by Pierre Corbineau, implements the standard "
"Nelson and Oppen congruence closure algorithm, which is a decision procedure "
"for ground equalities with uninterpreted symbols. It also includes "
"constructor theory (see :tacn:`injection` and :tacn:`discriminate`). If the "
"goal is a non-quantified equality, congruence tries to prove it with non-"
"quantified equalities in the context. Otherwise it tries to infer a "
"discriminable equality from those in the context. Alternatively, congruence "
"tries to prove that a hypothesis is equal to the goal or to the negation of "
"another hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:3918
msgid ""
":tacn:`congruence` is also able to take advantage of hypotheses stating "
"quantified equalities, but you have to provide a bound for the number of "
"extra equalities generated that way. Please note that one of the sides of "
"the equality must contain all the quantified variables in order for "
"congruence to match against it."
msgstr ""

#: ../../proof-engine/tactics.rst:3940
msgid ""
"Tries to add at most `n` instances of hypotheses stating quantified "
"equalities to the problem in order to solve it. A bigger value of `n` does "
"not make success slower, only failure. You might consider adding some lemmas "
"as hypotheses using assert in order for :tacn:`congruence` to use them."
msgstr ""

#: ../../proof-engine/tactics.rst:3948
msgid ""
"Adds :n:`{+ @term}` to the pool of terms used by :tacn:`congruence`. This "
"helps in case you have partially applied constructors in your goal."
msgstr ""

#: ../../proof-engine/tactics.rst:3953
msgid ""
"The decision procedure managed to find a proof of the goal or of a "
"discriminable equality but this proof could not be built in Coq because of "
"dependently-typed functions."
msgstr ""

#: ../../proof-engine/tactics.rst:3959
msgid ""
"The decision procedure could solve the goal with the provision that "
"additional arguments are supplied for some partially applied constructors. "
"Any term of an appropriate type will allow the tactic to successfully solve "
"the goal. Those additional arguments can be given to congruence by filling "
"in the holes in the terms given in the error message, using the :tacn:"
"`congruence with` variant described above."
msgstr ""

#: ../../proof-engine/tactics.rst:3967
msgid "This option makes :tacn:`congruence` print debug information."
msgstr ""

#: ../../proof-engine/tactics.rst:3971
msgid "Checking properties of terms"
msgstr ""

#: ../../proof-engine/tactics.rst:3973
msgid ""
"Each of the following tactics acts as the identity if the check succeeds, "
"and results in an error otherwise."
msgstr ""

#: ../../proof-engine/tactics.rst:3979
msgid ""
"This tactic checks whether its arguments are equal modulo alpha conversion "
"and casts."
msgstr ""

#: ../../proof-engine/tactics.rst:3987
msgid ""
"This tactic checks whether its arguments are unifiable, potentially "
"instantiating existential variables."
msgstr ""

#: ../../proof-engine/tactics.rst:3994
msgid ""
"Unification takes the transparency information defined in the hint database :"
"n:`@ident` into account (see :ref:`the hints databases for auto and eauto "
"<thehintsdatabasesforautoandeauto>`)."
msgstr ""

#: ../../proof-engine/tactics.rst:4000
msgid ""
"This tactic checks whether its argument is a current existential variable. "
"Existential variables are uninstantiated variables generated by :tacn:"
"`eapply` and some other tactics."
msgstr ""

#: ../../proof-engine/tactics.rst:4009
msgid ""
"This tactic checks whether its argument has an existential variable as a "
"subterm. Unlike context patterns combined with ``is_evar``, this tactic "
"scans all subterms, including those under binders."
msgstr ""

#: ../../proof-engine/tactics.rst:4018
msgid ""
"This tactic checks whether its argument is a variable or hypothesis in the "
"current goal context or in the opened sections."
msgstr ""

#: ../../proof-engine/tactics.rst:4027
msgid "Equality"
msgstr ""

#: ../../proof-engine/tactics.rst:4033
msgid ""
"This tactic applies to a goal of the form :g:`f a`:sub:`1` :g:`... a`:sub:"
"`n` :g:`= f′a′`:sub:`1` :g:`... a′`:sub:`n`.  Using :tacn:`f_equal` on such "
"a goal leads to subgoals :g:`f=f′` and :g:`a`:sub:`1` = :g:`a′`:sub:`1` and "
"so on up to :g:`a`:sub:`n` :g:`= a′`:sub:`n`. Amongst these subgoals, the "
"simple ones (e.g. provable by :tacn:`reflexivity` or :tacn:`congruence`) are "
"automatically solved by :tacn:`f_equal`."
msgstr ""

#: ../../proof-engine/tactics.rst:4044
msgid ""
"This tactic applies to a goal that has the form :g:`t=u`. It checks that `t` "
"and `u` are convertible and then solves the goal. It is equivalent to "
"``apply refl_equal``."
msgstr ""

#: ../../proof-engine/tactics.rst:4056
msgid ""
"This tactic applies to a goal that has the form :g:`t=u` and changes it "
"into :g:`u=t`."
msgstr ""

#: ../../proof-engine/tactics.rst:4062
msgid ""
"If the statement of the hypothesis ident has the form :g:`t=u`, the tactic "
"changes it to :g:`u=t`."
msgstr ""

#: ../../proof-engine/tactics.rst:4070
msgid ""
"This tactic applies to a goal that has the form :g:`t=u` and transforms it "
"into the two subgoals :n:`t=@term` and :n:`@term=u`."
msgstr ""

#: ../../proof-engine/tactics.rst:4075
msgid "Equality and inductive sets"
msgstr ""

#: ../../proof-engine/tactics.rst:4077
msgid ""
"We describe in this section some special purpose tactics dealing with "
"equality and inductive sets or types. These tactics use the equality :g:`eq:"
"forall (A:Type), A->A->Prop`, simply written with the infix symbol :g:`=`."
msgstr ""

#: ../../proof-engine/tactics.rst:4085
msgid ""
"This tactic solves a goal of the form :g:`forall x y : R, {x = y} + {~ x = y}"
"`, where :g:`R` is an inductive type such that its constructors do not take "
"proofs or functions as arguments, nor objects in dependent types. It solves "
"goals of the form :g:`{x = y} + {~ x = y}` as well."
msgstr ""

#: ../../proof-engine/tactics.rst:4093
msgid ""
"This tactic compares two given objects :n:`@term` and :n:`@term` of an "
"inductive datatype. If :g:`G` is the current goal, it leaves the sub- goals :"
"n:`@term =@term -> G` and :n:`~ @term = @term -> G`. The type of :n:`@term` "
"and :n:`@term` must satisfy the same restrictions as in the tactic ``decide "
"equality``."
msgstr ""

#: ../../proof-engine/tactics.rst:4102
msgid ""
"Let :n:`@term` be the proof of a statement of conclusion :n:`@term = @term`. "
"If :n:`@term` and :n:`@term` are structurally different (in the sense "
"described for the tactic :tacn:`discriminate`), then the tactic "
"``simplify_eq`` behaves as :n:`discriminate @term`, otherwise it behaves as :"
"n:`injection @term`."
msgstr ""

#: ../../proof-engine/tactics.rst:4109
msgid ""
"If some quantified hypothesis of the goal is named :n:`@ident`, then :n:"
"`simplify_eq @ident` first introduces the hypothesis in the local context "
"using :n:`intros until @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:4115
msgid ""
"This does the same thing as :n:`intros until @num` then :n:`simplify_eq "
"@ident` where :n:`@ident` is the identifier for the last introduced "
"hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:4121
msgid ""
"This does the same as :n:`simplify_eq @term` but using the given bindings to "
"instantiate parameters or hypotheses of :n:`@term`."
msgstr ""

#: ../../proof-engine/tactics.rst:4128
msgid ""
"This works the same as ``simplify_eq`` but if the type of :n:`@term`, or the "
"type of the hypothesis referred to by :n:`@num`, has uninstantiated "
"parameters, these parameters are left as existential variables."
msgstr ""

#: ../../proof-engine/tactics.rst:4134
msgid ""
"If the current goal has form :g:`t1 <> t2`, it behaves as :n:`intro @ident; "
"simplify_eq @ident`."
msgstr ""

#: ../../proof-engine/tactics.rst:4140
msgid ""
"This tactic applies to any goal. If :n:`@ident` has type :g:`(existT B a "
"b)=(existT B a' b')` in the local context (i.e. each :n:`@term` of the "
"equality has a sigma type :g:`{ a:A & (B a)}`) this tactic rewrites :g:`a` "
"into :g:`a'` and :g:`b` into :g:`b'` in the current goal. This tactic works "
"even if :g:`B` is also a sigma type. This kind of equalities between "
"dependent pairs may be derived by the :tacn:`injection` and :tacn:"
"`inversion` tactics."
msgstr ""

#: ../../proof-engine/tactics.rst:4151
msgid ""
"Analogous to :tacn:`dependent rewrite ->` but uses the equality from right "
"to left."
msgstr ""

#: ../../proof-engine/tactics.rst:4155
msgid "Inversion"
msgstr ""

#: ../../proof-engine/tactics.rst:4160
msgid ""
":tacn:`functional inversion` is a tactic that performs inversion on "
"hypothesis :n:`@ident` of the form :n:`@qualid {+ @term} = @term` or :n:"
"`@term = @qualid {+ @term}` where :n:`@qualid` must have been defined using "
"Function (see :ref:`advanced-recursive-functions`). Note that this tactic is "
"only available after a ``Require Import FunInd``."
msgstr ""

#: ../../proof-engine/tactics.rst:4170
msgid ""
"This error may be raised when some inversion lemma failed to be generated by "
"Function."
msgstr ""

#: ../../proof-engine/tactics.rst:4176
msgid ""
"This does the same thing as :n:`intros until @num` folowed by :n:`functional "
"inversion @ident` where :token:`ident` is the identifier for the last "
"introduced hypothesis."
msgstr ""

#: ../../proof-engine/tactics.rst:4183
msgid ""
"If the hypothesis :n:`@ident` (or :n:`@num`) has a type of the form :n:"
"`@qualid`:sub:`1` :n:`@term`:sub:`1` ... :n:`@term`:sub:`n` :n:`= @qualid`:"
"sub:`2` :n:`@term`:sub:`n+1` ... :n:`@term`:sub:`n+m` where :n:`@qualid`:sub:"
"`1` and :n:`@qualid`:sub:`2` are valid candidates to functional inversion, "
"this variant allows choosing which :n:`@qualid` is inverted."
msgstr ""

#: ../../proof-engine/tactics.rst:4193
msgid ""
"This kind of inversion has nothing to do with the tactic :tacn:`inversion` "
"above. This tactic does :g:`change (@ident t)`, where `t` is a term built in "
"order to ensure the convertibility. In other words, it does inversion of the "
"function :n:`@ident`. This function must be a fixpoint on a simple recursive "
"datatype: see :ref:`quote` for the full details."
msgstr ""

#: ../../proof-engine/tactics.rst:4202
msgid "Happens when quote is not able to perform inversion properly."
msgstr ""

#: ../../proof-engine/tactics.rst:4207
msgid ""
"All terms that are built only with :n:`{* @ident}` will be considered by "
"quote as constants rather than variables."
msgstr ""

#: ../../proof-engine/tactics.rst:4211
msgid "Classical tactics"
msgstr ""

#: ../../proof-engine/tactics.rst:4213
msgid ""
"In order to ease the proving process, when the Classical module is loaded. A "
"few more tactics are available. Make sure to load the module using the "
"``Require Import`` command."
msgstr ""

#: ../../proof-engine/tactics.rst:4222
msgid ""
"The tactics ``classical_left`` and ``classical_right`` are the analog of the "
"left and right but using classical logic. They can only be used for "
"disjunctions. Use ``classical_left`` to prove the left part of the "
"disjunction with the assumption that the negation of right part holds. Use "
"``classical_right`` to prove the right part of the disjunction with the "
"assumption that the negation of left part holds."
msgstr ""

#: ../../proof-engine/tactics.rst:4232
msgid "Automating"
msgstr ""

#: ../../proof-engine/tactics.rst:4238
msgid ""
"The tactic :tacn:`btauto` implements a reflexive solver for boolean "
"tautologies. It solves goals of the form :g:`t = u` where `t` and `u` are "
"constructed over the following grammar:"
msgstr ""

#: ../../proof-engine/tactics.rst:4254
msgid ""
"Whenever the formula supplied is not a tautology, it also provides a counter-"
"example."
msgstr ""

#: ../../proof-engine/tactics.rst:4257
msgid ""
"Internally, it uses a system very similar to the one of the ring tactic."
msgstr ""

#: ../../proof-engine/tactics.rst:4260
msgid ""
"Note that this tactic is only available after a ``Require Import Btauto``."
msgstr ""

#: ../../proof-engine/tactics.rst:4264
msgid ""
"The goal is not of the form :g:`t = u`. Especially note that :tacn:`btauto` "
"doesn't introduce variables into the context on its own."
msgstr ""

#: ../../proof-engine/tactics.rst:4270
msgid ""
"The tactic :tacn:`omega`, due to Pierre Crégut, is an automatic decision "
"procedure for Presburger arithmetic. It solves quantifier-free formulas "
"built with `~`, `\\/`, `/\\`, `->` on top of equalities, inequalities and "
"disequalities on both the type :g:`nat` of natural numbers and :g:`Z` of "
"binary integers. This tactic must be loaded by the command ``Require Import "
"Omega``. See the additional documentation about omega (see Chapter :ref:"
"`omega`)."
msgstr ""

#: ../../proof-engine/tactics.rst:4284
msgid ""
"The :n:`ring` tactic solves equations upon polynomial expressions of a ring "
"(or semiring) structure. It proceeds by normalizing both hand sides of the "
"equation (w.r.t. associativity, commutativity and distributivity, constant "
"propagation) and comparing syntactically the results."
msgstr ""

#: ../../proof-engine/tactics.rst:4290
msgid ""
":n:`ring_simplify` applies the normalization procedure described above to "
"the given terms. The tactic then replaces all occurrences of the terms given "
"in the conclusion of the goal by their normal forms. If no term is given, "
"then the conclusion should be an equation and both hand sides are normalized."
msgstr ""

#: ../../proof-engine/tactics.rst:4296
msgid ""
"See :ref:`Theringandfieldtacticfamilies` for more information on the tactic "
"and how to declare new ring structures. All declared field structures can be "
"printed with the ``Print Rings`` command."
msgstr ""

#: ../../proof-engine/tactics.rst:4307
msgid ""
"The field tactic is built on the same ideas as ring: this is a reflexive "
"tactic that solves or simplifies equations in a field structure. The main "
"idea is to reduce a field expression (which is an extension of ring "
"expressions with the inverse and division operations) to a fraction made of "
"two polynomial expressions."
msgstr ""

#: ../../proof-engine/tactics.rst:4313
msgid ""
"Tactic :n:`field` is used to solve subgoals, whereas :n:`field_simplify {+ "
"@term}` replaces the provided terms by their reduced fraction. :n:"
"`field_simplify_eq` applies when the conclusion is an equation: it "
"simplifies both hand sides and multiplies so as to cancel denominators. So "
"it produces an equation without division nor inverse."
msgstr ""

#: ../../proof-engine/tactics.rst:4319
msgid ""
"All of these 3 tactics may generate a subgoal in order to prove that "
"denominators are different from zero."
msgstr ""

#: ../../proof-engine/tactics.rst:4322
msgid ""
"See :ref:`Theringandfieldtacticfamilies` for more information on the tactic "
"and how to declare new field structures. All declared field structures can "
"be printed with the Print Fields command."
msgstr ""

#: ../../proof-engine/tactics.rst:4340
msgid ""
"File plugins/setoid_ring/RealField.v for an example of instantiation, theory "
"theories/Reals for many examples of use of field."
msgstr ""

#: ../../proof-engine/tactics.rst:4346
msgid ""
"This tactic written by Loïc Pottier solves linear inequalities on real "
"numbers using Fourier’s method :cite:`Fourier`. This tactic must be loaded "
"by ``Require Import Fourier``."
msgstr ""

#: ../../proof-engine/tactics.rst:4350
msgid "Example: .. coqtop:: reset all"
msgstr ""

#: ../../proof-engine/tactics.rst:4353
msgid ""
"Require Import Reals. Require Import Fourier. Goal forall x y:R, (x < y)%R -"
"> (y + 1 >= x - 1)%R. intros; fourier."
msgstr ""

#: ../../proof-engine/tactics.rst:4359
msgid "Non-logical tactics"
msgstr ""

#: ../../proof-engine/tactics.rst:4365
msgid ""
"This tactic puts the :n:`@num` first goals at the end of the list of goals. "
"If :n:`@num` is negative, it will put the last :math:`|num|` goals at the "
"beginning of the list."
msgstr ""

#: ../../proof-engine/tactics.rst:4382
msgid ""
"This tactic switches the position of the goals of indices :n:`@num` and :n:"
"`@num`. If either :n:`@num` or :n:`@num` is negative then goals are counted "
"from the end of the focused goal list. Goals are indexed from 1, there is no "
"goal with position 0."
msgstr ""

#: ../../proof-engine/tactics.rst:4400
msgid "This tactics reverses the list of the focused goals."
msgstr ""

#: ../../proof-engine/tactics.rst:4414
msgid ""
"This tactic moves all goals under focus to a shelf. While on the shelf, "
"goals will not be focused on. They can be solved by unification, or they can "
"be called back into focus with the command :cmd:`Unshelve`."
msgstr ""

#: ../../proof-engine/tactics.rst:4422
msgid ""
"Shelves only the goals under focus that are mentioned in other goals. Goals "
"that appear in the type of other goals can be solved by unification."
msgstr ""

#: ../../proof-engine/tactics.rst:4436
msgid ""
"This command moves all the goals on the shelf (see :tacn:`shelve`) from the "
"shelf into focus, by appending them to the end of the current list of "
"focused goals."
msgstr ""

#: ../../proof-engine/tactics.rst:4443
msgid ""
"This tactic removes the focused goals from the proof. They are not solved, "
"and cannot be solved later in the proof. As the goals are not solved, the "
"proof cannot be closed."
msgstr ""

#: ../../proof-engine/tactics.rst:4447
msgid ""
"The ``give_up`` tactic can be used while editing a proof, to choose to write "
"the proof script in a non-sequential order."
msgstr ""

#: ../../proof-engine/tactics.rst:4451
msgid "Simple tactic macros"
msgstr ""

#: ../../proof-engine/tactics.rst:4453
msgid "A simple example has more value than a long explanation:"
msgstr ""

#: ../../proof-engine/tactics.rst:4464
msgid ""
"The tactics macros are synchronous with the Coq section mechanism: a tactic "
"definition is deleted from the current environment when you close the "
"section (see also :ref:`section-mechanism`) where it was defined. If you "
"want that a tactic macro defined in a module is usable in the modules that "
"require it, you should put it outside of any section."
msgstr ""

#: ../../proof-engine/tactics.rst:4470
msgid ":ref:`ltac` gives examples of more complex user-defined tactics."
msgstr ""

#: ../../proof-engine/tactics.rst:4473
msgid ""
"Actually, only the second subgoal will be generated since the other one can "
"be automatically checked."
msgstr ""

#: ../../proof-engine/tactics.rst:4475
msgid "This corresponds to the cut rule of sequent calculus."
msgstr ""

#: ../../proof-engine/tactics.rst:4476
msgid "Reminder: opaque constants will not be expanded by δ reductions."
msgstr ""

#: ../../proof-engine/tactics.rst:4477
msgid ""
"The behavior of this tactic has changed a lot compared to the versions "
"available in the previous distributions (V6). This may cause significant "
"changes in your theories to obtain the same result. As a drawback of the re-"
"engineering of the code, this tactic has also been completely revised to get "
"a very compact and readable version."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:4
msgid "Vernacular commands"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:9
msgid "Displaying"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:17
msgid ""
"This command displays on the screen information about the declared or "
"defined object referred by :n:`@qualid`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:32
msgid ""
"This is a synonym of :cmd:`Print` :n:`@qualid` when :n:`@qualid` denotes a "
"global constant."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:37
#: ../../proof-engine/vernacular-commands.rst:51
msgid ""
"This locally renames the polymorphic universes of :n:`@qualid`. An "
"underscore means the raw universe is printed."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:44
msgid ""
"This displays various information about the object denoted by :n:`@qualid`: "
"its kind (module, constant, assumption, inductive, constructor, "
"abbreviation, …), long name, type, implicit arguments and argument scopes. "
"It does not print the body of definitions or proofs."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:57
msgid ""
"This command displays information about the current state of the "
"environment, including sections and modules."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:63
msgid ""
"This command displays the :n:`@num` last objects of the current environment, "
"including sections and modules."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:68
msgid ""
"The name :n:`@ident` should correspond to a currently open section, this "
"command displays the objects defined since the beginning of this section."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:76
msgid "Flags, Options and Tables"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:78
msgid ""
"Coq has many settings to control its behavior.  Setting types include flags, "
"options and tables:"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:81
msgid ""
"A :production:`flag` has a boolean value, such as :flag:`Asymmetric "
"Patterns`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:82
msgid ""
"An :production:`option` generally has a numeric or string value, such as :"
"opt:`Firstorder Depth`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:83
msgid "A :production:`table` contains a set of strings or qualids."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:84
msgid ""
"In addition, some commands provide settings, such as :cmd:`Extraction "
"Language OCaml`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:88
msgid ""
"Flags, options and tables are identified by a series of identifiers, each "
"with an initial capital letter."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:94
msgid ""
"Sets :token:`flag` on. Scoping qualifiers are described :ref:`here "
"<set_unset_scope_qualifiers>`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:100
msgid ""
"Sets :token:`flag` off. Scoping qualifiers are described :ref:`here "
"<set_unset_scope_qualifiers>`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:105
msgid "Prints the current value of :token:`flag`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:111
msgid ""
"Sets :token:`option` to the specified value.  Scoping qualifiers are "
"described :ref:`here <set_unset_scope_qualifiers>`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:117
msgid ""
"Sets :token:`option` to its default value.  Scoping qualifiers are "
"described :ref:`here <set_unset_scope_qualifiers>`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:122
msgid "Prints the current value of :token:`option`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:126
msgid ""
"Prints the current value of all flags and options, and the names of all "
"tables."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:132
msgid "Adds the specified value to :token:`table`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:137
msgid "Removes the specified value from :token:`table`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:142
msgid "Reports whether :token:`table` contains the specified value."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:147
msgid "Prints the values in :token:`table`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:151
msgid "A synonym for :cmd:`Print Table @table`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:155
msgid "A synonym for :cmd:`Print Options`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:160
msgid "Scope qualifiers for :cmd:`Set` and :cmd:`Unset`"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:162
msgid ":n:`{? Local | Global | Export }`"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:164
msgid ""
"Flag and option settings can be global in scope or local to nested scopes "
"created by :cmd:`Module` and :cmd:`Section` commands.  There are four "
"alternatives:"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:167
msgid ""
"no qualifier: the original setting is *not* restored at the end of the "
"current module or section."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:168
msgid ""
"**Local**: the setting is applied within the current scope.  The original "
"value of the option or flag is restored at the end of the current module or "
"section."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:170
msgid ""
"**Global**: similar to no qualifier, the original setting is *not* restored "
"at the end of the current module or section.  In addition, if the value is "
"set in a file, then :cmd:`Require`-ing the file sets the option."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:173
msgid ""
"**Export**: similar to **Local**, the original value of the option or flag "
"is restored at the end of the current module or section.  In addition, if "
"the value is set in a file, then :cmd:`Import`-ing the file sets the option."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:177
msgid "Newly opened scopes inherit the current settings."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:182
msgid "Requests to the environment"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:186
msgid ""
"This command displays the type of :n:`@term`. When called in proof mode, the "
"term is checked in the local context of the current subgoal."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:194
msgid ""
"This variant specifies on which subgoal to perform typing (see Section :ref:"
"`invocation-of-tactics`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:202
msgid ""
"This command performs the specified reduction on :n:`@term`, and displays "
"the resulting term with its type. The term to be reduced may depend on "
"hypothesis introduced in the first subgoal (if a proof is in progress)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:207
#: ../../proof-engine/vernacular-commands.rst:216
msgid "Section :ref:`performingcomputations`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:212
msgid ""
"This command performs a call-by-value evaluation of term by using the "
"bytecode-based virtual machine. It is a shortcut for ``Eval vm_compute in`` :"
"n:`@term`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:221
msgid ""
"This commands display all the assumptions (axioms, parameters and variables) "
"a theorem or definition depends on. Especially, it informs on the "
"assumptions with respect to which the validity of a theorem relies."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:229
msgid ""
"Displays the set of opaque constants :n:`@qualid` relies on in addition to "
"the assumptions."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:235
msgid ""
"Displays the set of transparent constants :n:`@qualid` relies on in addition "
"to the assumptions."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:241
msgid "Displays all assumptions and constants :n:`@qualid` relies on."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:246
msgid ""
"This command displays the name and type of all objects (hypothesis of the "
"current goal, theorems, axioms, etc) of the current context whose statement "
"contains :n:`@qualid`. This command is useful to remind the user of the name "
"of library lemmas."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:253
msgid "There is no constant in the environment named qualid."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:257
msgid ""
"If :n:`@string` is a valid identifier, this command displays the name and "
"type of all objects (theorems, axioms, etc) of the current context whose "
"name contains string. If string is a notation’s string denoting some "
"reference :n:`@qualid` (referred to by its main symbol as in `\"+\"` or by "
"its notation’s string as in `\"_ + _\"` or `\"_ 'U' _\"`, see Section :ref:"
"`notations`), the command works like ``Search`` :n:`@qualid`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:266
msgid ""
"The string string must be a notation or the main symbol of a notation which "
"is then interpreted in the scope bound to the delimiting key :n:`@key` (see "
"Section :ref:`LocalInterpretationRulesForNotations`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:272
msgid ""
"This searches for all statements or types of definition that contains a "
"subterm that matches the pattern `term_pattern` (holes of the pattern are "
"either denoted by `_` or by `?ident` when non linear patterns are expected)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:279
msgid ""
"where :n:`@term_pattern_string` is a term_pattern, a string, or a string "
"followed by a scope delimiting key `%key`.  This generalization of "
"``Search`` searches for all objects whose statement or type contains a "
"subterm matching :n:`@term_pattern` (or :n:`@qualid` if :n:`@string` is the "
"notation for a reference qualid) and whose name contains all string of the "
"request that correspond to valid identifiers. If a term_pattern or a string "
"is prefixed by `-`, the search excludes the objects that mention that "
"term_pattern or that string."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:291
#: ../../proof-engine/vernacular-commands.rst:350
#: ../../proof-engine/vernacular-commands.rst:409
#: ../../proof-engine/vernacular-commands.rst:445
msgid ""
"This restricts the search to constructions defined in the modules named by "
"the given :n:`qualid` sequence."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:296
#: ../../proof-engine/vernacular-commands.rst:355
#: ../../proof-engine/vernacular-commands.rst:414
#: ../../proof-engine/vernacular-commands.rst:450
msgid ""
"This restricts the search to constructions not defined in the modules named "
"by the given :n:`qualid` sequence."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:301
#: ../../proof-engine/vernacular-commands.rst:364
#: ../../proof-engine/vernacular-commands.rst:419
#: ../../proof-engine/vernacular-commands.rst:455
msgid ""
"This specifies the goal on which to search hypothesis (see Section :ref:"
"`invocation-of-tactics`). By default the 1st goal is searched. This variant "
"can be combined with other variants presented here."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:325
msgid ""
"Up to |Coq| version 8.4, :cmd:`Search` had the behavior of current :cmd:"
"`SearchHead` and the behavior of current :cmd:`Search` was obtained with "
"command :cmd:`SearchAbout`. For compatibility, the deprecated name :cmd:"
"`SearchAbout` can still be used as a synonym of :cmd:`Search`. For "
"compatibility, the list of objects to search when using :cmd:`SearchAbout` "
"may also be enclosed by optional ``[ ]`` delimiters."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:335
msgid ""
"This command displays the name and type of all hypothesis of the current "
"goal (if any) and theorems of the current context whose statement’s "
"conclusion has the form `(term t1 .. tn)`. This command is useful to remind "
"the user of the name of library lemmas."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:360
msgid ""
"No module :n:`@qualid` has been required (see Section :ref:`compiled-files`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:369
msgid "Up to |Coq| version 8.4, ``SearchHead`` was named ``Search``."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:374
msgid ""
"This command displays the name and type of all hypothesis of the current "
"goal (if any) and theorems of the current context whose statement’s "
"conclusion or last hypothesis and conclusion matches the expressionterm "
"where holes in the latter are denoted by `_`. It is a variant of :n:`Search "
"@term_pattern` that does not look for subterms but searches for statements "
"whose conclusion has exactly the expected form, or whose statement finishes "
"by the given series of hypothesis/conclusion."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:397
msgid ""
"Patterns need not be linear: you can express that the same expression must "
"occur in two places by using pattern variables `?ident`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:428
msgid ""
"This command displays the name and type of all hypothesis of the current "
"goal (if any) and theorems of the current context whose statement’s "
"conclusion is an equality of which one side matches the expression term. "
"Holes in term are denoted by “_”."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:465
msgid ""
"Specifies a set of strings used to exclude lemmas from the results of :cmd:"
"`Search`, :cmd:`SearchHead`, :cmd:`SearchPattern` and :cmd:`SearchRewrite` "
"queries.  A lemma whose fully-qualified name contains any of the strings "
"will be excluded from the search results.  The default blacklisted "
"substrings are ``_subterm``, ``_subproof`` and ``Private_``."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:471
msgid ""
"Use the :cmd:`Add @table` and :cmd:`Remove @table` commands to update the "
"set of blacklisted strings."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:476
msgid ""
"This command displays the full name of objects whose name is a prefix of the "
"qualified identifier :n:`@qualid`, and consequently the |Coq| module in "
"which they are defined. It searches for objects from the different qualified "
"namespaces of |Coq|: terms, modules, Ltac, etc."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:497
msgid "As Locate but restricted to terms."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:501
msgid "As Locate but restricted to modules."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:505
msgid "As Locate but restricted to tactics."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:507
msgid "Section :ref:`locating-notations`"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:513
msgid "Loading files"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:515
msgid ""
"|Coq| offers the possibility of loading different parts of a whole "
"development stored in separate files. Their contents will be loaded as if "
"they were entered from the keyboard. This means that the loaded files are "
"ASCII files containing sequences of commands for |Coq|’s toplevel. This kind "
"of file is called a *script* for |Coq|. The standard (and default) extension "
"of |Coq|’s script files is .v."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:525
msgid ""
"This command loads the file named :n:`ident`.v, searching successively in "
"each of the directories specified in the *loadpath*. (see Section :ref:"
"`libraries-and-filesystem`)"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:529
msgid ""
"Files loaded this way cannot leave proofs open, and the ``Load`` command "
"cannot be used inside a proof either."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:534
msgid ""
"Loads the file denoted by the string :n:`@string`, where string is any "
"complete filename. Then the `~` and .. abbreviations are allowed as well as "
"shell variables. If no extension is specified, |Coq| will use the default "
"extension ``.v``."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:543
msgid ""
"Display, while loading, the answers of |Coq| to each command (including "
"tactics) contained in the loaded file."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:547
msgid "Section :ref:`controlling-display`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:558
msgid "Compiled files"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:560
msgid ""
"This section describes the commands used to load compiled files (see "
"Chapter :ref:`thecoqcommands` for documentation on how to compile a file). A "
"compiled file is a particular case of module called *library file*."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:567
msgid ""
"This command looks in the loadpath for a file containing module :n:`@qualid` "
"and adds the corresponding module to the environment of |Coq|. As library "
"files have dependencies in other library files, the command :cmd:`Require` :"
"n:`@qualid` recursively requires all library files the module qualid depends "
"on and adds the corresponding modules to the environment of |Coq| too. |Coq| "
"assumes that the compiled files have been produced by a valid |Coq| compiler "
"and their contents are then not replayed nor rechecked."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:576
msgid ""
"To locate the file in the file system, :n:`@qualid` is decomposed under the "
"form `dirpath.ident` and the file `ident.vo` is searched in the physical "
"directory of the file system that is mapped in |Coq| loadpath to the logical "
"path dirpath (see Section :ref:`libraries-and-filesystem`). The mapping "
"between physical directories and logical names at the time of requiring the "
"file must be consistent with the mapping used to compile the file. If "
"several files match, one of them is picked in an unspecified fashion."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:588
msgid ""
"This loads and declares the module :n:`@qualid` and its dependencies then "
"imports the contents of :n:`@qualid` as described :ref:`here "
"<import_qualid>`. It does not import the modules on which qualid depends "
"unless these modules were themselves required in module :n:`@qualid` using :"
"cmd:`Require Export`, as described below, or recursively required through a "
"sequence of :cmd:`Require Export`.  If the module required has already been "
"loaded, :cmd:`Require Import` :n:`@qualid` simply imports it, as :cmd:"
"`Import` :n:`@qualid` would."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:601
msgid ""
"This command acts as :cmd:`Require Import` :n:`@qualid`, but if a further "
"module, say `A`, contains a command :cmd:`Require Export` `B`, then the "
"command :cmd:`Require Import` `A` also imports the module `B.`"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:607
msgid ""
"This loads the modules named by the :n:`qualid` sequence and their recursive "
"dependencies. If ``Import`` or ``Export`` is given, it also imports these "
"modules and all the recursive dependencies that were marked or transitively "
"marked as ``Export``."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:616
msgid ""
"This command acts as :cmd:`Require`, but picks any library whose absolute "
"name is of the form dirpath.dirpath’.qualid for some `dirpath’`. This is "
"useful to ensure that the :n:`@qualid` library comes from a given package by "
"making explicit its absolute root."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:625
msgid ""
"The command did not find the file foo.vo. Either foo.v exists but is not "
"compiled or foo.vo is in a directory which is not in your LoadPath (see "
"Section :ref:`libraries-and-filesystem`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:631
msgid ""
"The command tried to load library file :n:`@ident`.vo that depends on some "
"specific version of library :n:`@qualid` which is not the one already loaded "
"in the current |Coq| session. Probably `ident.v` was not properly recompiled "
"with the last version of the file containing module :n:`@qualid`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:639
msgid ""
"The file `ident.vo` was found but either it is not a |Coq| compiled module, "
"or it was compiled with an incompatible version of |Coq|."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:645
msgid ""
"The library file `dirpath’` is indirectly required by the ``Require`` "
"command but it is bound in the current loadpath to the file `ident.vo` which "
"was bound to a different library name `dirpath` at the time it was compiled."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:653
msgid ""
"This command is not allowed inside a module or a module type being defined. "
"It is meant to describe a dependency between compilation units. Note however "
"that the commands ``Import`` and ``Export`` alone can be used inside modules "
"(see Section :ref:`Import <import_qualid>`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:659
msgid "Chapter :ref:`thecoqcommands`"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:663
msgid ""
"This command displays the list of library files loaded in the current |Coq| "
"session. For each of these libraries, it also tells if it is imported."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:670
msgid ""
"This commands loads the OCaml compiled files with names given by the :n:"
"`@string` sequence (dynamic link). It is mainly used to load tactics "
"dynamically. The files are searched into the current OCaml loadpath (see the "
"command ``Add ML Path`` in Section :ref:`libraries-and-filesystem`). Loading "
"of OCaml files is only possible under the bytecode version of ``coqtop`` (i."
"e. ``coqtop`` called with option ``-byte``, see chapter :ref:"
"`thecoqcommands`), or when |Coq| has been compiled with a version of OCaml "
"that supports native Dynlink (≥ 3.11)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:682
msgid ""
"This variant is not exported to the modules that import the module where "
"they occur, even if outside a section."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:692
msgid ""
"This prints the name of all OCaml modules loaded with ``Declare ML Module``. "
"To know from where these module were loaded, the user should use the command "
"``Locate File`` (see :ref:`here <locate-file>`)"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:700
msgid "Loadpath"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:702
msgid ""
"Loadpaths are preferably managed using |Coq| command line options (see "
"Section `libraries-and-filesystem`) but there remain vernacular commands to "
"manage them for practical purposes. Such commands are only meant to be "
"issued in the toplevel, and using them in source files is discouraged."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:710
msgid "This command displays the current working directory."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:715
msgid ""
"This command changes the current directory according to :n:`@string` which "
"can be any valid path."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:720
msgid "Is equivalent to Pwd."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:725
msgid ""
"This command is equivalent to the command line option ``-Q`` :n:`@string` :n:"
"`@dirpath`. It adds the physical directory string to the current |Coq| "
"loadpath and maps it to the logical directory dirpath."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:731
msgid ""
"Performs as Add LoadPath :n:`@string` as :n:`@dirpath` but for the empty "
"directory path."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:737
msgid ""
"This command is equivalent to the command line option ``-R`` :n:`@string` :n:"
"`@dirpath`. It adds the physical directory string and all its subdirectories "
"to the current |Coq| loadpath."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:743
msgid ""
"Works as :cmd:`Add Rec LoadPath` :n:`@string` as :n:`@dirpath` but for the "
"empty logical directory path."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:749
msgid ""
"This command removes the path :n:`@string` from the current |Coq| loadpath."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:754
msgid "This command displays the current |Coq| loadpath."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:758
msgid ""
"Works as :cmd:`Print LoadPath` but displays only the paths that extend the :"
"n:`@dirpath` prefix."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:764
msgid ""
"This command adds the path :n:`@string` to the current OCaml loadpath (see "
"the command `Declare ML Module`` in Section :ref:`compiled-files`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:770
msgid ""
"This command adds the directory :n:`@string` and all its subdirectories to "
"the current OCaml loadpath (see the command :cmd:`Declare ML Module`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:776
msgid ""
"This command displays the current OCaml loadpath. This command makes sense "
"only under the bytecode version of ``coqtop``, i.e. using option ``-byte`` "
"(see the command Declare ML Module in Section :ref:`compiled-files`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:785
msgid ""
"This command displays the location of file string in the current loadpath. "
"Typically, string is a .cmo or .vo or .v file."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:791
msgid ""
"This command gives the status of the |Coq| module dirpath. It tells if the "
"module is loaded and if not searches in the load path for a module of "
"logical name :n:`@dirpath`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:799
msgid "Backtracking"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:801
msgid ""
"The backtracking commands described in this section can only be used "
"interactively, they cannot be part of a vernacular file loaded via ``Load`` "
"or compiled by ``coqc``."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:808
msgid ""
"This command removes all the objects in the environment since :n:`@ident` "
"was introduced, including :n:`@ident`. :n:`@ident` may be the name of a "
"defined or declared object as well as the name of a section. One cannot "
"reset over the name of a module or of an object inside a module."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:817
msgid ""
"Goes back to the initial state, just after the start of the interactive "
"session."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:823
msgid ""
"This command undoes all the effects of the last vernacular command. Commands "
"read from a vernacular file via a :cmd:`Load` are considered as a single "
"command. Proof management commands are also handled by this command (see "
"Chapter :ref:`proofhandling`). For that, Back may have to undo more than one "
"command in order to reach a state where the proof management information is "
"available. For instance, when the last command is a :cmd:`Qed`, the "
"management information about the closed proof has been discarded. In this "
"case, :cmd:`Back` will then undo all the proof steps up to the statement of "
"this proof."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:835
msgid ""
"Undo :n:`@num` vernacular commands. As for Back, some extra commands may be "
"undone in order to reach an adequate state. For instance Back :n:`@num` will "
"not re-enter a closed proof, but rather go just before that proof."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:842
msgid "The user wants to undo more commands than available in the history."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:846
msgid ""
"This command brings back the system to the state labeled :n:`@num`, "
"forgetting the effect of all commands executed after this state. The state "
"label is an integer which grows after each successful command. It is "
"displayed in the prompt when in -emacs mode. Just as :cmd:`Back` (see "
"above), the :cmd:`BackTo` command now handles proof states. For that, it may "
"have to undo some extra commands and end on a state `num′ ≤ num` if "
"necessary."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:859
msgid ""
":cmd:`Backtrack` is a *deprecated* form of :cmd:`BackTo` which allows "
"explicitly manipulating the proof environment. The three numbers represent "
"the following:"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:863
msgid "*first number* : State label to reach, as for :cmd:`BackTo`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:864
msgid ""
"*second number* : *Proof state number* to unbury once aborts have been done. "
"|Coq| will compute the number of :cmd:`Undo` to perform (see Chapter :ref:"
"`proofhandling`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:866
msgid ""
"*third number* : Number of :cmd:`Abort` to perform, i.e. the number of "
"currently opened nested proofs that must be canceled (see Chapter :ref:"
"`proofhandling`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:871
msgid "The destination state label is unknown."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:877
msgid "Quitting and debugging"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:882
msgid "This command permits to quit |Coq|."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:887
msgid ""
"This is used mostly as a debug facility by |Coq|’s implementers and does not "
"concern the casual user. This command permits to leave |Coq| temporarily and "
"enter the OCaml toplevel. The OCaml command:"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:896
msgid ""
"adds the right loadpaths and loads some toplevel printers for all abstract "
"types of |Coq|- section_path, identifiers, terms, judgments, …. You can also "
"use the file base_include instead, that loads only the pretty-printers for "
"section_paths and identifiers. You can return back to |Coq| with the command:"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:908
msgid ""
"It only works with the bytecode version of |Coq| (i.e. `coqtop.byte`, see "
"Section `interactive-use`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:910
msgid ""
"You must have compiled |Coq| from the source package and set the environment "
"variable COQTOP to the root of your copy of the sources (see Section "
"`customization-by-environment-variables`)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:919
msgid ""
"This command executes the vernacular command :n:`@command` and displays the "
"time needed to execute it."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:925
msgid ""
"This command executes the vernacular command :n:`@command`, redirecting its "
"output to \":n:`@string`.out\"."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:931
msgid ""
"This command executes the vernacular command :n:`@command`. If the command "
"has not terminated after the time specified by the :n:`@num` (time expressed "
"in seconds), then it is interrupted and an error message is displayed."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:939
msgid ""
"This option controls a default timeout for subsequent commands, as if they "
"were passed to a :cmd:`Timeout` command. Commands already starting by a :cmd:"
"`Timeout` are unaffected."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:946
msgid ""
"For debugging scripts, sometimes it is desirable to know whether a command "
"or a tactic fails. If the given :n:`@command` fails, the ``Fail`` statement "
"succeeds, without changing the proof state, and in interactive mode, the "
"system prints a message confirming the failure. If the given :n:`@command` "
"succeeds, the statement is an error, and it prints a message indicating that "
"the failure did not occur."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:960
msgid "Controlling display"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:964
msgid "This option controls the normal displaying."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:969
msgid ""
"This option configures the display of warnings. It is experimental, and "
"expects, between quotes, a comma-separated list of warning names or "
"categories. Adding - in front of a warning or category disables it, adding + "
"makes it an error. It is possible to use the special categories all and "
"default, the latter containing the warnings enabled by default. The flags "
"are interpreted from left to right, so in case of an overlap, the flags on "
"the right have higher priority, meaning that `A,-A` is equivalent to `-A`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:979
msgid ""
"This option restricts the output of search commands to identifier names; "
"turning it on causes invocations of :cmd:`Search`, :cmd:`SearchHead`, :cmd:"
"`SearchPattern`, :cmd:`SearchRewrite` etc. to omit types from their output, "
"printing only identifiers."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:987
msgid ""
"This command sets which left-aligned part of the width of the screen is used "
"for display. At the time of writing this documentation, the default value is "
"78."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:994
msgid ""
"This option controls the nesting depth of the formatter used for pretty- "
"printing. Beyond this depth, display of subterms is replaced by dots. At the "
"time of writing this documentation, the default value is 50."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1000
msgid ""
"This option controls the compact display mode for goals contexts. When on, "
"the printer tries to reduce the vertical size of goals contexts by putting "
"several variables (even if of different types) on the same line provided it "
"does not exceed the printing width (see :opt:`Printing Width`). At the time "
"of writing this documentation, it is off by default."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1008
msgid ""
"This option controls whether unfocused goals are displayed. Such goals are "
"created by focusing other goals with bullets (see :ref:`bullets` or :ref:"
"`curly braces <curly-braces>`). It is off by default."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1014
msgid ""
"This option controls the printing of the “(dependent evars: …)” line when ``-"
"emacs`` is passed."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1021
msgid "Controlling the reduction strategies and the conversion algorithm"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1024
msgid ""
"|Coq| provides reduction strategies that the tactics can invoke and two "
"different algorithms to check the convertibility of types. The first "
"conversion algorithm lazily compares applicative terms while the other is a "
"brute-force but efficient algorithm that first normalizes the terms before "
"comparing them. The second algorithm is based on a bytecode representation "
"of terms similar to the bytecode representation used in the ZINC virtual "
"machine :cite:`Leroy90`. It is especially useful for intensive computation "
"of algebraic values, such as numbers, and for reflection-based tactics. The "
"commands to fine- tune the reduction strategies and the lazy conversion "
"algorithm are described first."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1038
msgid ""
"This command has an effect on unfoldable constants, i.e. on constants "
"defined by :cmd:`Definition` or :cmd:`Let` (with an explicit body), or by a "
"command assimilated to a definition such as :cmd:`Fixpoint`, :cmd:`Program "
"Definition`, etc, or by a proof ended by :cmd:`Defined`. The command tells "
"not to unfold the constants in the :n:`@qualid` sequence in tactics using δ-"
"conversion (unfolding a constant is replacing it by its definition)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1045
msgid ""
":cmd:`Opaque` has also an effect on the conversion algorithm of |Coq|, "
"telling it to delay the unfolding of a constant as much as possible when |"
"Coq| has to check the conversion (see Section :ref:`conversion-rules`) of "
"two distinct applied constants."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1053
msgid ""
"The scope of :cmd:`Opaque` is limited to the current section, or current "
"file, unless the variant :cmd:`Global Opaque` is used."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1058
#: ../../proof-engine/vernacular-commands.rst:1093
msgid ""
"Sections :ref:`performingcomputations`, :ref:`tactics-automating`, :ref:"
"`proof-editing-mode`"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1063
msgid ""
"There is no constant referred by :n:`@qualid` in the environment. "
"Nevertheless, if you asked :cmd:`Opaque` `foo` `bar` and if `bar` does not "
"exist, `foo` is set opaque."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1069
msgid ""
"This command is the converse of :cmd:`Opaque` and it applies on unfoldable "
"constants to restore their unfoldability after an Opaque command."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1072
msgid ""
"Note in particular that constants defined by a proof ended by Qed are not "
"unfoldable and Transparent has no effect on them. This is to keep with the "
"usual mathematical practice of *proof irrelevance*: what matters in a "
"mathematical development is the sequence of lemma statements, not their "
"actual proofs. This distinguishes lemmas from the usual defined constants, "
"whose actual values are of course relevant in general."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1083
msgid ""
"The scope of Transparent is limited to the current section, or current file, "
"unless the variant :cmd:`Global Transparent` is used."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1089
msgid "There is no constant referred by :n:`@qualid` in the environment."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1100
msgid ""
"This command generalizes the behavior of Opaque and Transparent commands. It "
"is used to fine-tune the strategy for unfolding constants, both at the "
"tactic level and at the kernel level. This command associates a level to the "
"qualified names in the :n:`@qualid` sequence. Whenever two expressions with "
"two distinct head constants are compared (for instance, this comparison can "
"be triggered by a type cast), the one with lower level is expanded first. In "
"case of a tie, the second one (appearing in the cast type) is expanded."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1110
msgid "Levels can be one of the following (higher to lower):"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1112
msgid ""
"``opaque`` : level of opaque constants. They cannot be expanded by tactics "
"(behaves like +∞, see next item)."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1114
msgid ""
":n:`@num` : levels indexed by an integer. Level 0 corresponds to the default "
"behavior, which corresponds to transparent constants. This level can also be "
"referred to as transparent. Negative levels correspond to constants to be "
"expanded before normal transparent constants, while positive levels "
"correspond to constants to be expanded after normal transparent constants."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1120
msgid ""
"``expand`` : level of constants that should be expanded first (behaves like "
"−∞)"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1125
msgid ""
"These directives survive section and module closure, unless the command is "
"prefixed by ``Local``. In the latter case, the behavior regarding sections "
"and modules is the same as for the :cmd:`Transparent` and :cmd:`Opaque` "
"commands."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1133
msgid ""
"This command prints the strategy currently associated to :n:`@qualid`. It "
"fails if :n:`@qualid` is not an unfoldable reference, that is, neither a "
"variable nor a constant."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1141
msgid "Print all the currently non-transparent strategies."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1146
msgid ""
"This command allows giving a short name to a reduction expression, for "
"instance lazy beta delta [foo bar]. This short name can then be used in "
"``Eval`` :n:`@ident` ``in`` ... or ``eval`` directives. This command accepts "
"the Local modifier, for discarding this reduction name at the end of the "
"file or module. For the moment the name cannot be qualified. In particular "
"declaring the same name in several modules or in several functor "
"applications will be refused if these declarations are not local. The name :"
"n:`@ident` cannot be used directly as an Ltac tactic, but nothing prevents "
"the user to also perform a ``Ltac`` `ident` ``:=`` `convtactic`."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1158
msgid ":ref:`performingcomputations`"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1164
msgid "Controlling the locality of commands"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1170
msgid ""
"Some commands support a Local or Global prefix modifier to control the scope "
"of their effect. There are four kinds of commands:"
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1174
msgid ""
"Commands whose default is to extend their effect both outside the section "
"and the module or library file they occur in.  For these commands, the Local "
"modifier limits the effect of the command to the current section or module "
"it occurs in.  As an example, the :cmd:`Coercion` and :cmd:`Strategy` "
"commands belong to this category."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1179
msgid ""
"Commands whose default behavior is to stop their effect at the end of the "
"section they occur in but to extend their effect outside the module or "
"library file they occur in. For these commands, the Local modifier limits "
"the effect of the command to the current module if the command does not "
"occur in a section and the Global modifier extends the effect outside the "
"current sections and current module if the command occurs in a section. As "
"an example, the :cmd:`Arguments`, :cmd:`Ltac` or :cmd:`Notation` commands "
"belong to this category. Notice that a subclass of these commands do not "
"support extension of their scope outside sections at all and the Global "
"modifier is not applicable to them."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1189
msgid ""
"Commands whose default behavior is to stop their effect at the end of the "
"section or module they occur in.  For these commands, the ``Global`` "
"modifier extends their effect outside the sections and modules they occur "
"in.  The :cmd:`Transparent` and :cmd:`Opaque` (see Section :ref:`vernac-"
"controlling-the-reduction-strategies`) commands belong to this category."
msgstr ""

#: ../../proof-engine/vernacular-commands.rst:1195
msgid ""
"Commands whose default behavior is to extend their effect outside sections "
"but not outside modules when they occur in a section and to extend their "
"effect outside the module or library file they occur in when no section "
"contains them.For these commands, the Local modifier limits the effect to "
"the current section or module while the Global modifier extends the effect "
"outside the module even when the command occurs in a section.  The :cmd:"
"`Set` and :cmd:`Unset` commands belong to this category."
msgstr ""
